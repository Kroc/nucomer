; nÃ¼comer diskzine (c) copyright Kroc Camen 2019-2023. unless otherwise noted,
; licenced under Creative Commons Attribution Non-Commercial Share-Alike 4.0
; licence; you may reuse and modify this code how you please as long as you:
;
; - retain the copyright notice
; - use the same licence for your derived code
; - do not use it for commercial purposes
;   (contact the author for a commercial licence)
;
; prg_logo.acme:
;===============================================================================
; after the bootstrap, the logo splash screen is shown and the main menu
; is loaded. this is done this way so that the logo screen can be discarded
; and overwritten after it is shown and not occupy RAM permenantly
; for a once-off screen
;
!source "nucomer.acme"          ; nucomer constants for memory layout

* = nu_logo


logo_boot:
;===============================================================================
; display the logo and chain-load the outfit:
;-------------------------------------------------------------------------------
        ; turn the screen off whilst we clear it
        lda # %00000000
        sta .VIC_SCREEN_CTL1

        ; change the VIC bank
        ;
        ldx .CIA2_PORTA_DDR     ; (backup current value)
        lda # %00000111         ; we only want to write to the low 3-bits
        sta .CIA2_PORTA_DDR     ; set the port's read/write state
        ;
        ; the bit value is the inverse of the bank number 0-3
        lda # (!NU_VIC_BANK) & %00000011
        sta .CIA2_PORTA

        ; we must restore the read/write state
        ; of the port or disk I/O will break!
        stx .CIA2_PORTA_DDR

        ; change the VIC memory layout to position the text-screen & char ROM
        lda # ((>nu_logo_screen & %00111100) << 2) | ((>$1800 & %00111000) >> 2)
        sta .VIC_LAYOUT

        ; patch interrupts:
        ;=======================================================================
        sei                     ; disable interrupts whilst we alter them

        ; turn off all interrupts on CIA1. note that bit 7 is used to fill all
        ; other bits that are given as 1! therefore, the value `%011111111` is
        ; instructing the port to set bits 0-6 to 0, therefore turning off all
        ; timers on the port
        ;
        lda # %01111111
        sta .CIA1_INTERRUPT
        ; repeat this also for CIA2 which uses the Non-Maskable-Interrupt
        ; ("NMI") for its timers
        sta .CIA2_INTERRUPT

        ; set the non-maskable interrupt location when the KERNAL is on.
        ; pressing the RESTORE key will fire this routine (unless disabled
        ; -- see comments on `nmi_disable` routine)
        lda #< nmi_kernalon
        sta .KERNAL_VECTOR_NMI+0
        lda #> nmi_kernalon
        sta .KERNAL_VECTOR_NMI+1

        ; likewise, when the KERNAL is off, an NMI handler
        ; must be specified or the machine will crash
        lda #< nmi_nokernal
        sta .HW_VECTOR_NMI+0
        lda #> nmi_nokernal
        sta .HW_VECTOR_NMI+1

        ; disable all forms of VIC-II interrupts
        ; (raster, light-pen, sprite collisions)
        lda # %00000000
        sta .VIC_INTERRUPT_CONTROL

        ; switch to the minimal interrupt
        ; handler for when the KERNAL is off
        lda #< irq_nokernal
        sta .HW_VECTOR_IRQ+LO
        lda #> irq_nokernal
        sta .HW_VECTOR_IRQ+HI

        ; and likewise for when the KERNAL is on
        lda #< irq_kernalon
        sta .KERNAL_VECTOR_IRQ+LO
        lda #> irq_kernalon
        sta .KERNAL_VECTOR_IRQ+HI

        cli                     ; enable interrupts

        ; load the tune:
        ;-----------------------------------------------------------------------
        lda # $e0               ; load 0th SID song
        ldx #< nu_song
        ldy #> nu_song
        jsr fastload_exo
        bcc +
        brk

        ; show the logo:
        ;-----------------------------------------------------------------------
+       jsr logo_screen

        ; load BSOD64:
        ;-----------------------------------------------------------------------
        lda # $c3               ; load BSOD64 ("C3.BSOD64")
        ldx #< bsod64
        ldy #> bsod64
        jsr fastload_exo
        bcc +
        brk

        ; load the font:
        ;-----------------------------------------------------------------------
+       lda # $f0               ; load 0th font ("F0...")
        ldx #< nu_font
        ldy #> nu_font
        jsr fastload_exo
        bcc +
        brk

        ; load the main outfit
        ;-----------------------------------------------------------------------
+       lda # %00110111
        sta .CPU_CONTROL

        ; we will not be returning here!
        ;
        lda #> (nu_main-1)
        pha
        lda #< (nu_main-1)
        pha

        lda # $c2               ; filename "C2*", i.e. the main outfit
        ldx #< nu_main
        ldy #> nu_main
        jmp fastload_exo


nmi_nokernal:
;===============================================================================
        ; when the KERNAL is off we must acknowledge the interrupt
        ; by reading from CIA2 otherwise the NMI becomes disabled 
        asl .CIA2_INTERRUPT

        ; fallthrough
        ; ...

nmi_kernalon:
        ;-----------------------------------------------------------------------
        ; when KERNAL is on, it will already have acknowledged the interrupt.
        ; the KERNAL does not push the registers to the stack for NMIs
        rti

irq_nokernal:
;===============================================================================
        ; when the KERNAL is off we must acknowledge the interrupt
        ; by reading from CIA1 otherwise it will instantly fire again 
        asl .CIA1_INTERRUPT
        rti


irq_kernalon:
;===============================================================================
        ; pull the registers from the stack
        ; (in reverse order)
        pla                     ; pull...
        tay                     ; ...Y
        pla                     ; pull...
        tax                     ; ...X
        pla                     ; pull A

        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti


wait_frames:
;===============================================================================
; wait for a given number of frames to pass:
;
; in:   X                       number of frames to wait (1-based)
;-------------------------------------------------------------------------------
-       jsr wait_frame
        dex
        bne -
        
        rts

wait_frame:
        ;-----------------------------------------------------------------------
        ; wait for a full cycle of the raster beam:
        ;
        ; bit 7 of $D011 is the upper-most bit of the current raster line,
        ; i.e. when it is 0 the beam is on lines 0-255 and when it's 1 the
        ; beam is on lines 256+ -- PAL has 312 lines, NTSC has 262 lines
        ; but some very early NTSC machines have 263 lines
        ;
        ; first, we wait for the beam to enter the top of the screen
        ; (lines 0-255), this is so that if the beam is currently within the
        ; bottom of the screen (lines 256+), we wait for it to go back around
        ; and don't trigger early
        ;
-       bit .VIC_SCREEN_VERT
        bmi -                   ; wait until bit 7 is 0

        ; now wait for the addressible screen to pass and the vblank
        ; to begin again, this syncronises the main thread with the vblank
-       bit .VIC_SCREEN_VERT
        bpl -                   ; wait until bit 7 is 1

        rts

;===============================================================================
!source "logo/logo.acme"
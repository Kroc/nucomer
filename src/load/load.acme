; COVERT BITOPS Autoconfiguring Loader/Depacker V2.28
; with 1541/1571/1581/CMD FD/CMD HD/IDE64/Fastdrive-emu autodetection & support
;
; - EXOMIZER 2 & 3 depack by Magnus Lind & Krill
; - PUCRUNCH depack by Pasi Ojala
; - 1581/CMD FD/CMD HD information from Ninja & DocBacardi /The Dreams
; - 2MHz 2-bit transfer delay code by MagerValp
; - ACME port by Kroc Camen
; - rest by Lasse Öörni
;
; thanks to K.M/TABOO for inspiration on badline detection and 1-bit transfer,
; and Marko Mäkelä for his original irqloader.s (huge inspiration)
;
!cpu    6502

;-------------------------------------------------------------------------------
; Include your loader configuration file at this point!
;-------------------------------------------------------------------------------

!zone   fastloader {
;-------------------------------------------------------------------------------
; Defines derived from the compile options (need not be changed)
;-------------------------------------------------------------------------------

.zp_loadtempreg         = zpbase2+0     ; temp variables for the loader
.zp_bufferstatus        = zpbase2+1     ; bytes in fastload buffer
.zp_fileopen            = zpbase2+2     ; file open indicator
.zp_fastloadstatus      = zpbase2+3     ; fastloader active indicator

.zp_destlo              = zpbase+0
.zp_desthi              = zpbase+1

; other defines
;-------------------------------------------------------------------------------
.MW_LENGTH              = 32            ; no. bytes in one Memory-Write command

!addr {

; KERNAL zero-page variables:
.zp_kernal_status       = $90
.zp_kernal_messages     = $9d
.zp_kernal_fa           = $ba

; disk-drive variables:
acsbf                   = $01           ; buffer 1 command
trkbf                   = $08           ; buffer 1 track
sctbf                   = $09           ; buffer 1 sector
iddrv0                  = $12           ; disk drive ID
drvtemp                 = $06           ; temp variable
id                      = $16           ; disk ID

buf                     = $0400         ; sector data buffer
drvstart                = $0500         ; start of drive-code
drv_sendtblhigh         = $0700         ; 256-byte table for 2-bit send optimization
initialize              = $d005         ; initialize routine in 1541 ROM

; KERNAL routines
.kernal_ciout           = $ffa8
.kernal_listen          = $ffb1
.kernal_second          = $ff93
.kernal_unlsn           = $ffae
.kernal_talk            = $ffb4
.kernal_tksa            = $ff96
.kernal_untlk           = $ffab
.kernal_acptr           = $ffa5
.kernal_chkin           = $ffc6
.kernal_chkout          = $ffc9
.kernal_chrin           = $ffcf
.kernal_chrout          = $ffd2
.kernal_close           = $ffc3
.kernal_open            = $ffc0
.kernal_setmsg          = $ff90
.kernal_setnam          = $ffbd
.kernal_setlfs          = $ffba
.kernal_clrchn          = $ffcc
.kernal_getin           = $ffe4
.kernal_load            = $ffd5
.kernal_save            = $ffd8
}

;-------------------------------------------------------------------------------
; Resident portion of loader (routines that you're going to use at runtime)
;-------------------------------------------------------------------------------

!if LOADFILE_UNPACKED > 0 {
        !source "load/load_unpacked.acme"
}

!if LOADFILE_EXOMIZER > 0 {
        !source "load/load_exomizer.acme"
}

!if LOADFILE_PUCRUNCH > 0 {
        !source "load/load_pucrunch.acme"
}

;===============================================================================
; openfile:
;
; opens a file either with slow or fast loader.
; if a file is already open, does nothing!
;
; parameters: X (low),Y (high): Address of null-terminated filename
; returns: -
; modifies: A,X,Y
;
openfile:
        ;-----------------------------------------------------------------------
        lda .zp_fileopen        ; a file already open?
        beq +                   ; no, go ahead and open
        
        rts

+       !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                stx .zp_destlo
                sty .zp_desthi
        } else {;///////////////////////////////////////////////////////////////
                ; two-letter file-name
                stx .filename+0
                sty .filename+1
        }       ;///////////////////////////////////////////////////////////////
        inc .zp_fileopen        ; "file opened"
        lda usefastload
        bne fastopen

;===============================================================================
; SLOWOPEN
;
; Opens a file without fastloader.
;
; Parameters: A:0 (it always is at this point)
; Returns: -
; Modifies: A,X,Y
;
slowopen:
        ;-----------------------------------------------------------------------
        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                tay
        }       ;///////////////////////////////////////////////////////////////
        jsr kernalon

        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
-               iny
                lda (.zp_destlo), y
                bne -
                tya
                ldx .zp_destlo
                ldy .zp_desthi
        } else {;///////////////////////////////////////////////////////////////
                lda # $03
                ldx #< .filename
                ldy #> .filename
        }       ;///////////////////////////////////////////////////////////////

        jsr .kernal_setnam
        lda # $02
        ldy # $00
        jsr setlfsdevice
        jsr .kernal_open
        ldx # $02               ; file number
        jsr .kernal_chkin
        jmp kernaloff

;===============================================================================
; fastopen:
;
; opens a file with fastloader. Uses an asynchronous protocol inspired by
; Marko Mäkelä's work when sending the filename.
;
; parameters: -
; returns: -
; modifies: A,X,Y
;
fastopen:
        ;-----------------------------------------------------------------------
        jsr initfastload        ; if fastloader is not yet initted, init it now
        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                ldy # $00
fastload_sendouter:
                lda (.zp_destlo), y
                sta .zp_loadtempreg
                pha
                ldx # $08       ; bit counter
        } else {;///////////////////////////////////////////////////////////////
                ldx # $01
fastload_sendouter:
                ldy # $08       ; bit counter
        }       ;///////////////////////////////////////////////////////////////

fastload_sendinner:
        bit $dd00               ; wait for both DATA & CLK to go high
        bpl fastload_sendinner
        bvc fastload_sendinner
        !if LONG_NAMES = 0 {
                ;///////////////////////////////////////////////////////////////
                lsr .filename, x
        } else {;///////////////////////////////////////////////////////////////
                lsr .zp_loadtempreg
        }       ;///////////////////////////////////////////////////////////////
        lda # $10
        ora $dd00
        bcc +
        eor # $30
        ; zero-bit:
+       sta $dd00               ; wait for CLK & DATA low
        lda # $c0               ; (answer from disk-drive)
        ; send-back:
-       bit $dd00
        bne -
        lda # $ff-$30           ; set DATA and CLK high
        and $dd00
        sta $dd00
        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                dex
                bne fastload_sendinner
                iny
                pla
                bne fastload_sendouter
        } else {;///////////////////////////////////////////////////////////////
                dey
                bne fastload_sendinner
                dex
                bpl fastload_sendouter
        }       ;///////////////////////////////////////////////////////////////
        sta $d07a               ; SCPU to slow mode
        ; pre-delay:
-       dex                     ; delay to make sure the 1541 has set
        bne -                   ; DATA high / CLK low before we continue

fastload_fillbuffer:
        ldx .zp_fileopen
        beq fileclosed
        pha
        sta $d07a               ;SCPU to slow mode
        
        !if TWOBIT_PROTOCOL > 0 {
                ;///////////////////////////////////////////////////////////////
                ldx # $00
                lda # $03
                sta .zp_loadtempreg        ;And operand for NTSC delay
        }       ;///////////////////////////////////////////////////////////////

        ; fill-buffer wait:
-       bit $dd00               ; wait for 1541 to signal
        bvc -                   ; data ready by setting CLK high

        !if TWOBIT_PROTOCOL > 0 {
                ;///////////////////////////////////////////////////////////////
fastload_fbloop:
                sei
fastload_waitbadline:
                lda $d011               ;Check that a badline won't disturb
                clc                     ;the timing
                sbc $d012
                and # $07
                beq fastload_waitbadline
                lda $dd00
                ora # $10
                sta $dd00               ;CLK=low to begin transfer
fastload_delay: and # $03
                sta fastload_eor+1
                sta $dd00
fastload_receivebyte:
                lda $dd00
                lsr
                lsr
                eor $dd00
                lsr
                lsr
                eor $dd00
                lsr
                lsr
                eor $dd00
                cli
fastload_eor:   eor # $00
                sta loadbuffer, x
                inx
                bne fastload_fbloop

        } else {;///////////////////////////////////////////////////////////////

                !if (loadbuffer & $ff) != 0 {
                    !error "loadbuffer is not aligned!"
                }

                pha                       ;Some delay before beginning
                pla
                pha
                pla
fastload_fillbufferloop:                  ;1bit receive code
                nop
                nop
                ldx # $08                  ;Bit counter
fastload_bitloop:
                nop
                lda # $10
                eor $dd00                 ;Take databit
                sta $dd00                 ;Store reversed clockbit
                asl
fastload_store: ror loadbuffer
                dex
                bne fastload_bitloop
                !if BORDER_FLASHING > 0 {
                        ;///////////////////////////////////////////////////////
                        dec $d020
                        inc $d020
                }       ;///////////////////////////////////////////////////////
                inc fastload_store+1
                bne fastload_fillbufferloop
                
        }       ;///////////////////////////////////////////////////////////////

fillbuffer_common:
        lda # $02                        ;Reset buffer read pos.
        sta .zp_bufferstatus
        ldx # $ff
        lda loadbuffer                  ;Full 254 bytes?
        bne @fullbuffer
        ldx loadbuffer+1                ;End of load?
        bne @noloadend
        stx .zp_fileopen                   ;Clear fileopen indicator
        lda loadbuffer+2                ;Read the return/error code
        sta fileclosed+1

@noloadend:
@fullbuffer:
        stx fastload_endcmp+1
        pla
        clc
        bcc getbyte_restx

fileclosed:
        lda # $00
        sec
        bcs getbyte_restx

;===============================================================================
; GETBYTE
;
; Gets a byte from an opened file.
;
; Parameters: -
; Returns: C=0 OK, A contains byte
;          C=1 File stream ended. A contains the error code:
;              $00 - OK, end of file
;              $02 - File not found
; Modifies: A
;
getbyte:
        ;-----------------------------------------------------------------------
        stx getbyte_restx+1
getbyte_usefastload:
        lda # $00
        beq slowload_getbyte
fastload_getbyte:
        ldx .zp_bufferstatus
        lda loadbuffer, x
fastload_endcmp:
        cpx # $00                       ;Reach end of buffer?
        bcs fastload_fillbuffer
        inc .zp_bufferstatus
getbyte_restx:
        ldx # $00
        rts

slowload_getbyte:
        lda .zp_fileopen
        beq fileclosed
        jsr kernalon
        jsr .kernal_chrin
        ldx .zp_kernal_status
        bne slowload_eof
        jsr kernaloff
        clc
        bcc getbyte_restx
slowload_eof:
        pha
        txa
        and # $03
        sta fileclosed+1        ;EOF - store return code
        dec .zp_fileopen
        sty getbyte_resty+1
        jsr close_kernaloff
getbyte_resty:
        ldy # $00
        pla
        ldx fileclosed+1        ;Check return code, if nonzero,
        cpx # $01                ;return with carry set and return
        bcc getbyte_restx       ;code in A
        txa
        bcs getbyte_restx

!if LOAD_UNDER_IO > 0 {
;///////////////////////////////////////////////////////////////////////////////
; disable I/O:
;
; stores $01 status, disables interrupts & IO area
;
; Parameters: -
; Returns: -
; Modifies: -
;
disableio:
        ;-----------------------------------------------------------------------
        pha
        lda $01
        sta enableio_01+1
        lda # $34
        sei
        sta $01
        pla
        rts

;===============================================================================
; enable I/O:
;
; restores $01 status and enables interrupts
;
; Parameters: -
; Returns: -
; Modifies: -
;
enableio:
        ;-----------------------------------------------------------------------
        pha
enableio_01:
        lda # $36
        sta $01
        cli
        pla
        rts

;///////////////////////////////////////////////////////////////////////////////
}

;-------------------------------------------------------------------------------
; SETLFSDEVICE
;
; Gets the last used device number and performs a SETLFS.
;
; Parameters: -
; Returns: -
; Modifies: X
;
setlfsdevice:
        ;-----------------------------------------------------------------------
        ldx .zp_kernal_fa
        jmp .kernal_setlfs

;===============================================================================
; KERNALON
;
; switches KERNAL on to prepare for slow loading.
; saves state of $01
;
; Parameters: -
; Returns: -
; Modifies: X
;
kernalon:
        ;-----------------------------------------------------------------------
        ldx $01
        stx kernaloff+1
        ldx # $36
        stx $01
        rts

;===============================================================================
; CLOSE_KERNALOFF
;
; Closes file 2 and then restores state of $01.
;
; Parameters: -
; Returns: -
; Modifies: A,X,Y
;
close_kernaloff:
        ;-----------------------------------------------------------------------
        lda # $02
        jsr .kernal_close
        jsr .kernal_clrchn

;===============================================================================
; KERNALOFF
;
; Restores state of $01.
;
; Parameters: -
; Returns: -
; Modifies: X
;
kernaloff:
        ;-----------------------------------------------------------------------
        ldx # $36
        stx $01
il_ok:
        rts

;===============================================================================
; INITFASTLOAD
;
; Uploads the fastloader to disk drive memory and starts it.
;
; Parameters: -
; Returns: -
; Modifies: A,X,Y
;
initfastload:
        ;-----------------------------------------------------------------------
        lda usefastload         ; if fastloader not needed, do nothing
        beq il_ok
        lda .zp_fastloadstatus  ; if fastloader already initted,
        bne il_ok               ; do nothing
        inc .zp_fastloadstatus
        lda #< drivecode
        ldx #> drivecode
        ldy # (drvend-drvstart+.MW_LENGTH-1) / .MW_LENGTH

ifl_begin:
        sta ifl_senddata+1
        stx ifl_senddata+2
        sty .zp_loadtempreg      ; number of "packets" to send
        jsr kernalon
        lda #> drvstart
        sta ifl_mwstring+1
        ldy # $00
        sty ifl_mwstring+2      ; drivecode starts at lowbyte 0
        beq ifl_nextpacket
ifl_sendmw:
        lda ifl_mwstring, x      ;Send M-W command (backwards)
        jsr .kernal_ciout
        dex
        bpl ifl_sendmw
        ldx # .MW_LENGTH
ifl_senddata:
        lda drivecode, y        ; send one byte of drivecode
        jsr .kernal_ciout
        iny
        bne ifl_notover
        inc ifl_senddata+2
ifl_notover:
        inc ifl_mwstring+2      ; also, move the M-W pointer forward
        bne ifl_notover2
        inc ifl_mwstring+1
ifl_notover2:
        dex
        bne ifl_senddata
        jsr .kernal_unlsn               ; unlisten to perform the command
ifl_nextpacket:
        lda .zp_kernal_fa                  ; set drive to listen
        jsr .kernal_listen
        lda .zp_kernal_status
        cmp # $c0
        beq ifl_error           ; abort if serial error (IDE64!)
        lda # $6f
        jsr .kernal_second
        ldx # $05
        dec .zp_loadtempreg      ; all "packets" sent?
        bpl ifl_sendmw
ifl_sendme:
        lda ifl_mestring-1, x    ; send M-E command (backwards)
        jsr .kernal_ciout
        dex
        bne ifl_sendme
        jsr .kernal_unlsn
ifl_error:
        jmp kernaloff

;-------------------------------------------------------------------------------
; DRIVECODE - Code executed in the disk drive.
;-------------------------------------------------------------------------------

; address in C64's memory
drivecode:

!pseudopc drvstart {

; address in diskdrive's memory
drvmain:
!if TWOBIT_PROTOCOL > 0 {
        ;///////////////////////////////////////////////////////////////////////
        jsr drv_initsendtbl     ; one-time init for 2MHz send
}       ;///////////////////////////////////////////////////////////////////////
        cli                     ;File loop: Get filename first
        lda # $00                ;Set DATA & CLK high
drv_1800ac0:
        sta $1800
        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                ldx # $00
        } else {;///////////////////////////////////////////////////////////////
                ldx # $01
        }       ;///////////////////////////////////////////////////////////////
drv_nameloop:
        ldy # $08                ;Bit counter
drv_namebitloop:
drv_1800ac1:
        lda $1800
        bpl drv_noquit          ;Quit if ATN is low
        jmp drv_quit
drv_noquit:
        and # $05                ;Wait for CLK or DATA going low
        beq drv_namebitloop
        lsr                     ;Read the data bit
        lda # $02                ;Pull the other line low to acknowledge
        bcc drv_namezero ;the bit being received
        lda # $08
drv_namezero:
        ror drv_filename, x      ;Store the data bit
drv_1800ac2:
        sta $1800
drv_namewait:
drv_1800ac3:
        lda $1800               ;Wait for either line going high
        and # $05
        cmp # $05
        beq drv_namewait
        lda # $00
drv_1800ac4:
        sta $1800               ;Set both lines high
        dey
        bne drv_namebitloop     ;Loop until all bits have been received
        sei                     ;Disable interrupts after first byte
        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                inx
                lda drv_filename-1, x    ;End of filename?
                bne drv_nameloop
        } else {;///////////////////////////////////////////////////////////////
                dex
                bpl drv_nameloop
        }       ;///////////////////////////////////////////////////////////////

        lda # $08                ;CLK low, data isn't available
drv_1800ac5:
        sta $1800

drv_dirtrk:
        ldx $1000
drv_dirsct:
        ldy $1000               ;Read disk directory
drv_dirloop:
        jsr drv_readsector      ;Read sector
        ldy # $02
drv_nextfile:
        lda buf, y               ;File type must be PRG
        and # $83
        cmp # $82
        bne drv_notfound
        !if LONG_NAMES > 0 {
                ;///////////////////////////////////////////////////////////////
                ldx # $03
                sty drv_namelda+1
                lda # $a0                ;Make an endmark at the 16th letter
                sta buf+19, y
drv_namecmploop:
                lda drv_filename-3, x    ;Check for wildcard first
                cmp # $2a
                beq drv_found
drv_namelda:
                lda buf, x               ;Check against each letter of filename,
                cmp drv_filename-3, x    ;break on mismatch
                bne drv_namedone
                inx
                bne drv_namecmploop
drv_namedone:   cmp # $a0                ;If got endmark in both filenames, found
                bne drv_notfound
                lda drv_filename-3, x
                beq drv_found
        } else {;///////////////////////////////////////////////////////////////
                lda buf+3, y
                cmp drv_filename
                bne drv_notfound
                lda buf+4, y
                cmp drv_filename+1
                beq drv_found
        }
drv_notfound:
        tya
        clc
        adc # $20
        tay
        bcc drv_nextfile
        ldy buf+1               ;Go to next directory block, go on until no
        ldx buf                 ;more directory blocks
        bne drv_dirloop
drv_filenotfound:
        ldx # $02                ;Return code $02 = File not found
drv_loadend:
        stx buf+2
        lda # $00
        sta buf
        sta buf+1
        beq drv_sendblk

drv_quit:                               ;If ATN, exit to drive ROM code
drv_drivetype:
        ldx # $00
        bne drv_quitnot1541
        lda # $1a                       ;Restore data direction register
        sta $1802
        jmp initialize

drv_quitnot1541:
        rts

drv_found:
        iny
drv_nextsect:
        ldx buf, y       ;File found, get starting track & sector
        beq drv_loadend ;At file's end? (return code $00 = OK)
        lda buf+1, y
        tay
        jsr drv_readsector      ;Read the data sector

!if TWOBIT_PROTOCOL > 0 {
        ;///////////////////////////////////////////////////////////////////////
drv_sendblk:
drv_sendloop:
drv_2mhzsend:
        lda buf
        ldx # $00                        ;Set CLK=high to mark data available
drv_1800ac6:
        stx $1800
        tay
        and # $0f
        tax
        lda # $04                        ;Wait for CLK=low
drv_1800ac7:
        bit $1800
        beq drv_1800ac7
        lda drv_sendtbl, x
        nop
        nop
drv_1800ac8:
        sta $1800
        asl
        and # $0f
        cmp ($00, x)
        nop
drv_1800ac9:
        sta $1800
        lda drv_sendtblhigh, y
        cmp ($00, x)
        nop
drv_1800ac10:
        sta $1800
        asl
        and # $0f
        cmp ($00, x)
        nop
drv_1800ac11:
        sta $1800
        inc drv_2mhzsend+1
        bne drv_2mhzsend
        nop
drv_2mhzsenddone:
        lda # $08                ;CLK low, data isn't available
drv_1800ac12:
        sta $1800
        ldy # $00
 
} else {;///////////////////////////////////////////////////////////////////////

drv_sendblk:
        lda # $04                ;Bitpair counter/
        ldx # $00                ;compare-value for CLK-line
drv_1800ac6:
        stx $1800               ;CLK & DATA high -> ready to go
drv_sendloop:
        ldx buf
drv_zpac1:
        stx drvtemp
        tay                     ;Bitpair counter
drv_sendloop_bitpair:
        ldx # $00
drv_zpac2:
        lsr drvtemp
        bcs drv_sendloop_wait1
        ldx # $02
drv_sendloop_wait1:
drv_1800ac7:
        bit $1800               ;Wait until CLK high
        bne drv_sendloop_wait1
drv_1800ac8:
        stx $1800
        ldx # $00
drv_zpac3:
        lsr drvtemp
        bcs drv_sendloop_wait2
        ldx # $02
drv_sendloop_wait2:
drv_1800ac9:
        bit $1800
        beq drv_sendloop_wait2  ;Wait until CLK low
drv_1800ac10:
        stx $1800
        dey
        bne drv_sendloop_bitpair
        inc drv_sendloop+1
        bne drv_sendloop
drv_sendloop_endwait:
drv_1800ac11:
        bit $1800               ;Wait for CLK high
        bne drv_sendloop_endwait
        asl                     ;Set CLK low, DATA high
drv_1800ac12:
        sta $1800               ;(more data yet not ready)

}       ;///////////////////////////////////////////////////////////////////////

        lda buf                 ;First 2 bytes zero marks end of loading
        ora buf+1               ;(3rd byte is the return code)
        bne drv_nextsect
        jmp drvmain

drv_readsector:
        jsr drv_led
drv_readtrk:
        stx $1000
drv_readsct:
        sty $1000
drv_retry:
        lda # $80
        ldx # 1
drv_execjsr:
        jsr drv_1541exec        ;Exec buffer 1 job
        cmp # $02                ;Error?
        bcs drv_retry           ;Retry indefinitely
drv_success:
        sei                     ;Make sure interrupts now disabled
drv_led:
        lda # $08                ;Flash the drive LED
drv_ledac1:
        eor $1c00
drv_ledac2:
        sta $1c00
        rts

drv_1541exec:
        sta $01
        cli                     ;Allow interrupts & execute command
drv_1541execwait:
        lda $01
        bmi drv_1541execwait
        pha
        lda id                  ;Handle disk ID change
        sta iddrv0
        lda id+1
        sta iddrv0+1
        pla
        rts

drv_fdexec:
        jsr $ff54               ;FD2000 fix by Ninja
        lda $03
        rts

        !if TWOBIT_PROTOCOL > 0 {
                ;///////////////////////////////////////////////////////////////
drv_initsendtbl:
                lda drv_drivetype+1     ;1541?
                bne drv_not1541
                lda $e5c6
                cmp # $37
                bne drv_not1571         ;Enable 2Mhz mode on 1571
                jsr $904e
drv_not1571:    
                lda # $7a                ;Set data direction so that can compare against $1800 being zero
                sta $1802
drv_not1541:
                ldx # $00
drv_sendtblloop:
                txa                     ;Build high nybble send table
                lsr
                lsr
                lsr
                lsr
                tay
                lda drv_sendtbl, y
                sta drv_sendtblhigh, x
                inx
                bne drv_sendtblloop
                rts
drv_sendtbl:
                !byte   $0f, $07, $0d, $05
                !byte   $0b, $03, $09, $01
                !byte   $0e, $06, $0c, $04
                !byte   $0a, $02, $08, $00

        }       ;///////////////////////////////////////////////////////////////

drv_1541dirtrk:
        !byte   18
drv_1541dirsct:
        !byte   1
drv_1581dirsct:
        !byte   3
drv_filename:

drvend:
        !if drvend > drv_sendtblhigh {
                !error
        }

} ;< end !pseudopc

;-------------------------------------------------------------------------------
; M-W and M-E command strings
;-------------------------------------------------------------------------------
ifl_mwstring:
        ; "Write-Memory"
        !byte   .MW_LENGTH, $00, $00
        !pet    "W-M"

ifl_mestring:
        ; "Execute-Memory"
        !byte   >drvstart, <drvstart
        !pet    "E-M"

;===============================================================================
; filename (in short name mode)
;
!if LONG_NAMES = 0 {
;///////////////////////////////////////////////////////////////////////////////
.filename:
        !byte   "00*"
;///////////////////////////////////////////////////////////////////////////////
}

;-------------------------------------------------------------------------------
; Loader configuration
;-------------------------------------------------------------------------------
usefastload:
        ; if nonzero, fast-loading will be used (auto-configured)
        !byte   0
useserial:
        ; if non-zero, serial protocol is in use and IRQs can't be used
        ; reliably while KERNAL file I/O is in progress
        !byte   1

;-------------------------------------------------------------------------------
; Disposable portion of loader (routines only needed when initializing)
;-------------------------------------------------------------------------------

;===============================================================================
; INITLOADER
;
; Inits the loadersystem. Must only be called only once in the beginning.
;
; Parameters: -
; Returns: -
; Modifies: A,X,Y
;
initloader:
        ;-----------------------------------------------------------------------
        sta $d07f               ; disable SCPU hardware regs
        lda # $00
        sta .zp_kernal_messages ; disable KERNAL messages
        sta .zp_fastloadstatus  ; initial fastload status = off
        sta .zp_fileopen        ; no file initially open

        !if TWOBIT_PROTOCOL>0 {
                ;///////////////////////////////////////////////////////////////
                sei
                tax
il_detectntsc1: lda $d012               ; detect PAL/NTSC/Drean
il_detectntsc2: cmp $d012
                beq il_detectntsc2
                bmi il_detectntsc1
                cmp # $20
                bcc il_isntsc
il_countcycles: inx
                lda $d012
                cmp # $28
                bcc il_countcycles
                cpx # $e8
                bcc il_ispal
                bcs il_isdrean
il_isntsc:      ; adjust 2-bit fastload transfer delay for NTSC / Drean
il_isdrean:     lda # $25
                sta fastload_delay
                lda # .zp_loadtempreg
                sta fastload_delay+1
il_ispal:       cli
        }       ;///////////////////////////////////////////////////////////////

il_detectdrive:
        lda # $aa
        sta $a5
        lda #< il_drivecode
        ldx #> il_drivecode
        ldy # (il_driveend-il_drivecode+.MW_LENGTH-1)/.MW_LENGTH
        jsr ifl_begin                   ;Upload test-drivecode
        lda .zp_kernal_status                      ;If serial error here, not a
        cmp # $c0                        ;serial device
        beq il_noserial
        ldx # $00
        ldy # $00
il_delay:
        inx                             ;Delay to make sure the test-
        bne il_delay                    ;drivecode executed to the end
        iny
        bpl il_delay
        lda .zp_kernal_fa                          ;Set drive to listen
        jsr .kernal_listen
        lda # $6f
        jsr .kernal_second
        ldx # $05
il_ddsendmr:
        lda .il_mrstring, x               ;Send M-R command (backwards)
        jsr .kernal_ciout
        dex
        bpl il_ddsendmr
        jsr .kernal_unlsn
        lda .zp_kernal_fa
        jsr .kernal_talk
        lda # $6f
        jsr .kernal_tksa
        lda # $00
        jsr .kernal_acptr                       ;First byte: test value
        pha
        jsr .kernal_acptr                       ;Second byte: drive type
        tax
        jsr .kernal_untlk
        pla
        cmp # $aa                        ;Drive can execute code, so can
        beq il_fastloadok               ;use fastloader
        lda $a5                         ;If serial bus delay counter
        cmp # $aa                        ;untouched, not a serial device
        bne il_nofastload
il_noserial:
        dec useserial                   ;Serial bus not used: switch to
il_nofastload:
        rts                             ;"fake" IRQ-loading mode

il_fastloadok:
        sta usefastload                 ;Perform patching of drivecode according to detected type
        sta getbyte_usefastload+1
        !if TWOBIT_PROTOCOL > 0 {
                ;///////////////////////////////////////////////////////////////
                ; for 1541, need to copy the 1MHz transfer code
                tax
                bpl il_not1571  ; $ff = 1571, turn to $00 (1541)
                inx
                beq il_2mhzdrive
il_not1571:     bne il_2mhzdrive
                ldy #drv_1mhzsenddone-drv_1mhzsend-1
il_copy1mhzcode:lda il_drv1mhzsend, y
                sta drv_2mhzsend-drvstart+drivecode, y
                dey
                bpl il_copy1mhzcode
il_2mhzdrive:
        }
        stx il_drivetype+1
        stx drv_drivetype+1-drvstart+drivecode
        txa
        beq il_skippatch1800            ;$1800 patching not needed for 1541
        lda .il_1800lo-1, x               ;Perform patching of drivecode
        sta il_patch1800lo+1
        lda .il_1800hi-1, x
        sta il_patch1800hi+1
        ldy #12
il_patchloop:
        ldx .il_1800ofs, y
il_patch1800lo:
        lda # $00                        ;Patch all $1800 accesses
        sta drvmain+1-drvstart+drivecode, x
il_patch1800hi:
        lda # $00
        sta drvmain+2-drvstart+drivecode, x
        dey
        bpl il_patchloop
il_skippatch1800:
il_drivetype:
        ldx # $00
        lda .il_dirtrklo, x               ;Patch directory
        sta drv_dirtrk+1-drvstart+drivecode
        lda .il_dirtrkhi, x
        sta drv_dirtrk+2-drvstart+drivecode
        lda .il_dirsctlo, x
        sta drv_dirsct+1-drvstart+drivecode
        lda .il_dirscthi, x
        sta drv_dirsct+2-drvstart+drivecode
        lda .il_execlo, x                 ;Patch job exec address
        sta drv_execjsr+1-drvstart+drivecode
        lda .il_exechi, x
        sta drv_execjsr+2-drvstart+drivecode
        lda .il_jobtrklo, x               ;Patch job track/sector
        sta drv_readtrk+1-drvstart+drivecode
        clc
        adc # $01
        sta drv_readsct+1-drvstart+drivecode
        lda .il_jobtrkhi, x
        sta drv_readtrk+2-drvstart+drivecode
        adc # $00
        sta drv_readsct+2-drvstart+drivecode
        !if TWOBIT_PROTOCOL=0 {
                ;///////////////////////////////////////////////////////////////
                lda .il_zp, x                     ;Patch zeropage temp usage
                sta drv_zpac1+1-drvstart+drivecode
                sta drv_zpac2+1-drvstart+drivecode
                sta drv_zpac3+1-drvstart+drivecode
        }
        lda .il_ledenabled, x             ;Patch LED flashing
        sta drv_led-drvstart+drivecode
        lda .il_ledbit, x
        sta drv_led+1-drvstart+drivecode
        lda .il_ledadrhi, x
        sta drv_ledac1+2-drvstart+drivecode
        sta drv_ledac2+2-drvstart+drivecode
        rts

;-------------------------------------------------------------------------------
; IL_DRIVECODE - Drivecode used to detect drive type & test if drivecode
; execution works OK
;-------------------------------------------------------------------------------

il_drivecode:
!pseudopc       drvstart {

                asl ild_return1         ;Modify first returnvalue to prove
                                        ;we've executed something :)
                lda $fea0               ;Recognize drive family
                ldx # 3                  ;(from Dreamload)
ild_floop:      cmp ild_family-1, x
                beq ild_ffound
                dex                     ;If unrecognized, assume 1541
                bne ild_floop
                beq ild_1541
ild_ffound:     lda ild_idloclo-1, x
                sta ild_idlda+1
                lda ild_idlochi-1, x
                sta ild_idlda+2
ild_idlda:      lda $fea4               ;Recognize drive type
                ldx # 3                  ;3 = CMD HD
ild_idloop:     cmp ild_id-1, x          ;2 = CMD FD
                beq ild_idfound         ;1 = 1581
                dex                     ;0 = 1541
                bne ild_idloop
ild_1541:       
                !if TWOBIT_PROTOCOL > 0 {
                        lda $e5c6
                        cmp # $37
                        bne ild_idfound         ;Recognize 1571 as a subtype
                        dex                     ;$ff = 1571
                }
ild_idfound:    stx ild_return2
                rts

ild_family:
        !byte   $43, $0d, $ff
ild_idloclo:
        !byte   $a4, $c6, $e9
ild_idlochi:
        !byte   $fe, $e5, $a6
ild_id:
        !byte   "8", "F", "H"

ild_return1:
        !byte   $55
ild_return2:
        !byte   0

} ;< end of !pseudopc

il_driveend:

;-------------------------------------------------------------------------------
; IL_DRV1MHZSEND - 2-bit protocol send code for 1MHz drives
;-------------------------------------------------------------------------------
!if TWOBIT_PROTOCOL > 0 {
;///////////////////////////////////////////////////////////////////////////////

il_drv1mhzsend:
!pseudopc       drv_2mhzsend {

drv_1mhzsend:
        ldx # $00
drv_1mhzsendloop:
        lda buf
        tay
        and # $0f
        stx $1800
        tax
        lda drv_sendtbl, x
drv_1mhzwait:
        ldx $1800
        beq drv_1mhzwait
        sta $1800
        asl
        and # $0f
        sta $1800
        lda drv_sendtblhigh, y
        sta $1800
        asl
        and # $0f
        sta $1800
        inc drv_1mhzsendloop+1
        bne drv_1mhzsendloop
        beq drv_2mhzsenddone

drv_1mhzsenddone:

}       ;< end of drive addressing
;///////////////////////////////////////////////////////////////////////////////
}

.il_mrstring:
        !byte   2, >ild_return1, <ild_return1
        !pet    "R-M"

.il_1800ofs:
        !byte   drv_1800ac0-drvmain
        !byte   drv_1800ac1-drvmain
        !byte   drv_1800ac2-drvmain
        !byte   drv_1800ac3-drvmain
        !byte   drv_1800ac4-drvmain
        !byte   drv_1800ac5-drvmain
        !byte   drv_1800ac6-drvmain
        !byte   drv_1800ac7-drvmain
        !byte   drv_1800ac8-drvmain
        !byte   drv_1800ac9-drvmain
        !byte   drv_1800ac10-drvmain
        !byte   drv_1800ac11-drvmain
        !byte   drv_1800ac12-drvmain

.il_1800lo:
        !byte   <$4001, <$4001, <$8000
.il_1800hi:
        !byte   >$4001, >$4001, >$8000

.il_dirtrklo:
        !byte   <drv_1541dirtrk, <$022b, <$54, <$2ba7
.il_dirtrkhi:
        !byte   >drv_1541dirtrk, >$022b, >$54, >$2ba7
.il_dirsctlo:
        !byte   <drv_1541dirsct, <drv_1581dirsct, <$56, <$2ba9
.il_dirscthi:
        !byte   >drv_1541dirsct, >drv_1581dirsct, >$56, >$2ba9

.il_execlo:
        !byte   <drv_1541exec, <$ff54, <drv_fdexec, <$ff4e
.il_exechi:
        !byte   >drv_1541exec, >$ff54, >drv_fdexec, >$ff4e

.il_jobtrklo:
        !byte <$0008, <$000d, <$000d, <$2802
.il_jobtrkhi:
        !byte >$0008, >$000d, >$000d, >$2802

!if TWOBIT_PROTOCOL=0 {
;///////////////////////////////////////////////////////////////////////////////
.il_zp:
        !byte   $06, $0b, $0b, $06

;///////////////////////////////////////////////////////////////////////////////
}
.il_ledenabled:
        !byte   $a9, $a9, $a9, $60
.il_ledbit:
        !byte   $08, $40, $40, $00
.il_ledadrhi:
        !byte   $1c, $40, $40, $40

}
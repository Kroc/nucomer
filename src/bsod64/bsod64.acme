; BSOD64 (C) Kroc Camen, 2019
; licenced under BSD 2-clause

;===============================================================================
; BSOD64 is a "blue screen of death" for C64 programs. why would you want that?
;
; ...
;
; DESIGN GOALS:
;-------------------------------------------------------------------------------
; * completely self-contained:
; - one source file
; - no external dependencies
; - does not need to be compiled into your own program
; - no need for compatibility with any particular assembler
; - can be loaded from disk using BASIC
; - resides in "unused" memory ($C000..$D000)
;
; * small:
; - maximum limit of 4 KB code
; - favours small code over speed / memory usage
; - uses KERNAL functions where possible

!to     "bsod64.prg"
!zone   bsod64 {

;===============================================================================
; colours:
;                         hex   Â¦ nybble
BLACK                   = $00   ; %0000
WHITE                   = $01   ; %0001
RED                     = $02   ; %0010
CYAN                    = $03   ; %0011
PURPLE                  = $04   ; %0100
GREEN                   = $05   ; %0101
BLUE                    = $06   ; %0110
YELLOW                  = $07   ; %0111
ORANGE                  = $08   ; %1000
BROWN                   = $09   ; %1001
LTRED                   = $0a   ; %1010
DKGREY                  = $0b   ; %1011
GREY                    = $0c   ; %1100
LTGREEN                 = $0d   ; %1101
LTBLUE                  = $0e   ; %1110
LTGREY                  = $0f   ; %1111

PET_STOP                = $03

PET_BLACK               = $90
PET_WHITE               = $05
PET_RED                 = $1c
PET_CYAN                = $9f
PET_PURPLE              = $9c
PET_GREEN               = $1e
PET_BLUE                = $1f
PET_YELLOW              = $9e
PET_ORANGE              = $81
PET_BROWN               = $95
PET_LTRED               = $96
PET_DKGREY              = $97
PET_GREY                = $98
PET_LTGREEN             = $99
PET_LTBLUE              = $9a
PET_LTGREY              = $9b

PET_CLR                 = $93
PET_LCASE               = $0e

PET_RVSON               = $12
PET_RVSOFF              = $92

PET_F1                  = $85
PET_F2                  = $86
PET_F3                  = $87
PET_F4                  = $88
PET_F5                  = $89
PET_F6                  = $8a
PET_F7                  = $8b
PET_F8                  = $8c

; KERNAL/BASIC:
;===============================================================================
!addr   vectors         = $0314

VECTOR_IRQ              = $00   ;=$0314/5
VECTOR_BRK              = $02   ;=$0316/7
VECTOR_NMI              = $04   ;=$0318/9
VECTOR_OPEN             = $06   ;=$031a/b
VECTOR_CLOSE            = $08   ;=$031c/d
VECTOR_CHKIN            = $0a   ;=$031e/f
VECTOR_CHKOUT           = $0c   ;=$0320/1
VECTOR_CLRCHN           = $0e   ;=$0322/3
VECTOR_CHRIN            = $10   ;=$0324/5
VECTOR_CHROUT           = $12   ;=$0326/7
VECTOR_STOP             = $14   ;=$0328/9
VECTOR_GETIN            = $16   ;=$032a/b
VECTOR_CLALL            = $18   ;=$032c/d
VECTOR_LOAD             = $1c   ;=$0330/1
VECTOR_SAVE             = $1e   ;=$0332/3

; initialize VIC; restore default input/output to keyboard/screen;
; clear screen; set PAL/NTSC switch and interrupt timer
;
!addr   kernal_scinit   = $ff81

; initialize CIA's, SID volume; setup memory configuration;
; set and start interrupt timer
;
!addr   kernal_ioinit   = $ff84

; clear memory addresses $0002-$0101 and $0200-$03FF; run memory test
; and set start and end address of BASIC work area accordingly;
; set screen memory to $0400 and datasette buffer to $033C
;
!addr   kernal_ramtas   = $ff87

; fill vector table at memory addresses $0314-$0333 with default values
;
!addr   kernal_restor   = $ff8a

; copy vector table at memory addresses $0314-$0333 from or into user table.
; input:
;       carry : 0 = copy user table into vector table
;               1 = copy vector table into user table
;         X/Y : pointer to user table
;
!addr   kernal_vector   = $ff8d

; set system error display switch at memory address $009D
; input:
;       A : switch value
;
!addr   kernal_setmsg   = $ff90

; send `LISTEN` secondary address to serial bus.
; (must call `LISTEN` beforehand)
; input:
;       A : secondary address.
;
!addr   kernal_lstnsa   = $ff93

; send `TALK` secondary address to serial bus.
; (must call `TALK` beforehand)
; input:
;       A : secondary address
;
!addr   kernal_talksa   = $ff96

; save or restore start address of BASIC work area
; input:
;       carry : 0 = restore from input
;               1 = save to output
;         X/Y : address (if carry = 0)
; output:
;         X/Y : address (if carry = 1)
;
!addr   kernal_membot   = $ff99

; save or restore end address of BASIC work area
; input:
;       carry : 0 = restore from input
;               1 = Save to output
;         X/Y : address (if carry = 0)
; output:
;         X/Y : address (if carry = 1)
;
!addr   kernal_memtop   = $ff9c

; query keyboard; put current matrix code into memory address $00CB,
; current status of shift keys into memory address $028D and PETSCII
; code into keyboard buffer
!addr   kernal_scnkey   = $ff9f

; unknown. (set serial bus timeout)
; input:
;       A : timeout value
;
!addr   kernal_settmo   = $ffa2

; read byte from serial bus.
; (must call `TALK` and `TALKSA` beforehand)
; output:
;       A : byte read
;
!addr   kernal_iecin    = $ffa5

; write byte to serial bus.
; (must call `LISTEN` and `LSTNSA` beforehand)
; input:
;       A : byte to write
;
!addr   kernal_iecout   = $ffa8

; send `UNTALK` command to serial bus
!addr   kernal_untalk   = $ffab

; send `UNLISTEN` command to serial bus
!addr   kernal_unlstn   = $ffae

; send `LISTEN` command to serial bus
; input:
;       A : device number
;
!addr   kernal_listen   = $ffb1

; send `TALK` command to serial bus
; input:
;       A : device number
;
!addr   kernal_talk     = $ffb4

; fetch status of current input/output device, value of `ST` variable
; (for RS232, status is cleared)
; output:
;       A : device status
;
!addr   kernal_readst   = $ffb7

; set file parameters
; input:
;       A : logical number
;       X : device number
;       Y : secondary address
;
!addr   kernal_setlfs   = $ffba

; set file name parameters
; input:
;         A : file name length
;       X/Y : pointer to file name
;
!addr   kernal_setnam   = $ffbd

; open file (must call `SETLFS` and `SETNAM` beforehand)
!addr   kernal_open     = $ffc0

; close file
; input:
;       A : logical number
;
!addr   kernal_close    = $ffc3

; define file as default input
; (must call `OPEN` beforehand)
; input:
;       X : logical number
;
!addr   kernal_chkin    = $ffc6

; define file as default output
; (must call `OPEN` beforehand)
; input:
;       X : logical number
;
!addr   kernal_chkout   = $ffc9

; close default input/output files (for serial bus, send `UNTALK` and/or
; `UNLISTEN`); restore default input/output to keyboard/screen
!addr   kernal_clrchn   = $ffcc

; read byte from default input (for keyboard, read a line from the screen).
; (if not keyboard, must call `OPEN` and `CHKIN` beforehand)
; output:
;       A : byte read
;
!addr   kernal_chrin    = $ffcf

; write byte to default output
; (if not screen, must call `OPEN` and `CHKOUT` beforehand)
; input:
;       A : byte to write
;
!addr   kernal_chrout   = $ffd2

; load or verify file. (must call `SETLFS` and `SETNAM` beforehand)
; input:
;           A : 0 = load, 1-255 = verify;
;         X/Y : load address (if secondary address = 0)
; output:
;       carry : 0 = no errors, 1 = error
;           A : KERNAL error code (if carry = 1)
;         X/Y : address of last byte loaded/verified (if carry = 0)
;
!addr   kernal_load     = $ffd5

; save file. (must call `SETLFS` and `SETNAM` beforehand)
; input:
;           A : address of zero page register holding
;               start address of memory area to save
;         X/Y : End address of memory area plus 1.
; output:
;       carry : 0 = No errors, 1 = Error
;           A : KERNAL error code (if carry = 1)
;
!addr   kernal_save     = $ffd8

; set Time of Day, at memory address $00A0-$00A2
; input:
;       A/X/Y : new TOD value
;
!addr   kernal_settim   = $ffdb

; read Time of Day, at memory address $00A0-$00A2
; output:
;       A/X/Y : current TOD value
;
!addr   kernal_rdtim    = $ffde

; query Stop key indicator, at memory address $0091;
; if pressed, call CLRCHN and clear keyboard buffer
; output:
;        zero : 0 = not pressed, 1 = pressed
;       carry : 1 = pressed
;
!addr   kernal_stop     = $ffe1

; read byte from default input
; (if not keyboard, must call `OPEN` and `CHKIN` beforehand)
; output:
;       A : byte read
;
!addr   kernal_getin    = $ffe4

; clear file table; call `CLRCHN`
!addr   kernal_clall    = $ffe7

; update Time of Day, at memory address $00A0-$00A2,
; and stop-key indicator, at memory address $0091
!addr   kernal_udtim    = $ffea

; fetch number of screen rows and columns
; output:
;       X : number of columns (40)
;       Y : number of rows (25)
;
!addr   kernal_screen   = $ffed

; save or restore cursor position
; input:
;       carry : 0 = restore from input, 1 = save to output
;           X : cursor column (if carry = 0)
;           Y : cursor row (if carry = 0)
; output:
;           X : cursor column (if carry = 1)
;           Y : cursor row (if carry = 1)
;
!addr   kernal_plot     = $fff0

; fetch CIA1 base address
; output:
;       X/Y : CIA1 base address ($DC00)
;
!addr   kernal_iobase   = $fff3

; address space:
;===============================================================================
!addr   zp              = $00
!addr   stack           = $0100
!addr   work            = $0200
!addr   vector          = $0300
!addr   screen          = $0400
!addr   vic             = $d000
!addr   sid             = $d400
!addr   vic_color       = $d800
!addr   cia1            = $dc00
!addr   cia2            = $dd00

; the VIC-II registers:
;-------------------------------------------------------------------------------
VIC_SPRITE0_X           = $00   ;=$D000
VIC_SPRITE0_Y           = $01   ;=$D001
VIC_SPRITE1_X           = $02   ;=$D002
VIC_SPRITE1_Y           = $03   ;=$D003
VIC_SPRITE2_X           = $04   ;=$D004
VIC_SPRITE2_Y           = $05   ;=$D005
VIC_SPRITE3_X           = $06   ;=$D006
VIC_SPRITE3_Y           = $07   ;=$D007
VIC_SPRITE4_X           = $08   ;=$D008
VIC_SPRITE4_Y           = $09   ;=$D009
VIC_SPRITE5_X           = $0a   ;=$D00A
VIC_SPRITE5_Y           = $0b   ;=$D00B
VIC_SPRITE6_X           = $0c   ;=$D00C
VIC_SPRITE6_Y           = $0d   ;=$D00D
VIC_SPRITE7_X           = $0e   ;=$D00E
VIC_SPRITE7_Y           = $0f   ;=$D00F
VIC_SPRITES_X           = $10   ;=$D010
VIC_SCREEN_VERT         = $11   ;=$D011
VIC_SCANLINE            = $12   ;=$D012
VIC_LIGHTPEN_X          = $13   ;=$D013
VIC_LIGHTPEN_Y          = $14   ;=$D014
VIC_SPRITE_ENABLE       = $15   ;=$D015
VIC_SCREEN_HORZ         = $16   ;=$D016
VIC_SPRITE_XPAND_VERT   = $17   ;=$D017
VIC_LAYOUT              = $18   ;=$D018
VIC_IRQ_STATUS          = $19   ;=$D019
VIC_IRQ_CONTROL         = $1a   ;=$D01A
VIC_SPRITE_PRIORITY     = $1b   ;=$D01B
VIC_SPRITE_MULTICOLOR   = $1c   ;=$D01C
VIC_SPRITE_XPAND_HORZ   = $1d   ;=$D01D
VIC_SPRITE_HIT_SPRITE   = $1e   ;=$D01E
VIC_SPRITE_HIT_BKGRND   = $1f   ;=$D01F
VIC_SCREEN_BORDER       = $20   ;=$D020
VIC_SCREEN_BKGRND       = $21   ;=$D021
VIC_SCREEN_BKGRND1      = $22   ;=$D022
VIC_SCREEN_BKGRND2      = $23   ;=$D023
VIC_SCREEN_BKGRND3      = $24   ;=$D024
VIC_SPRITES_COLOR1      = $25   ;=$D025
VIC_SPRITES_COLOR2      = $26   ;=$D026
VIC_SPRITE0_COLOR       = $27   ;=$D027
VIC_SPRITE1_COLOR       = $28   ;=$D028
VIC_SPRITE2_COLOR       = $29   ;=$D029
VIC_SPRITE3_COLOR       = $2a   ;=$D02A
VIC_SPRITE4_COLOR       = $2b   ;=$D02B
VIC_SPRITE5_COLOR       = $2c   ;=$D02C
VIC_SPRITE6_COLOR       = $2d   ;=$D02D
VIC_SPRITE7_COLOR       = $2e   ;=$D02E

; CIA1+2 registers:
;-------------------------------------------------------------------------------
CIA_PORTA               = $00   ;=$DC00/$DD00
CIA_PORTB               = $01   ;=$DC01/$DD01
CIA_PORTA_DDR           = $02   ;=$DC02/$DD02
CIA_PORTB_DDR           = $03   ;=$DC03/$DD03
CIA_TIMERA_LO           = $04   ;=$DC04/$DD04
CIA_TIMERA_HI           = $05   ;=$DC05/$DD05
CIA_TIMERB_LO           = $06   ;=$DC06/$DD06
CIA_TIMERB_HI           = $07   ;=$DC07/$DD07
CIA_TOD_TENTHS          = $08   ;=$DC08/$DD08
CIA_TOD_SECS            = $09   ;=$DC09/$DD09
CIA_TOD_MINS            = $0a   ;=$DC0A/$DD0A
CIA_TOD_HOURS           = $0b   ;=$DC0B/$DD0B
CIA_SHIFT               = $0c   ;=$DC0C/$DD0C
CIA_IRQ                 = $0d   ;=$DC0D/$DD0D
CIA_TIMERA              = $0e   ;=$DC0E/$DD0E
CIA_TIMERB              = $0f   ;=$DC0F/$DD0F

;===============================================================================
!addr   orig_zp         = $f000 ; backup of zero-page ($0000-$00FF)
!addr   orig_stack      = $f100 ; backup of stack ($0100-$1FF)
!addr   orig_work       = $f200 ; backup of KERNAL work-RAM ($0200-$02FF)
!addr   orig_vectors    = $f300 ; backup of KERNAL/BASIC vectors ($0300-$03FF)
!addr   orig_screen     = $f400 ; backup of text screen ($0400-$04FF)
!addr   orig_color      = $f500 ; backup of colour RAM
!addr   orig_vic        = $f600 ; backup of VIC-II registers (46-bytes)

;;; working copy of the frozen processor status flags
;;!addr   zp_f            = $fe
;;; working copy of the frozen registers
;;!addr   zp_y            = $fd
;;!addr   zp_x            = $fc
;;!addr   zp_a            = $fb

;;; temporary stack pointer of the frozen stack i.e. a focus cursor, and not the
;;; origanl stack pointer at time of freeze nor the current system stack pointer
;;!addr   zp_sp           = $02
;;; address of the frozen stack, for indexing
;;!addr   zp_stack        = $03
;;!addr   zp_stack_lo     = $03
;;!addr   zp_stack_hi     = $04

; address displayed at the top of the memory viewer
!addr   zp_addr         = $05
!addr   zp_addr_lo      = $05
!addr   zp_addr_hi      = $06

;-------------------------------------------------------------------------------
; address for string indexing
; ("pointer to memory allocated for current string variable")
!addr   zp_str          = $35
!addr   zp_str_lo       = $35
!addr   zp_str_hi       = $36

;===============================================================================
; 888888b.    .d8888b.   .d88888b.  8888888b.   .d8888b.      d8888
; 888  "88b  d88P  Y88b d88P" "Y88b 888  "Y88b d88P  Y88b    d8P888
; 888  .88P  Y88b.      888     888 888    888 888          d8P 888
; 8888888K.   "Y888b.   888     888 888    888 888d888b.   d8P  888
; 888  "Y88b     "Y88b. 888     888 888    888 888P "Y88b d88   888
; 888    888       "888 888     888 888    888 888    888 8888888888
; 888   d88P Y88b  d88P Y88b. .d88P 888  .d88P Y88b  d88P       888
; 8888888P"   "Y8888P"   "Y88888P"  8888888P"   "Y8888P"        888
;===============================================================================
* = $c000
;===============================================================================
; install BSOD64's launch hooks:
;
; this will alter the system interrupts to launch BSOD64 whenever the RESTORE
; key is pressed, or the BRK instruction is encountered in running code
; 
; if you are using your own interrupt code then you will need to include a
; small piece of code at the beginning of your IRQ / NMI routine to invoke
; BSOD64 -- see the comments for the `bsod_irq` routine below
;
bsod_basic:                     ; SYS 49152 / jsr $c000
        jmp bsod_init

;===============================================================================
; invoke BSOD64 manually with a JSR:
;
; DO NOT USE FROM WITHIN AN INTERRUPT HANDLER, otherwise BSOD64 will wrongly
; see the JSR as the interrupt address -- use the next routine (`bsod_irq`)
; for invoking BSDO64 from within your interrupt handler
;
; THIS ASSUMES THE FOLLOWING STACK LAYOUT:
;
;       top  -> PC lo-byte              (pushed by JSR)
;               PC hi-byte              (pushed by JSR)
;
bsod_jsr:                       ; SYS 49155 / jsr $c003
        jmp bsod_push

;===============================================================================
; invoke BSOD64 from an interrupt environment (IRQ/NMI/BRK)
;
; THIS ASSUMES THE FOLLOWING STACK LAYOUT:
;
;       top  -> Y register              (pushed by your IRQ/NMI routine)
;               X register              (pushed by your IRQ/NMI routine)
;               A register              (pushed by your IRQ/NMI routine)
;               processor status        (pushed by hardware interrupt)
;               PC lo-byte              (pushed by hardware interrupt)
;               PC hi-byte              (pushed by hardware interrupt)
;
bsod:                           ; jmp $c006

        ; disable interrupts first!
        ; we must stop any more host code from running!
        sei
        ; we do not know if decimal mode was in use,
        ; turn it off before we use adc/sbc
        cld
        ; get the stack pointer
        tsx
        stx orig_sp             ; keep an unmodified copy
        stx bsod_sp             ; make a working copy
        ; backup the registers that were pushed on to the stack by the
        ; IRQ/NMI routine (or BSOD64 iteself in the case of `bsod_jsr`)
        lda stack+1, x          ; top of stack
        sta orig_y              ; keep an unmodified copy of Y
        sta bsod_y              ; make a working (modifiable) copy
        lda stack+2, x          ; 2nd item on stack
        sta orig_x              ; keep an unmodified copy of X
        sta bsod_x              ; make a working (modifiable) copy
        lda stack+3, x          ; 3rd item on stack
        stx orig_a              ; keep an unmodified copy of A
        sta bsod_a              ; make a working (modifiable) copy
        ; below the registers should be the
        ; processor status at the time of interrupt
        lda stack+4, x
        sta orig_f              ; keep an unmodified copy
        sta bsod_f              ; make a working (modifiable) copy

        ; and lastly the program-counter
        ; WARNING! the BRK instruction always adds 2 to the pushed PC
        lda stack+5, x          ; program counter lo-byte
        sta orig_pc_lo          ; keep an unmodified copy
        sta bsod_pc_lo          ; make a working (modifiable) copy
        lda stack+6, x          ; program counter hi-byte
        sta orig_pc_hi          ; keep an unmodified copy
        sta bsod_pc_hi          ; make a working (modifiable) copy

        ; freeze low-memory:
        ;-----------------------------------------------------------------------
        ; backup the original zero-page. this includes the processor port
        ; ($00/$01) that defines the memory layout that we must reinstate
        ; when we defrost
        ldx # 0
-       lda zp, x
        sta orig_zp, x
        dex
        bne -

        ; with the CPU port registers $00 & $01 backed up, we can now change
        ; memory layout to ensure I/O is accessible to backup VIC, SID etc.
        lda # %00000001         ; ignore Datasette control
        sta zp+0                ; only modify memory layout
        sta zp+1                ; switch I/O on, KERNAL & BASIC off

        ; backup the original stack. since BSOD64 will be using the stack
        ; too, we will want to take a copy of the stack at freeze-time
-       lda stack, x
        sta orig_stack, x
        ; backup the KERNAL/BASIC work RAM at $0200-$02FF
        lda work, x
        sta orig_work, x
        ; backup the KERNAL/BASIC vectors at $0300-$03FF
        lda vector, x
        sta orig_vectors, x
        ; backup the original text screen at $0400-$04FF
        lda screen, X
        sta orig_screen, x
        ; rinse and repeat
        dex
        bne -

        ; freeze VIC-II:
        ;-----------------------------------------------------------------------
        ; backup the VIC-II state before we start changing the screen
        ;
        ldx # $2e               ; number of VIC-II registers
-       lda vic, x
        sta orig_vic, x
        dex
        bpl -

        ; backup colour RAM. this is done in four
        ; stripes to avoid using a nested loop
        ldx # 0
-       lda vic_color  + $000, x
        sta orig_color + $000, x
        lda vic_color  + $100, x
        sta orig_color + $100, x
        lda vic_color  + $200, x
        sta orig_color + $200, x
        lda vic_color  + $300, x
        sta orig_color + $300, x
        dex
        bne -

        ; reset machine state:
        ;-----------------------------------------------------------------------
        ; enable KERNAL & BASIC
        inc zp+1
        inc zp+1

        ; this KERNAL routine erases pages 0, 1, & 2, runs a memory test,
        ; and configures BASIC limits. it sets the page number for screen
        ; memory to $04 just before it exits
        ;;jsr kernal_ramtas

        ; restore the default vector table
        jsr kernal_restor

        ; re-initialise VIC-II
        jsr kernal_scinit

        ; a BSOD must be blue...
        lda # BLUE
        sta vic+VIC_SCREEN_BORDER
        sta vic+VIC_SCREEN_BKGRND
        ; we can now hide the screen whilst we continue to work
        lda # %00001011         ; 25 rows, screen off
        sta vic+VIC_SCREEN_VERT

        ; re-initialise CIAs, get interrupts running again
        jsr kernal_ioinit

        lda # %00011011         ; 25 rows, screen on
        sta vic+VIC_SCREEN_VERT

        ; configure working environment
        ;-----------------------------------------------------------------------
        ; the memory viewer will be initially focused
        ; on the program counter address
        lda bsod_pc_lo
        and # %11111000         ; align to every 8 bytes
        sta zp_addr_lo
        lda bsod_pc_hi
        sta zp_addr_hi

;===============================================================================
; redraw the entire BSOD64 screen
;
bsod_redraw:
        jsr bsod_print_str_inline
        !pet    PET_CLR, PET_LCASE
        !pet    PET_CYAN, "BSOD64v0.0-190711"
        !byte   0

        ; draw the lines across the screen
        ldx # 39
        ldy # $63
-       lda # $64
        sta screen+( 6 * 40), x
        tya
        sta screen+(23 * 40), x
        ; add colour
        lda # CYAN
        sta vic_color+( 6 * 40), x
        sta vic_color+(23 * 40), x
        dex
        bpl -

        ; write the menu on the bottom of the screen
        jsr bsod_print_key_inline_pos
        !byte   24, 0
        !pet    PET_F1, "MEMORY ", 1
        !pet    PET_F3, "VIC ", 1
        !pet    PET_F5, "SID ", 1
        !pet    PET_F7, "DISK", 0
        
        ; redraw the various windows
        jsr bsod_redraw_registers
        jsr bsod_redraw_flags
        jsr bsod_redraw_banks
        jsr bsod_redraw_stack
        jsr bsod_redraw_memory

        jmp *

;===============================================================================
; set the cursor positon:
; (save a byte every time we have to do this)
;
bsod_set_cursor:
        clc                     ; = set cursor
        jmp kernal_plot         ; call KERNAL to position cursor

;===============================================================================
; redraw the register window
;
bsod_redraw_registers:
        ; title
        jsr bsod_print_key_inline_pos
        !pet    0, 18, "R", "REGISTERS", 0

        ; register legend
        jsr bsod_print_str_inline_pos
        !byte   2, 18
        !pet    PET_GREEN, "PC:  A: X: Y:"
        !pet    PET_LTBLUE      ; set colour for hex digits
        !byte   0

        ; program counter value
        ldy # 18
        ldx # 3
        lda bsod_pc_hi
        jsr bsod_print_hex8_pos
        lda bsod_pc_lo
        jsr bsod_print_hex8

        ; registers
        ldy # 23
        lda bsod_a
        jsr bsod_print_hex8_pos
        lda # ' '
        tax
        jsr kernal_chrout
        lda bsod_x
        jsr bsod_print_hex8
        txa
        jsr kernal_chrout
        lda bsod_y
        jsr bsod_print_hex8

        rts

;===============================================================================
; redraw the flags window:
;
bsod_redraw_flags:

        ; title
        jsr bsod_print_key_inline_pos
        !pet    0, 32, "F", "FLAGS", 0

        ; flags legend "nv-bdiz"
        jsr bsod_print_str_inline_pos
        !byte   2, 32
        !pet    PET_GREEN, "nv-bdizc"
        !pet    PET_LTBLUE      ; set colour for flag bits
        !byte   0

        ; print the processor flags
        ldy # 32
        ldx # 3
        lda bsod_f
        sec
        jsr bsod_print_bin8

        rts

;===============================================================================
; redraw the banks (I/O, ROMs) window:
;
bsod_redraw_banks:

        ; banks title / legend
        jsr bsod_print_key_inline_pos
        !pet    2, 0, "B", "BANKS  ", 0
        jsr bsod_print_str_inline
        !pet    PET_GREEN, "89ABCDEF"
        !pet    PET_LTBLUE      ; set colour for memory map
        !pet    PET_RVSON       ; turn reverse on for the memory map
        !byte   0

        ; draw the memory layout:
        ;-----------------------------------------------------------------------
        ; position cursor
        ldy # 9
        ldx # 3
        jsr bsod_set_cursor

        ; default blank (no banked in ROM) character
        lda # ' '
        sta @b+1
        sta @i+1
        sta @k+1
        tax

        ; TODO: detect cart ROM
        jsr kernal_chrout
        jsr kernal_chrout
        
        lda orig_zp+1
        and # %00000011
        beq .print              ; %00 = all RAM, nothing else

        ldy # 'I'               ; I/O is on
        sty @i+1

        clc
        sbc # 1
        beq .print

        ldy # 'K'
        sty @k+1

        sbc # 1
        beq .print

        ldy # 'B'
        sty @b+1

.print:
@b      lda # $21
        jsr kernal_chrout
        jsr kernal_chrout
        txa
        jsr kernal_chrout       ; $C000 is always RAM
@i      lda # $21
        jsr kernal_chrout
@k      lda # $21
        jsr kernal_chrout
        jsr kernal_chrout

        lda # PET_RVSOFF
        jsr kernal_chrout
        rts

;===============================================================================
; redraw the stack window:
;
bsod_redraw_stack:

        ; title
        jsr bsod_print_key_inline_pos
        !pet    5, 32, "S", "STACK", 0

        ; set cursor to first line
        lda # 7
        sta @line
        ; get the frozen stack pointer
        ldy bsod_sp

-       jsr bsod_print_str_inline_pos
@line   !pet    7, 32, PET_PURPLE, 0
        ; is this line the top of the stack at freeze-time?
        cpy bsod_sp
        bne +
        lda # "@"
        !byte   $2c

+       lda # " "
        jsr kernal_chrout
        jsr bsod_print_str_inline
        !pet    PET_GREEN, "1", 0
        tya
        jsr bsod_print_hex8

        lda # PET_LTBLUE
        jsr kernal_chrout
        lda # " "
        jsr kernal_chrout

        sei
        dec zp+1
        dec zp+1
        lda orig_stack+1, y
        inc zp+1
        inc zp+1
        cli
        jsr bsod_print_hex8
        iny
        beq +

        ldx @line
        inx
        stx @line
        cpx # 23
        bcc -

+       ; TODO: handle hitting the bottom of the stack ($1FF);
        ;       unused lines will have to be cleared if the stack is shallow
        rts

;===============================================================================
; redraw the memory window:
;
bsod_redraw_memory:

        ; title
        jsr bsod_print_key_inline_pos
        !byte   5, 0
        !pet    "M", "MEMORY ", 1
        !pet    "G", "GOTO", 0

        ; set cursor to first line
        ldy # 0
        ldx # 7
        jsr bsod_set_cursor

        ; begin printing the hex dump
        ldy # 16                ; number of lines to print

-       jsr bsod_print_hexline
        clc
        lda # 8
        adc zp_addr_lo
        sta zp_addr_lo
        bcc +
        inc zp_addr_hi
+       dey
        bne -

        rts

;===============================================================================
; print a row of memory values:
;
bsod_print_hexline:

        sty @y+1                ; preserve Y-register
        lda # 0                 ; byte offset
        pha

        ; print the gutter
        jsr bsod_print_str_inline
        !pet    PET_GREEN, "  $"
        !byte   0

        ; print the memory address
        lda zp_addr_hi
        jsr bsod_print_hex8
        lda zp_addr_lo
        jsr bsod_print_hex8
        lda # PET_LTBLUE
        jsr kernal_chrout

        pla
        tay
        ldx # 8

-       lda # ' '
        jsr kernal_chrout
        lda (zp_addr), y
        jsr bsod_print_hex8
        iny
        dex
        bne -

        lda # $0d
        jsr kernal_chrout

@y      ldy # $88
        rts

;===============================================================================
; print a byte as PETSCII hexadecimal:
;
;       A = byte value
;       X = screen row
;       Y = screen col
;
bsod_print_hex8_pos:
        ;-----------------------------------------------------------------------
        pha                     ; put aside original value

        jsr bsod_set_cursor     ; position the cursor
        
        pla                     ; retrieve original value

bsod_print_hex8:
        ;-----------------------------------------------------------------------
        stx @x+1                ; preserve X-register
        sty @y+1                ; preserve Y-register

        sed                     ; enable decimal mode
        pha                     ; put original value aside

        lsr                     ; shift upper nybble down
        lsr                     ; ...
        lsr                     ; ...
        lsr                     ; ...
        cmp #9+1
        adc # $30               ; rebase to PETSCII '0' and above
        jsr kernal_chrout
        iny

        pla                     ; retrieve original value
        and # $0f               ; extract lower nybble
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above
        jsr kernal_chrout
        iny

        cld                     ; disable decimal mode
@x      ldx # $88
@y      ldy # $88
        rts

;===============================================================================
; print a byte as PETSCII binary:
;
;       A = value
;      c- = use 0/1 digits
;      c+ = use -/* digits
;       X = screen row
;       Y = screen col
;
bsod_print_bin8:

        php                     ; put aside input carry state
        pha                     ; put aside original value

        jsr bsod_set_cursor     ; position the cursor

        ldy # 8                 ; print 8-bits
        pla                     ; retrieve original value

        ; check the carry state. if carry is set binary
        ; digits will be printed as "-" = 0 and "*" = 1
        plp                     ; retrieve input carry state
        bcs @sym                ; carry set = use symbols

        ; print "0" & "1" digits
        ;-----------------------------------------------------------------------
@dig    asl                     ; pop a bit off the value
        tax                     ; remember remainder for next loop
        lda # $30               ; PETSCII '0'
        adc # 0                 ; PETSCII '1' if bit was 1
        jsr kernal_chrout       ; print digit

        txa                     ; retrieve remaining value before looping
        dey                     ; 1 digit down
        bne @dig                ; any more left?

        rts

        ; print "-" & "*" digits
        ;-----------------------------------------------------------------------
@sym    asl                     ; pop a bit off the value
        tax                     ; remember remainder for next loop

        bcc +                   ; is bit 0 or 1?
        lda # $2a               ; PETSCII '*'
        !byte $2c               ; `bit $....` (skip next 2-byte instruction)
+       lda # $2d               ; PETSCII '-'
        jsr kernal_chrout
        
        txa                     ; retrieve remaining value before looping
        dey                     ; 1 digit down
        bne @sym                ; any more left?

        rts

;===============================================================================
; print a key guide, e.g. "R:REGISTERS":
;
; having a routine for this does away with the need to store
; the same colour-changing bytes for every key string
;
bsod_print_key_inline_pos:
        ;-----------------------------------------------------------------------
        ; clear carry to indicate an embedded
        ; position in the string
        clc
        ; skip the next instruction (`clc`)
        ; when we fall into the routine below
        !byte $24

bsod_print_key_inline:
        ;-----------------------------------------------------------------------
        ; set carry to indicate 'no embedded position'
        sec

        ; preserve registers at the end of the inline string
        ; printing routine, which is where we will exit
        stx bsod_print_str_inline_pos__x
        sty bsod_print_str_inline_pos__y

        ; get the address of the string from the stack.
        ; if carry is clear, the row/col will be read
        ; from the first two bytes of the string
        jsr bsod_stack_string
        
bsod_print_key_inline_print:

        ; print the key
        lda # PET_WHITE
        jsr kernal_chrout
        lda (zp_str), y
        ; handle some special codes that require more than one character:
        cmp # PET_F1            ; is the key F1 or above?
        bcc +
        cmp # PET_F8+1          ; is it F1 through F8?
        bcs +
        tax                     ; keep that Fx keycode...

        ; print the F for Function, first
        lda # "f"
        jsr kernal_chrout
        ; turn an F1-F8 PETSCII code ($85-$8C)
        ; into a PETSCII number ($31-$38)
        txa                     ; retrieve the Fx keycode
        sbc # $53               ; move into "1"-"8" range

        ; print the key letter
+       jsr kernal_chrout
        ; print the colon separating key and function
        lda # PET_LTBLUE
        jsr kernal_chrout
        lda # ":"
        jsr kernal_chrout
        ; print the remainder of the string in yellow
        lda # PET_YELLOW
        jsr kernal_chrout
        iny
        jmp bsod_print_str_inline_pos__print

;===============================================================================
; print a null-terminated PETSCII string, at the current cursor location,
; where the string data immediately follows the call to this routine!
;
; preserves:    X, Y
;
bsod_print_str_inline:

        ; set carry to indicate 'no embedded position'
        sec
        ; skip the next instruction (`clc`)
        ; when we fall into the routine below
        !byte $24
        
;===============================================================================
; print a null-terminated PETSCII string that includes the row+col position
; in the first two bytes, where the string data immediately follows the call
; to this routine!
;
; preserves:    X, Y
;
bsod_print_str_inline_pos:
        
        ; clear carry to indicate that the cursor position
        ; is embdedded in the string
        clc

        ; preserve X & Y
        stx @x+1
        sty @y+1

        ; get the address + row/col of the string from the stack
        jsr bsod_stack_string

@print  lda (zp_str), y
!addr   bsod_print_str_inline_pos__print = @print
        tax
        beq +
        dex
        beq .next_key

        jsr kernal_chrout
        iny
        bne @print

+       tsx
        iny
        tya
        adc stack+1, x
        sta stack+1, x
        bcc @x
        inc stack+2, x
        
@x      ldx # $88
!addr   bsod_print_str_inline_pos__x = @x+1
@y      ldy # $88
!addr   bsod_print_str_inline_pos__y = @y+1
        rts

.next_key:
        iny
        jmp bsod_print_key_inline_print

;===============================================================================
; read an inline string address from the stack:
;
bsod_stack_string:

        php                     ; put aside the carry flag for later

        tsx                     ; current stack pointer
        clc
        lda stack+4, x
        adc # 1
        sta zp_str_lo
        lda stack+5, x
        adc # 0
        sta zp_str_hi

        ldy # 0
        plp                     ; retrieve the original carry flag
        bcs @end

        ; read the row & col bytes
        ;
        lda (zp_str), y         ; read the row
        tax                     ; must be in X for KERNAL call
        iny
        lda (zp_str), y         ; read the col
        tay                     ; must be in Y for KERNAL call

        jsr bsod_set_cursor     ; position the cursor

        ldy # 2                 ; new string index

@end    rts

;===============================================================================
bsod_push:
        ; disable interrupts first!
        ; we must stop any more host code from running!
        sei
        ; we normalise the stack to appear the same as the interrupt call
        ; would. this reduces the complexity of handling the different
        ; methods of invoking BSOD64 
        php
        pha
        txa
        pha
        tya
        pha

        jmp bsod

;===============================================================================
;
bsod_init:
        rts

;===============================================================================
; BSOD64's backup of some C64 state at the point of BRK / NMI.
; this is used to minimize damage to the original stack
;
; unlike the other backup data (zero-page, stack, colour RAM),
; these are kept within the program code due to their sensitivity
; to corruption, and remain unmodified. working copies are made
; whilst BSOD64 is in use
;
orig_a:
        !byte   $88             ; backup of the A register
orig_x:
        !byte   $88             ; backup of the X register
orig_y:
        !byte   $88             ; backup of the Y register
orig_sp:
        !byte   $88             ; backup of the stack pointer
orig_pc:
orig_pc_lo:                     ; backup of the program counter
        !byte   $88
orig_pc_hi:
        !byte   $88
orig_f:
        !byte   $88             ;backup of the processor status (flags)

;-------------------------------------------------------------------------------
bsod_a:
        !byte   $88
bsod_x:
        !byte   $88
bsod_y:
        !byte   $88
bsod_sp:
        !byte   $88
bsod_pc:
bsod_pc_lo:
        !byte   $88
bsod_pc_hi:
        !byte   $88
bsod_f:
        !byte   $88

}
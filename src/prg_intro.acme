; nÃ¼comer diskzine (c) copyright Kroc Camen 2019-2023. unless otherwise noted,
; licenced under Creative Commons Attribution Non-Commercial Share-Alike 4.0
; licence; you may reuse and modify this code how you please as long as you:
;
; - retain the copyright notice
; - use the same licence for your derived code
; - do not use it for commercial purposes
;   (contact the author for a commercial licence)
;
; prg_intro.acme:
;===============================================================================
; after the bootstrap, the "intro" installs some permenant shared code
; shows the logo, and then loads the main menu. this is done this way
; so that the logo screen can be discard and overwritten after it is
; shown and not occupy RAM permenantly for a once-off screen
;
!source "nucomer.acme"          ; nucomer constants for memory layout

* = nu_intro

intro_boot:
;===============================================================================
; display the intro and chain-load the outfit:
;-------------------------------------------------------------------------------
        ; turn the screen off whilst we clear it
        lda # %00000000
        sta .VIC_SCREEN_CTL1

        ; change the VIC bank
        ;
        ldx .CIA2_PORTA_DDR     ; (backup current value)
        lda # %00000111         ; we only want to write to the low 3-bits
        sta .CIA2_PORTA_DDR     ; set the port's read/write state
        ;
        ; the bit value is the inverse of the bank number 0-3
        lda # (!NU_VIC_BANK) & %00000011
        sta .CIA2_PORTA         ; change VIC bank

        ; we must restore the read/write state
        ; of the port or disk I/O will break!
        stx .CIA2_PORTA_DDR

        ; change the VIC memory layout to position the text-screen & char ROM
        lda # ((>nu_intro_screen & %00111100) << 2) | ((>$1800 & %00111000) >> 2)
        sta .VIC_LAYOUT

        ; patch interrupts:
        ;=======================================================================
        sei                     ; disable interrupts whilst we alter them

        ; turn off all interrupts on CIA1. note that bit 7 is used to fill all
        ; other bits that are given as 1! therefore, the value `%011111111` is
        ; instructing the port to set bits 0-6 to 0, therefore turning off all
        ; timers on the port
        ;
        lda # %01111111
        sta .CIA1_INTERRUPT
        ; repeat this also for CIA2 which uses the Non-Maskable-Interrupt
        ; ("NMI") for its timers
        sta .CIA2_INTERRUPT

        ; set the non-maskable interrupt location when the KERNAL is on.
        ; pressing the RESTORE key will fire this routine (unless disabled
        ; -- see comments on `nmi_disable` routine)
        lda #< nmi_kernalon
        sta .KERNAL_VECTOR_NMI+0
        lda #> nmi_kernalon
        sta .KERNAL_VECTOR_NMI+1

        ; likewise, when the KERNAL is off, an NMI handler
        ; must be specified or the machine will crash
        lda #< nmi_nokernal
        sta .HW_VECTOR_NMI+0
        lda #> nmi_nokernal
        sta .HW_VECTOR_NMI+1

        ; disable all forms of VIC-II interrupts
        ; (raster, light-pen, sprite collisions)
        lda # %00000000
        sta .VIC_INTERRUPT_CONTROL

        ; switch to the minimal interrupt
        ; handler for when the KERNAL is off
        lda #< irq_nokernal
        sta .HW_VECTOR_IRQ+LO
        lda #> irq_nokernal
        sta .HW_VECTOR_IRQ+HI

        ; and likewise for when the KERNAL is on
        lda #< irq_kernalon
        sta .KERNAL_VECTOR_IRQ+LO
        lda #> irq_kernalon
        sta .KERNAL_VECTOR_IRQ+HI

        cli                     ; enable interrupts

        ;-----------------------------------------------------------------------
        jsr logo_screen
        
        ; load the main outfit
        ;-----------------------------------------------------------------------
;;        lda #> (nu_main-1)+$c
;;        pha
;;        lda #< (nu_main-1)+$c
;;        pha
        
        ;;lda CPU_CONTROL
        ;;and # %11111100
        ;;sta CPU_CONTROL
        ;;dec .CPU_CONTROL

        lda # %00110111
        sta .CPU_CONTROL

;;        ldx+1 .ZP_KERNAL_DEV    ; last-used KERNAL device number
;;        bne +                   ; not 0? good
;;        ldx # .DEV_DRV8         ; default to drive 8
;;+       ldy # $01               ; use PRG load-address
;;        tya                     ; logical file number
;;        jsr .KERNAL_SETLFS
;;
;;        ldx #< @filename_outfit
;;        ldy #> @filename_outfit
;;        lda # 3                 ; A is string-length
;;        jsr .KERNAL_SETNAM      ; set KERNAL file name
        
        ; we will not be returning here!
        ;
        lda #> (.basic_start-1)+$c
        pha
        lda #< (.basic_start-1)+$c
        pha

        lda # $c2               ; filename "C2*", i.e. the main outfit
        jmp fastload

;;        lda # 0
;;        jmp .KERNAL_LOAD        ; load, not verify

@filename_outfit:
        ;-----------------------------------------------------------------------
        !pet    "c2*"


nmi_nokernal:
;===============================================================================
        ; when the KERNAL is off we must acknowledge the interrupt
        ; by reading from CIA2 otherwise the NMI becomes disabled 
        asl .CIA2_INTERRUPT

nmi_kernalon:
        ;-----------------------------------------------------------------------
        ; when KERNAL is on, it will already have acknowledged the interrupt.
        ; the KERNAL does not push the registers to the stack for NMIs
        rti

irq_nokernal:
;===============================================================================
        ; when the KERNAL is off we must acknowledge the interrupt
        ; by reading from CIA1 otherwise it will instantly fire again 
        asl .CIA1_INTERRUPT
        rti


irq_kernalon:
;===============================================================================
        ; pull the registers from the stack
        ; (in reverse order)
        pla                     ; pull...
        tay                     ; ...Y
        pla                     ; pull...
        tax                     ; ...X
        pla                     ; pull A

        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti


wait_frames:
;===============================================================================
; wait for a given number of frames to pass:
;
; in:   X                       number of frames to wait (1-based)
;-------------------------------------------------------------------------------
-       jsr wait_frame
        dex
        bne -
        
        rts

wait_frame:
        ;-----------------------------------------------------------------------
        ; wait for a full cycle of the raster beam:
        ;
        ; bit 7 of $D011 is the upper-most bit of the current raster line,
        ; i.e. when it is 0 the beam is on lines 0-255 and when it's 1 the
        ; beam is on lines 256+ -- PAL has 312 lines, NTSC has 262 lines
        ; but some very early NTSC machines have 263 lines
        ;
        ; first, we wait for the beam to enter the top of the screen
        ; (lines 0-255), this is so that if the beam is currently within the
        ; bottom of the screen (lines 256+), we wait for it to go back around
        ; and don't trigger early
        ;
-       bit .VIC_SCREEN_VERT
        bmi -                   ; wait until bit 7 is 0

        ; now wait for the addressible screen to pass and the vblank
        ; to begin again, this syncronises the main thread with the vblank
-       bit .VIC_SCREEN_VERT
        bpl -                   ; wait until bit 7 is 1

        rts

;===============================================================================
!source "logo.acme"
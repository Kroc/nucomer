; the screen used when reading articles

; theme colours
READ_BORDER             = GREY
READ_FORE               = DKGREY
READ_BACK               = GREY

!addr {

; vertical scrolling register value to write at each vblank.
; this ensures that the change to the vertical smooth-scroll
; offset only ever occurs offscreen
ZP_READ_VERT            = $20

; number of lines in the complete article
ZP_READ_LINES           = $21
ZP_READ_LINES_LO        = $21
ZP_READ_LINES_HI        = $22

; height of the complete article -- in pixels! this is used to determine the
; exact point to clip smooth scrolling when scrolling quickly. the high-bit
; is used to determine the top of the article, so in practice the article
; is limited to $7FFF (32'767) pixels high, equivalant to 4'095 lines,
; or 170 screens high!
;
ZP_READ_VLEN            = $23
ZP_READ_VLEN_LO         = $23
ZP_READ_VLEN_HI         = $24

; exact scroll position -- in pixels!
ZP_READ_VPOS            = $25
ZP_READ_VPOS_LO         = $25
ZP_READ_VPOS_HI         = $26

; scroll accumulator, used for changing the speed
; of smooth scrolling; a signed byte
ZP_READ_SCROLL          = $27

; flag to indicate to stop allowing upward scrolling
; (prevents smooth scrolling at top of article)
ZP_READ_STOP_UP         = $28   ; $00 = go, $FF = stop
; flag to indicate to stop allowing downward scrolling
; (prevents smooth scrolling at bottom of article)
ZP_READ_STOP_DN         = $29   ; $00 = go, $FF = stop

; pointer into the line-length array
ZP_READ_LENS            = $2a
ZP_READ_LENS_LO         = $2a
ZP_READ_LENS_HI         = $2b
; address of the line data that appears at the top of the screen
; (changes only when scrolling, not during printing)
ZP_READ_TOP             = $2c
ZP_READ_TOP_LO          = $2c
ZP_READ_TOP_HI          = $2d
; current row on screen being printed (0-26)
ZP_READ_ROW             = $2e
; current line length
ZP_READ_LEN             = $2f
; number of rows to print
ZP_READ_ROWS            = $30
; address of the line that appears at the bottom of the screen
; (changes only when scrolling, not during printing)
ZP_READ_BOT             = $31
ZP_READ_BOT_LO          = $31
ZP_READ_BOT_HI          = $32
}

;===============================================================================
; in a case of "if it's stupid but it works, it's not stupid" we handle the
; scrolling in of new lines by simply treating the screen as taller than it
; actually is, filling new lines into the 40 chars before / after screen RAM.
; when the screen is hard-scrolled (all lines in the screen are moved up/down),
; the routine blindly moves the lines above/below the real screen into place
; without any special consideration
;
!addr {
read_screen_addr        = $0400-40
read_screen_addr_before = $0400-40
read_screen_addr_after  = $0400+(25*40)
}

read_screen_rows:
;-------------------------------------------------------------------------------
; this is a lookup table of row-number to screen address, but the screen is
; 27 rows high, starts 40 chars before the real screen RAM and ends 40 chars
; after the real screen RAM. this means that when printing row '0', it will
; be off-screen and likewise with row '26'
;
read_screen_rows_lo:
;-------------------------------------------------------------------------------
        !for    row, 0, 26 {
        !byte   <(read_screen_addr + (row * 40))
        }
read_screen_rows_hi:
;-------------------------------------------------------------------------------
        !for    row, 0, 26 {
        !byte   >(read_screen_addr + (row * 40))
        }

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_screen_row0        = $0400+(-1*40) ; offscreen-row before screen RAM
read_screen_row1        = $0400+( 0*40) ;=$0400
read_screen_row2        = $0400+( 1*40)
read_screen_row3        = $0400+( 2*40)
read_screen_row4        = $0400+( 3*40)
read_screen_row5        = $0400+( 4*40)
read_screen_row6        = $0400+( 5*40)
read_screen_row7        = $0400+( 6*40)
read_screen_row8        = $0400+( 7*40)
read_screen_row9        = $0400+( 8*40)
read_screen_row10       = $0400+( 9*40)
read_screen_row11       = $0400+(10*40)
read_screen_row12       = $0400+(11*40)
read_screen_row13       = $0400+(12*40)
read_screen_row14       = $0400+(13*40)
read_screen_row15       = $0400+(14*40)
read_screen_row16       = $0400+(15*40)
read_screen_row17       = $0400+(16*40)
read_screen_row18       = $0400+(17*40)
read_screen_row19       = $0400+(18*40)
read_screen_row20       = $0400+(19*40)
read_screen_row21       = $0400+(20*40)
read_screen_row22       = $0400+(21*40)
read_screen_row23       = $0400+(22*40)
read_screen_row24       = $0400+(23*40)
read_screen_row25       = $0400+(24*40)
read_screen_row26       = $0400+(25*40) ; offscreen-row after screen RAM
}

read_colour_addr:
;-------------------------------------------------------------------------------
; we can't put data before / after the colour RAM when I/O is on,
; and turning I/O on & off to use the RAM underneath is too slow
; so the 'offscreen' colour rows are stored here
;
read_colour_before:
;-------------------------------------------------------------------------------
        !fill   40, READ_FORE

read_colour_after:
;-------------------------------------------------------------------------------
        !fill   40, READ_FORE

read_colour_rows:
;-------------------------------------------------------------------------------
; and as before with screen RAM, a lookup table of colour-RAM addresses
; for each row, but accounting for our before & after rows (above)
;
read_colour_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <read_colour_before
        !for    row, 0, 24 {
        !byte   <($d800 + (row * 40))
        }
        !byte   <read_colour_after

read_colour_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >read_colour_before
        !for    row, 0, 24 {
        !byte   >($d800 + (row * 40))
        }
        !byte   >read_colour_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_colour_row0        = read_colour_before
read_colour_row1        = $d800+( 0*40) ;=$D800
read_colour_row2        = $d800+( 1*40)
read_colour_row3        = $d800+( 2*40)
read_colour_row4        = $d800+( 3*40)
read_colour_row5        = $d800+( 4*40)
read_colour_row6        = $d800+( 5*40)
read_colour_row7        = $d800+( 6*40)
read_colour_row8        = $d800+( 7*40)
read_colour_row9        = $d800+( 8*40)
read_colour_row10       = $d800+( 9*40)
read_colour_row11       = $d800+(10*40)
read_colour_row12       = $d800+(11*40)
read_colour_row13       = $d800+(12*40)
read_colour_row14       = $d800+(13*40)
read_colour_row15       = $d800+(14*40)
read_colour_row16       = $d800+(15*40)
read_colour_row17       = $d800+(16*40)
read_colour_row18       = $d800+(17*40)
read_colour_row19       = $d800+(18*40)
read_colour_row20       = $d800+(19*40)
read_colour_row21       = $d800+(20*40)
read_colour_row22       = $d800+(21*40)
read_colour_row23       = $d800+(22*40)
read_colour_row24       = $d800+(23*40)
read_colour_row25       = $d800+(24*40)
read_colour_row26       = read_colour_after
}

;===============================================================================
read_screen:
        ;-----------------------------------------------------------------------
        ; setup the screen:
        ; turn the screen off whilst we clear it
        lda # %00000000
        sta VIC_SCREEN_VERT

        ; set screen colour
        lda # READ_BORDER
        sta VIC_BORDER
        lda # READ_BACK
        sta VIC_BACKGROUND

        ; erase the text-screen
        lda # READ_FORE
        sta ZP_PRINT_COLOR
        jsr clear_screen

        ; whilst the lines before and after screen RAM will hold text
        ; waiting to be scrolled into view, we do need to fill these with
        ; spaces to begin with in case the first lines to be placed there
        ; do not fill 40-chars and we get screen garabge scrolling in
        ldx # 40-1
        lda # ' '
-       sta read_screen_addr_before, x
        sta read_screen_addr_after, x
        dex
        bpl -

        ; initialise printing:
        ;-----------------------------------------------------------------------
        ; the first two bytes are the size of the line-length array;
        ; in other words, how many lines in the article there are,
        ; and how far forward to skip to find the text data.
        ; we set the address of the first line to print
        clc
        lda $1ffe
        adc #< $1ffe
        sta READ_CHAR_LO
        sta ZP_READ_TOP_LO
        lda $1fff
        adc #> $1fff
        sta READ_CHAR_HI
        sta ZP_READ_TOP_HI

        ; ergo, the line-length array begins two bytes in
        ; and this is our intial pointer in the array
        ; -- we begin printing at article line 1
        lda #< $2000
        sta ZP_READ_LENS_LO
        lda #> $2000
        sta ZP_READ_LENS_HI

        ; for the smooth scrolling to not overshoot the bottom of the article,
        ; we need to calculate the height of the article in pixels; this is
        ; the number of lines multiplied by 8
        ;
        lda $1ffe
        ; subtract 27 to account for where the top of the screen
        ; is when the bottom of the article is reached
        sec
        sbc # 27
        sta ZP_READ_VLEN_LO
        lda $1fff
        sbc # 0
        sta ZP_READ_VLEN_HI
        ; begin multiplying
        asl ZP_READ_VLEN_LO     ; x2
        rol ZP_READ_VLEN_HI     ; ...
        asl ZP_READ_VLEN_LO     ; x4
        rol ZP_READ_VLEN_HI     ; ...
        asl ZP_READ_VLEN_LO     ; x8
        rol ZP_READ_VLEN_HI     ; ...

        ; print the article's first screen full of text
        ;-----------------------------------------------------------------------
        ldy # 0                 ; begin on row 0 -- the off-screen row
        ldx # 27                ; number of rows to print (1-based)
        jsr read_lines

        ; now that 27 rows have been printed, the routine will have left
        ; the details of the last row behind which we can make use of
        lda READ_CHAR_LO
        sta ZP_READ_BOT_LO
        lda READ_CHAR_HI
        sta ZP_READ_BOT_HI

        ;-----------------------------------------------------------------------
        ; reset the smooth scrolling variables
        ldx # $00
        stx ZP_READ_VERT        ; set starting smooth-scroll position
        stx ZP_READ_SCROLL      ; scroll-speed = 0
        stx ZP_READ_STOP_DN     ; allow scrolling down; $00 = go, $FF = stop
        stx ZP_READ_VPOS_LO     ; set the exact pixel vertical position
        stx ZP_READ_VPOS_HI     ; within the article to zero
        ; we begin at the top of the article,
        ; so disallow scrolling upwards
        dex                     ; X = $FF
        stx ZP_READ_STOP_UP     ; $00 = go, $FF = stop

        ; set our own interrupt handlers:
        lda #< read_irqs        ; A = address of IRQ table, lo-byte
        ldx #> read_irqs        ; X = address of IRQ table, hi-byte
        ldy # 2                 ; Y = number of entries in the table (1-based)
        jsr irqs_load

        ; note that the screen will automatically turn itself back on
        ; because the raster interrupt that handles smooth-scrolling
        ; always sets the screen control register every vblank

read_keyboard:
        ;-----------------------------------------------------------------------
        jsr Keyboard
        bcc @crsr

        ; when no keys are pressed, or the scroll keys
        ; are released, stop the smooth scrolling
        lda # $00
        sta ZP_READ_SCROLL
        ; no key code to process,
        ; go back to waiting
        bpl read_keyboard       ; (always branches)

        ; cursor up/down
        ;-----------------------------------------------------------------------
@crsr   cpx # %10000000
        bne @spc

        ; up, or down?
        tya
        and # %01010000         ; are either of the shift keys pressed?
        bne @up                 ; if yes, it's CRSR-UP

        ; crsr-dn
        ;-----------------------------------------------------------------------
        ; if at the bottom of the article,
        ; do not allow scrolling any further
        ;
@dn     lda ZP_READ_STOP_DN     ; check flag set when scroll hits the bottom
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content down the page:
        ; (smooth scroll upwards)
        ldx # $03               ; set scroll speed
        stx ZP_READ_SCROLL      ; this will be applied at interrupt
        ; whenever scrolling down,
        ; allow scrolling up again
        sta ZP_READ_STOP_UP     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

        ; crsr-up
        ;-----------------------------------------------------------------------
        ; if at the top of the article,
        ; do not allow scrolling any further
@up     lda ZP_READ_STOP_UP     ; check flag set when scroll hits the top
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content up the page
        ; (smooth scroll downwards)
        ldx # $fd               ; set -1 scroll speed
        stx ZP_READ_SCROLL      ; this will be applied at interrupt
        ; whenever scrolling up,
        ; allow scrolling down again
        sta ZP_READ_STOP_DN     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

@spc    cmp # $20
        bne @esc
        jmp read_screen

@esc    cmp # $1f               ; "<-" key
        beq @exit
        
@stop   cpy # %10000000
        bne +
        brk

+       jmp read_keyboard

        ;-----------------------------------------------------------------------
        jmp *

        ; TODO: transition out
@exit   jsr irqs_disable        ; tear down the custom interrupt handlers
        rts                     ; return to the menu

;===============================================================================
; table of interrupts to use for the reading screen:
;
read_irqs:
;-------------------------------------------------------------------------------
; hard scrolling the screen takes a lot of cycles and we must be ahead of the
; beam when we do this to avoid screen-tearing, therefore we begin scrolling
; the top of the screen whilst the beam is in the middle of the screen
;
READ_IRQ1 = SCANLINE_VBLANK_BEGIN - (14 * 8)

; just before the visible screen begins we set the vertical smooth-scrolling
; offset -- we cannot change the vertical scroll inside the screen or we will
; get tearing / glitching!
;
; hard scrolling the screen up or down takes a long time and even if we start
; before vblank, the process will overrun into the screen before it finishes,
; causing screen tear. therefore it is necessary for this interrupt to
; interrupt the previous one(!) whilst it is still shifting the screen,
; to ensure that the smooth scrolling register is not changed within
; the visible portion of the screen when hard-scrolling is occuring
;
READ_IRQ2 = SCANLINE_VBLANK_END - 8

read_irqs_addr_lo:
        !byte   <read_irq_scroll
        !byte   <read_irq_top
read_irqs_addr_hi:
        !byte   >read_irq_scroll
        !byte   >read_irq_top
read_irqs_scanline_lo:
        !byte   <READ_IRQ1
        !byte   <READ_IRQ2
read_irqs_scanline_hi:
        !byte   (>READ_IRQ1) << 7
        !byte   (>READ_IRQ2) << 7

read_irq_top:
        ;-----------------------------------------------------------------------
        ;;inc VIC_BORDER
        
        lda ZP_READ_VERT
        and # %00000111
        eor # %00000111
        ; update the screen/scroll register:
        ;     %---1---- = screen on
        ;     %----0--- = 24 rows (for smooth scrolling)
        ;     %-----??? = vertical scroll offset
        ora # %00010000
        sta VIC_SCREEN_VERT
        
;;        lda ZP_READ_VPOS_HI
;;        pha                     ; put original value aside
;;        sed                     ; enable decimal mode
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+0
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+1
;;        cld
;;
;;        lda ZP_READ_VPOS_LO
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+2
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+3
;;
;;        cld                     ; disable decimal mode
;;        lda ZP_READ_VLEN_HI
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+5
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+6
;;        cld                     ; disable decimal mode
;;        lda ZP_READ_VLEN_LO
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+7
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta $0400+(10*40)+8
;;

-       ;;dec VIC_BORDER
        rts

read_irq_scroll:
        ;-----------------------------------------------------------------------
        ;;inc VIC_BORDER

        ; is there any scrolling to be done?
        ;
        lda ZP_READ_SCROLL      ; read requested scroll speed
        beq -                   ; if scroll-speed = 0, then skip

        ; apply the scroll to our current
        ; vertical position within the article
        clc
        lda ZP_READ_VPOS_LO
        ; remember the article position *before* the move;
        ; we'll need to mask the bottom three bits later
        tay
        ; note that regardless of positive or negative scroll speed,
        ; adding will always produce the same result due to the
        ; wrap-around nature of negative numbers (e.g. -1 = +$FF)
        adc ZP_READ_SCROLL
        sta ZP_READ_VPOS_LO

        ; beyond one byte, we do have to take into
        ; account the postive / negative direction
        lda ZP_READ_VPOS_HI
        ; check the sign-bit of the scroll-speed
        bit ZP_READ_SCROLL
        bmi +
        ; for positive numbers,
        ; the carry can be applied
        adc # 0
       +bit_skip2
+       sbc # 0
        sta ZP_READ_VPOS_HI

        ; hit top/bottom of article?
        ;-----------------------------------------------------------------------
        ; have we gone above the top of the article?
        ; (pixel vertical position < $0000)
        ldx ZP_READ_VPOS_HI
        bpl +
        ; gone above the article; move back to the top
        stx ZP_READ_STOP_UP     ; X = $FF, disable scrolling upwards
        inx                     ; X = $00
        stx ZP_READ_VPOS_LO     ; set scroll position within article
        stx ZP_READ_VPOS_HI     ; to $0000
        stx ZP_READ_VERT        ; reset vertical smooth-scroll register

@done:  ;;dec VIC_BORDER
        rts

        ; check the end of the article:
        ; (X = ZP_READ_VPOS_HI)
+       ldx ZP_READ_VLEN_HI
        cpx ZP_READ_VPOS_HI
        beq +                   ; hi-bytes equal, compare lo-bytes
        bcs @scroll             ; scroll position < height, scroll ahead
        bcc @stop               ; scroll position > height, go back!
        ; check the low-bytes
+       ldx ZP_READ_VLEN_LO
        cpx ZP_READ_VPOS_LO
        bcs @scroll
        
        ; gone below the article!
        ; move back to the end
@stop   ldx # $ff
        stx ZP_READ_STOP_DN
        inx
        sta ZP_READ_SCROLL      ; set scroll speed to zero
        ; change the moved-to position back a bit
        ; to the exact bottom of the article
        ldx ZP_READ_VLEN_LO
        stx ZP_READ_VPOS_LO
        lda ZP_READ_VLEN_HI
        sta ZP_READ_VPOS_HI
        
        ; soft/hard-scroll the screen:
        ;-----------------------------------------------------------------------
        ; soft-scroll:
@scroll lda ZP_READ_VPOS_LO     ; retrieve the article scroll position
        sta ZP_READ_VERT        ; set the smooth-scrolling register at vblank

        ; do we need to hard-scroll?
        tya                     ; article scroll position *before* scroll
        and # %00000111
        sta ZP_READ_ROW         ; (temporary use)

        lda ZP_READ_VPOS_LO     ; article scroll position *after* scroll
        and # %00000111
        bit ZP_READ_SCROLL
        bpl +

        cmp ZP_READ_ROW
        bcc @done

        jmp read_scroll_up

+       cmp ZP_READ_ROW
        bcs @done

;===============================================================================
; scroll the article down a line:
;
read_scroll_down:
        ;-----------------------------------------------------------------------
        ; copy the screen up a row -- due to the number of rows, the loop has
        ; to be split into three otherwise the relative branches cannot reach
        ; the top (>128 bytes) but we do want to get as close to that limit as
        ; possible (about 41 load + stores) as this minimizes the number of
        ; cycles wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
-       ; row 1 -> row 0
        lda read_screen_row1, y ; the top line moves into the off-screen
        sta read_screen_row0, y ; buffer ready for if the user scrolls up
        lda read_colour_row1, y ; (=$D800)
        sta read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        ; row 2 -> row 1
        lda read_screen_row2, y
        sta read_screen_row1, y
        lda read_colour_row2, y
        sta read_colour_row1, y
        ; row 3 -> row 2
        lda read_screen_row3, y
        sta read_screen_row2, y
        lda read_colour_row3, y
        sta read_colour_row2, y
        ; row 4 -> row 3
        lda read_screen_row4, y
        sta read_screen_row3, y
        lda read_colour_row4, y
        sta read_colour_row3, y
        ; row 5 -> row 4
        lda read_screen_row5, y
        sta read_screen_row4, y
        lda read_colour_row5, y
        sta read_colour_row4, y
        ; row 6 -> row 5
        lda read_screen_row6, y
        sta read_screen_row5, y
        lda read_colour_row6, y
        sta read_colour_row5, y
        ; row 7 -> row 6
        lda read_screen_row7, y
        sta read_screen_row6, y
        lda read_colour_row7, y
        sta read_colour_row6, y
        ; row 8 -> row 7
        lda read_screen_row8, y
        sta read_screen_row7, y
        lda read_colour_row8, y
        sta read_colour_row7, y
        ; row 9 -> row 8
        lda read_screen_row9, y
        sta read_screen_row8, y
        lda read_colour_row9, y
        sta read_colour_row8, y
        ; row 10 -> row 9
        lda read_screen_row10, y
        sta read_screen_row9, y
        lda read_colour_row10, y
        sta read_colour_row9, y
        dey
        bpl -

        ldy # 39
        ; row 11 -> row 10
-       lda read_screen_row11, y
        sta read_screen_row10, y
        lda read_colour_row11, y
        sta read_colour_row10, y
        ; row 12 -> row 11
        lda read_screen_row12, y
        sta read_screen_row11, y
        lda read_colour_row12, y
        sta read_colour_row11, y
        ; row 13 -> row 12
        lda read_screen_row13, y
        sta read_screen_row12, y
        lda read_colour_row13, y
        sta read_colour_row12, y
        ; row 14 -> row 13
        lda read_screen_row14, y
        sta read_screen_row13, y
        lda read_colour_row14, y
        sta read_colour_row13, y
        ; row 15 -> row 14
        lda read_screen_row15, y
        sta read_screen_row14, y
        lda read_colour_row15, y
        sta read_colour_row14, y
        ; row 16 -> row 15
        lda read_screen_row16, y
        sta read_screen_row15, y
        lda read_colour_row16, y
        sta read_colour_row15, y
        ; row 17 -> row 16
        lda read_screen_row17, y
        sta read_screen_row16, y
        lda read_colour_row17, y
        sta read_colour_row16, y
        ; row 18 -> row 17
        lda read_screen_row18, y
        sta read_screen_row17, y
        lda read_colour_row18, y
        sta read_colour_row17, y
        ; row 19 -> row 18
        lda read_screen_row19, y
        sta read_screen_row18, y
        lda read_colour_row19, y
        sta read_colour_row18, y
        ; row 20 -> row 19
        lda read_screen_row20, y
        sta read_screen_row19, y
        lda read_colour_row20, y
        sta read_colour_row19, y
        dey
        bpl -

        ldy # 40
        ; row 21 -> row 20
-       lda read_screen_row21-1, y
        sta read_screen_row20-1, y
        lda read_colour_row21-1, y
        sta read_colour_row20-1, y
        ; row 22 -> row 21
        lda read_screen_row22-1, y
        sta read_screen_row21-1, y
        lda read_colour_row22-1, y
        sta read_colour_row21-1, y
        ; row 23 -> row 22
        lda read_screen_row23-1, y
        sta read_screen_row22-1, y
        lda read_colour_row23-1, y
        sta read_colour_row22-1, y
        ; row 24 -> row 23
        lda read_screen_row24-1, y
        sta read_screen_row23-1, y
        lda read_colour_row24-1, y
        sta read_colour_row23-1, y
        ; row 25 -> row 24
        lda read_screen_row25-1, y
        sta read_screen_row24-1, y
        lda read_colour_row25-1, y
        sta read_colour_row24-1, y
        ; row 26 -> row 25
        ; copy the off-screen line into view
        lda read_screen_row26-1, y
        sta read_screen_row25-1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row26-1, y
        sta read_colour_row25-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ;;dec VIC_BORDER

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; blank the off-screen row so that we don't scroll in garbage
        ; if the new line is shorter than the previous line
        ldx # 40
        lda # ' '
-       sta read_screen_addr_after-1, x
        dex
        bne -                   ; stop when X = 0 (important for later!)

        ; read the length of the current line at the top of the screen,
        ; and move the line-pointer for the top screen line to the next line
        ;
        clc                     ; (note that Y = 0)
        lda (ZP_READ_LENS), y   ; length of line above screen
        adc ZP_READ_TOP_LO      ; add line-length to the line address
        sta ZP_READ_TOP_LO      ; (move to next line)
        bcc +
        inc ZP_READ_TOP_HI
        clc

        ; do the same but with the line-pointer for the bottom row of the
        ; screen, but also write the address into the print routine
        ;
+       ldy # 26                ; row to begin printing at (below screen)
        lda (ZP_READ_LENS), y   ; length of line at bottom of screen
        adc ZP_READ_BOT_LO      ; add line-length to the line address
        sta ZP_READ_BOT_LO      ; (move to next line)
        sta READ_CHAR_LO        ; set printing routine line-address (lo)
        lda ZP_READ_BOT_HI
        adc # 0                 ; ripple the add
        sta ZP_READ_BOT_HI
        sta READ_CHAR_HI        ; set printing routine line-address (hi)

        ; move to the next entry in the line-lengths array
        inc ZP_READ_LENS_LO
        bne +
        inc ZP_READ_LENS_HI

+       inx                     ; X = 1; number of lines to print
        jmp read_lines

;===============================================================================
; scroll the article up a line:
;
read_scroll_temp1_char:
        ;-----------------------------------------------------------------------
        !fill   40, ' '

read_scroll_temp2_char:
        ;-----------------------------------------------------------------------
        !fill   40, ' '

read_scroll_temp1_color:
        ;-----------------------------------------------------------------------
        !fill   40, READ_FORE

read_scroll_temp2_color:
        ;-----------------------------------------------------------------------
        !fill   40, READ_FORE

read_scroll_up:
        ;-----------------------------------------------------------------------
        ; copy the screen down a row:
        ;
        ; credit for this particular methodology must go to Richard Bayliss
        ; of The New Dimenson for producing a copy routine fast enough to
        ; copy the screen bottom-up before the scanline catches up
        ; <http://tnd64.unikat.sk/assemble_it6.html>
        ;
        ; due to the number of rows, the loop has to be split into three
        ; otherwise the relative branches cannot reach the top (>128 bytes)
        ; but we do want to get close to that limit as possible (about 41
        ; load + stores) as this minimizes the amount of cycles wasted
        ; each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
-       ; row 9 -> row ...
        lda read_screen_row9, y
        sta read_scroll_temp1_char, y
        lda read_colour_row9, y
        sta read_scroll_temp1_color, y
        ; row 8 -> row 9
        lda read_screen_row8, y
        sta read_screen_row9, y
        lda read_colour_row8, y
        sta read_colour_row9, y
        ; row 7 -> row 8
        lda read_screen_row7, y
        sta read_screen_row8, y
        lda read_colour_row7, y
        sta read_colour_row8, y
        ; row 6 -> row 7
        lda read_screen_row6, y
        sta read_screen_row7, y
        lda read_colour_row6, y
        sta read_colour_row7, y
        ; row 5 -> row 6
        lda read_screen_row5, y
        sta read_screen_row6, y
        lda read_colour_row5, y
        sta read_colour_row6, y
        ; row 4 -> row 5
        lda read_screen_row4, y
        sta read_screen_row5, y
        lda read_colour_row4, y
        sta read_colour_row5, y
        ; row 3 -> row 4
        lda read_screen_row3, y
        sta read_screen_row4, y
        lda read_colour_row3, y
        sta read_colour_row4, y
        ; row 2 -> row 3
        lda read_screen_row2, y
        sta read_screen_row3, y
        lda read_colour_row2, y
        sta read_colour_row3, y
        ; row 1 -> row 2
        lda read_screen_row1, y
        sta read_screen_row2, y
        lda read_colour_row1, y
        sta read_colour_row2, y
        ; row 0 -> row 1
        ; (copy the off-screen line into view)
        lda read_screen_row0, y
        sta read_screen_row1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $D800-40 when I/O is on!
        lda read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        sta read_colour_row1, y ; (=$D800)
        dey
        bpl -

        ldy # 39
-       ; row 18 -> row ...
        lda read_screen_row18, y
        sta read_scroll_temp2_char, y
        lda read_colour_row18, y
        sta read_scroll_temp2_color, y
        ; row 17 -> row 18
        lda read_screen_row17, y
        sta read_screen_row18, y
        lda read_colour_row17, y
        sta read_colour_row18, y
        ; row 16 -> row 17
        lda read_screen_row16, y
        sta read_screen_row17, y
        lda read_colour_row16, y
        sta read_colour_row17, y
        ; row 15 -> row 16
        lda read_screen_row15, y
        sta read_screen_row16, y
        lda read_colour_row15, y
        sta read_colour_row16, y
        ; row 14 -> row 15
        lda read_screen_row14, y
        sta read_screen_row15, y
        lda read_colour_row14, y
        sta read_colour_row15, y
        ; row 13 -> row 14
        lda read_screen_row13, y
        sta read_screen_row14, y
        lda read_colour_row13, y
        sta read_colour_row14, y
        ; row 12 -> row 13
        lda read_screen_row12, y
        sta read_screen_row13, y
        lda read_colour_row12, y
        sta read_colour_row13, y
        ; row 11 -> row 12
        lda read_screen_row11, y
        sta read_screen_row12, y
        lda read_colour_row11, y
        sta read_colour_row12, y
        ; row 10 -> row 11
        lda read_screen_row10, y
        sta read_screen_row11, y
        lda read_colour_row10, y
        sta read_colour_row11, y
        ; row ... -> row 10
        lda read_scroll_temp1_char, y
        sta read_screen_row10, y
        lda read_scroll_temp1_color, y
        sta read_colour_row10, y
        dey
        bpl -

        ldy # 40
-       ; row 25 -> row 26
        ; the bottom line moves into the off-screen
        ; buffer ready for if the user scrolls down
        lda read_screen_row25-1, y
        sta read_screen_row26-1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row25-1, y
        sta read_colour_row26-1, y
        ; row 24 -> row 25
        lda read_screen_row24-1, y
        sta read_screen_row25-1, y
        lda read_colour_row24-1, y
        sta read_colour_row25-1, y
        ; row 23 -> row 24
        lda read_screen_row23-1, y
        sta read_screen_row24-1, y
        lda read_colour_row23-1, y
        sta read_colour_row24-1, y
        ; row 22 -> row 23
        lda read_screen_row22-1, y
        sta read_screen_row23-1, y
        lda read_colour_row22-1, y
        sta read_colour_row23-1, y
        ; row 21 -> row 22
        lda read_screen_row21-1, y
        sta read_screen_row22-1, y
        lda read_colour_row21-1, y
        sta read_colour_row22-1, y
        ; row 20 -> row 21
        lda read_screen_row20-1, y
        sta read_screen_row21-1, y
        lda read_colour_row20-1, y
        sta read_colour_row21-1, y
        ; row 19 -> row 20
        lda read_screen_row19-1, y
        sta read_screen_row20-1, y
        lda read_colour_row19-1, y
        sta read_colour_row20-1, y
        ; row ... -> row 19
        lda read_scroll_temp2_char-1, y
        sta read_screen_row19-1, y
        lda read_scroll_temp2_color-1, y
        sta read_colour_row19-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ;;dec VIC_BORDER

        ; print the next row in the off-screen space
        ;-----------------------------------------------------------------------
        ldx # 40
        lda # ' '
-       sta read_screen_addr_before-1, x
        dex
        bne -                   ; stop when X = 0 (important for later!)

        ; move the index in the line-lengths array back one line
        sec
        lda ZP_READ_LENS_LO
        sbc # 1
        sta ZP_READ_LENS_LO
        bcs +
        dec ZP_READ_LENS_HI
        sec

        ; move the address of the line above the screen
        ; backwards to the previous line address
        ;
+       lda ZP_READ_TOP_LO
        sbc (ZP_READ_LENS), y
        sta ZP_READ_TOP_LO
        sta READ_CHAR_LO        ; also set in the printing routine
        lda ZP_READ_TOP_HI
        sbc # 0                 ; ripple the subtract
        sta ZP_READ_TOP_HI
        sta READ_CHAR_HI

        ; repeat this for the off-screen
        ; line after the screen RAM
        ldy # 26
        lda ZP_READ_BOT_LO
        sbc (ZP_READ_LENS), y
        sta ZP_READ_BOT_LO
        bcs +
        dec ZP_READ_BOT_HI

+       ldy # 0                 ; starting row
        inx                     ; X = 1; number of rows to print

;===============================================================================
; print a number of lines from the article to the screen:
;
;       Y = row to begin printing
;       X = number of lines to print (1-based)
;       
read_lines:
        ;-----------------------------------------------------------------------
        ; prepare for printing:
        ;
        stx ZP_READ_ROWS        ; number of lines to print (1-based)
        jsr read_set_row        ; set starting row (0-based)

        ; get the number of bytes for this line,
        ; begin with the on-screen row index
@lens   ldy ZP_READ_ROW
        lda (ZP_READ_LENS), y   ; get length of the line
        tay                     ; Y = length of line data (in bytes)

        ; whilst we count Y down to zero, we keep a copy of the line-length
        ; to move the character pointer forward to the next line
        sty ZP_READ_LEN
        ; 0-length line is skipped,
        ; nothing to print
        beq @eol
        ; if this is $FF it's the indicator for the bottom of the article
        cpy # $ff
        beq @eof

.read_line:
        ;-----------------------------------------------------------------------
!addr   read_line       = .read_line

!addr   READ_CHAR       = @char+1
!addr   READ_CHAR_LO    = @char+1
!addr   READ_CHAR_HI    = @char+2

!addr   READ_OUT        = @out+1
!addr   READ_OUT_LO     = @out+1
!addr   READ_OUT_HI     = @out+2

!addr   READ_COLOR      = @color+1
!addr   READ_COLOR_LO   = @color+1
!addr   READ_COLOR_HI   = @color+2

        ; screen memory offset for the line
        ; (increases as each character is printed)
        ldx # 0

        ; read a byte from the binary string
@char   lda $8888, y
        
@out    sta read_screen_addr, x ; print the character
        ;;lda # READ_FORE         ; get text-colour ('random' for now)
@color  sta read_colour_addr, x ; set character colour
        inx
        dey
        bne @char

        ; end-of-line:
@eol    ; (note that Y is now zero due to line-bytes counting toward zero)
        tya
        ; reset screen-RAM / colour-RAM address
        ; offset for the next line
        tax
        
        dec ZP_READ_ROWS        ; all rows printed?
        beq @eof                ; yes -- stop printing

        ; look up the screen-address of the next row.
        ; (faster than adding 40 to the existing address,
        ;  since we don't need to read back the current value)
        ;
        ldy ZP_READ_ROW
        iny                     ; move to the next screen row
        jsr read_set_row

        ; move the data-pointer forward to the beginning of the next line,
        ; that is, add the length of the line (in bytes) to the pointer
        clc
        lda READ_CHAR_LO
        adc ZP_READ_LEN
        sta READ_CHAR_LO
        bcc @lens
        inc READ_CHAR_HI
        bne @lens

@eof    rts

;===============================================================================
; given a row, configures the line-printing routine to start from that row:
;
;       Y = screen row
;
read_set_row:
        ;-----------------------------------------------------------------------
        ; set this as the current row being printed
        sty ZP_READ_ROW
        ; get the screen address from the row number
        lda read_screen_rows_lo, y
        sta READ_OUT_LO
        lda read_screen_rows_hi, y
        sta READ_OUT_HI
        ; get the colour RAM address from the row number
        lda read_colour_rows_lo, y
        sta READ_COLOR_LO
        lda read_colour_rows_hi, y
        sta READ_COLOR_HI
        rts
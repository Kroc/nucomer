; n√ºcomer magazine (c) copyright Kroc Camen 2019. unless otherwise noted,
; licenced under Creative Commons Attribution Non-Commercial Share-Alike 4.0
; licence; you may reuse and modify this code how you please as long as you:
;
; - retain the copyright notice
; - use the same licence for your derived code
; - do not use it for commercial purposes
;   (contact the author for a commercial licence)
;
; read.acme:
;===============================================================================
; the screen used when reading articles

.THEME_GREY_BACK        = .VIC_LTGREY
.THEME_GREY_BORDER      = .THEME_GREY_BACK
.THEME_GREY_FORE        = .VIC_DKGREY
.THEME_GREY_TITLE       = .VIC_BLACK
.THEME_GREY_BOLD        = .VIC_WHITE
.THEME_GREY_NOUN        = .VIC_ORANGE
.THEME_GREY_NAME        = .VIC_PURPLE
.THEME_GREY_SOFT        = .VIC_GREY
.THEME_GREY_URL         = .VIC_BLUE
.THEME_GREY_WARN        = .VIC_RED

.THEME_BLUE_BACK        = .VIC_BLUE
.THEME_BLUE_BORDER      = .THEME_BLUE_BACK
.THEME_BLUE_FORE        = .VIC_LTBLUE
.THEME_BLUE_TITLE       = .VIC_YELLOW
.THEME_BLUE_BOLD        = .VIC_WHITE
.THEME_BLUE_NOUN        = .VIC_LTGREEN
.THEME_BLUE_NAME        = .VIC_GREEN
.THEME_BLUE_SOFT        = .VIC_GREY
.THEME_BLUE_URL         = .VIC_CYAN
.THEME_BLUE_WARN        = .VIC_RED

; define the default theme,
; as is compiled into the assembly:
;
.THEME_BACK             = .THEME_BLUE_BACK
.THEME_BORDER           = .THEME_BACK
.THEME_FORE             = .THEME_BLUE_FORE
.THEME_TITLE            = .THEME_BLUE_TITLE
.THEME_BOLD             = .THEME_BLUE_BOLD
.THEME_NOUN             = .THEME_BLUE_NOUN
.THEME_NAME             = .THEME_BLUE_NAME
.THEME_SOFT             = .THEME_BLUE_SOFT
.THEME_URL              = .THEME_BLUE_URL
.THEME_WARN             = .THEME_BLUE_WARN

!addr {
;===============================================================================
; number of lines in the complete article:
zp_read_lines           = $20
zp_read_lines_lo        = $20
zp_read_lines_hi        = $21

; height of the complete article -- in pixels! this is used to determine the
; exact point to clip smooth scrolling when scrolling quickly. the high-bit
; is used to determine the top of the article, so in practice the article
; is limited to $7FFF (32'767) pixels high, equivalant to 4'095 lines,
; or 170 screens high!
;
zp_read_vlen            = $22
zp_read_vlen_lo         = $22
zp_read_vlen_hi         = $23

; exact scroll position -- in pixels!
zp_read_vpos            = $24
zp_read_vpos_lo         = $24
zp_read_vpos_hi         = $25

; scroll accumulator, used for changing the speed
; of smooth scrolling; a signed byte
zp_read_scroll          = $26

; flag to indicate to disallow upward scrolling
; (prevents smooth scrolling at top of article)
zp_read_stop_up         = $27   ; $00 = go, $FF = stop
; flag to indicate to disallow downward scrolling
; (prevents smooth scrolling at bottom of article)
zp_read_stop_dn         = $28   ; $00 = go, $FF = stop

; pointer into the line-length array:
zp_read_lens            = $29
zp_read_lens_lo         = $29
zp_read_lens_hi         = $2a
; address of the line data that appears at the top of the screen:
; (changes only when scrolling, not during printing)
zp_read_top             = $2b
zp_read_top_lo          = $2b
zp_read_top_hi          = $2c
; number of rows to print: (1-based)
zp_read_rows            = $2d
; current row on screen being printed: (0-26)
zp_read_row             = $2e
; pointer to the current row's line-data;
; this is always where line-data is read from
zp_read_char            = $2f
zp_read_char_lo         = $2f
zp_read_char_hi         = $30
; current line data-length, in bytes:
zp_read_len             = $31
; indexes used when processing line colour-data (it's faster in this
; instance to use zero-page than use the stack or self-modifying-code)
zp_read_index_data      = $32
zp_read_index_col       = $33
; address of the line that appears at the bottom of the screen:
; (changes only when scrolling, not during printing)
zp_read_bot             = $34
zp_read_bot_lo          = $34
zp_read_bot_hi          = $35

; for text decompression, a buffer of 40 bytes is required; located in
; the zero-page for maximum speed. we _could_ decompress directly into
; screen RAM, but it would cause visual glitching when the beam goes
; through a line wilst un-packing
;
; TODO: make this 80-bytes, and we can use this buffer for
;       the temporary line copy during screen scrolling
;
zp_read_buffer          = $80
zp_read_buffer_len      = 40

; re-use the colour-data index for the decompression buffer,
; as the two won't ever be used at the same time
;
zp_read_buffer_index    = zp_read_index_col

}
;===============================================================================
read_screen_rows:
;-------------------------------------------------------------------------------
; this is a lookup table of row-number to screen address, but the screen is
; 27 rows high; this means that when printing row '0', it will be off-screen
; and likewise with row '26'
;
read_screen_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <nu_screen_before
        !for    row, 0, 24 {
                !byte   <(nu_screen + (row * 40))
        }
        !byte   <nu_screen_after

read_screen_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >nu_screen_before
        !for    row, 0, 24 {
                !byte   >(nu_screen + (row * 40))
        }
        !byte   >nu_screen_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_screen_row0        = nu_screen_before      ; off-screen row
read_screen_row1        = nu_screen+( 0*40)
read_screen_row2        = nu_screen+( 1*40)
read_screen_row3        = nu_screen+( 2*40)
read_screen_row4        = nu_screen+( 3*40)
read_screen_row5        = nu_screen+( 4*40)
read_screen_row6        = nu_screen+( 5*40)
read_screen_row7        = nu_screen+( 6*40)
read_screen_row8        = nu_screen+( 7*40)
read_screen_row9        = nu_screen+( 8*40)
read_screen_row10       = nu_screen+( 9*40)
read_screen_row11       = nu_screen+(10*40)
read_screen_row12       = nu_screen+(11*40)
read_screen_row13       = nu_screen+(12*40)
read_screen_row14       = nu_screen+(13*40)
read_screen_row15       = nu_screen+(14*40)
read_screen_row16       = nu_screen+(15*40)
read_screen_row17       = nu_screen+(16*40)
read_screen_row18       = nu_screen+(17*40)
read_screen_row19       = nu_screen+(18*40)
read_screen_row20       = nu_screen+(19*40)
read_screen_row21       = nu_screen+(20*40)
read_screen_row22       = nu_screen+(21*40)
read_screen_row23       = nu_screen+(22*40)
read_screen_row24       = nu_screen+(23*40)
read_screen_row25       = nu_screen+(24*40)
read_screen_row26       = nu_screen_after       ; off-screen-row
}

read_colour_rows:
;-------------------------------------------------------------------------------
; and as before with screen RAM, a lookup table of colour-RAM addresses
; for each row, but accounting for our before & after rows (above)
;
read_colour_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <nu_colour_before
        !for    row, 0, 24 {
                !byte   <($d800 + (row * 40))
        }
        !byte   <nu_colour_after

read_colour_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >nu_colour_before
        !for    row, 0, 24 {
                !byte   >($d800 + (row * 40))
        }
        !byte   >nu_colour_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_colour_row0        = nu_colour_before
read_colour_row1        = $d800+( 0*40) ;=$D800
read_colour_row2        = $d800+( 1*40)
read_colour_row3        = $d800+( 2*40)
read_colour_row4        = $d800+( 3*40)
read_colour_row5        = $d800+( 4*40)
read_colour_row6        = $d800+( 5*40)
read_colour_row7        = $d800+( 6*40)
read_colour_row8        = $d800+( 7*40)
read_colour_row9        = $d800+( 8*40)
read_colour_row10       = $d800+( 9*40)
read_colour_row11       = $d800+(10*40)
read_colour_row12       = $d800+(11*40)
read_colour_row13       = $d800+(12*40)
read_colour_row14       = $d800+(13*40)
read_colour_row15       = $d800+(14*40)
read_colour_row16       = $d800+(15*40)
read_colour_row17       = $d800+(16*40)
read_colour_row18       = $d800+(17*40)
read_colour_row19       = $d800+(18*40)
read_colour_row20       = $d800+(19*40)
read_colour_row21       = $d800+(20*40)
read_colour_row22       = $d800+(21*40)
read_colour_row23       = $d800+(22*40)
read_colour_row24       = $d800+(23*40)
read_colour_row25       = $d800+(24*40)
read_colour_row26       = nu_colour_after
}

;===============================================================================
;
read_styles:
read_styles_colour:
read_style0_colour:     !byte   .THEME_FORE     ; default text colour
read_style1_colour:     !byte   .THEME_TITLE    ; structural (e.g. title)
read_style2_colour:     !byte   .THEME_BOLD
read_style3_colour:     !byte   .THEME_NOUN     ; proper noun, work/citation
read_style4_colour:     !byte   .THEME_NAME     ; person / group
read_style5_colour:     !byte   .THEME_SOFT     ; soft / aside text
read_style6_colour:     !byte   .THEME_URL      ; URL
read_style7_colour:     !byte   .THEME_WARN     ; warning / error

;===============================================================================
read_screen:
        ;-----------------------------------------------------------------------
        ; setup the screen:
        ; turn the screen off whilst we clear it
        lda # %00000000
        sta .VIC_SCREEN_VERT

        ; set screen colour
        lda # .THEME_BORDER
        sta .VIC_BORDER
        ; (save a couple of bytes if the background/border are the same)
        !if .THEME_BORDER != .THEME_BACK {
        lda # .THEME_BACK
        }
        sta .VIC_BACKGROUND

        ; erase the text-screen
        lda # .THEME_FORE
        sta zp_print_colour
        jsr clear_screen

        ; whilst the off-screen lines will hold text waiting to be
        ; scrolled into view, we do need to fill these with spaces
        ; to begin with in case the first lines to be placed there
        ; do not fill 40-chars and we get screen garabge scrolling in
        ldx # 40-1
        lda # ' '
-       sta nu_screen_before, x
        sta nu_screen_after, x
        dex
        bpl -

        ; initialise printing:
        ;-----------------------------------------------------------------------
        ; the first two bytes are the size of the line-lengths array; in other
        ; words, how many lines in the article there are, and how far forward
        ; to skip to find the text data. we set the address of the first line
        ; to print
        ;
        ;       +--------------+  $4000
        ;       | tokens  (lo) |
        ;       |--------------|  $4100
        ;       | tokens  (hi) |
        ;       +--------------+  $4200
        ;       |              |
        ;       | line lengths |  (variable length)
        ;       :              :
        ;       +--------------+
        ;       |              |
        ;       | text data    |  (variable length)
        ;       :              :
        clc
        lda nu_text-2           ; lo-byte of no.lines
        adc #< (nu_lengths-2)   ; start of text data will come after lengths
        sta zp_read_char_lo     ; also park the reading head here
        sta zp_read_top_lo      ; and this will be the line above the screen
        lda nu_text-1           ; hi-byte of no.lines
        adc #> (nu_lengths-1)
        sta zp_read_char_hi
        sta zp_read_top_hi

        ; the line-length array begins after the token dictionary,
        ; and this is our intial pointer in the array
        ; -- we begin printing at article line 1
        lda #< nu_lengths
        sta zp_read_lens_lo
        lda #> nu_lengths
        sta zp_read_lens_hi

        ; for the smooth scrolling to not overshoot the bottom of the article,
        ; we need to calculate the height of the article in pixels; this is
        ; the number of lines multiplied by 8
        ;
        lda nu_text-2
        ; subtract 27 to account for where the top of the screen
        ; is when the bottom of the article is reached
        sec
        sbc # 27
        sta zp_read_vlen_lo
        lda nu_text-1
        sbc # 0
        sta zp_read_vlen_hi
        ; begin multiplying
        asl zp_read_vlen_lo     ; x2
        rol zp_read_vlen_hi     ; ...
        asl zp_read_vlen_lo     ; x4
        rol zp_read_vlen_hi     ; ...
        asl zp_read_vlen_lo     ; x8
        rol zp_read_vlen_hi     ; ...

        ; print the article's first screen full of text
        ;-----------------------------------------------------------------------
        ldy # 0                 ; begin on row 0 -- the off-screen row
        ldx # 27                ; number of rows to print (1-based)
        jsr read_print

        ; now that 27 rows have been printed, the routine will have left
        ; the details of the last row behind which we can make use of
        lda zp_read_char_lo
        sta zp_read_bot_lo
        lda zp_read_char_hi
        sta zp_read_bot_hi

        ;-----------------------------------------------------------------------
        ; reset the smooth scrolling variables
        ldx # $00
        stx zp_read_scroll      ; scroll-speed = 0
        stx zp_read_stop_dn     ; allow scrolling down; $00 = go, $FF = stop
        stx zp_read_vpos_lo     ; set the exact pixel vertical position
        stx zp_read_vpos_hi     ; within the article to zero
        ; we begin at the top of the article,
        ; so disallow scrolling upwards
        dex                     ; X = $FF
        stx zp_read_stop_up     ; $00 = go, $FF = stop

        ; set our own interrupt handlers:
        lda #< read_irqs        ; A = address of IRQ table, lo-byte
        ldx #> read_irqs        ; X = address of IRQ table, hi-byte
        ldy # 2                 ; Y = number of entries in the table (1-based)
        jsr irqs_load

        ; note that the screen will automatically turn itself back on
        ; because the raster interrupt that handles smooth-scrolling
        ; always sets the screen control register every vblank

read_keyboard:
        ;-----------------------------------------------------------------------
        jsr Keyboard
        bcc @crsr

        ; when no keys are pressed, or the scroll keys
        ; are released, stop the smooth scrolling
        lda # $00
        sta zp_read_scroll
        ; no key code to process,
        ; go back to waiting
        bpl read_keyboard       ; (always branches)

        ; cursor up/down
        ;-----------------------------------------------------------------------
@crsr   cpx # %10000000
        bne @spc

        ; up, or down?
        tya
        and # %01010000         ; are either of the shift keys pressed?
        bne @up                 ; if yes, it's CRSR-UP

        ; crsr-dn
        ;-----------------------------------------------------------------------
        ; if at the bottom of the article,
        ; do not allow scrolling any further
        ;
@dn     lda zp_read_stop_dn     ; check flag set when scroll hits the bottom
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content down the page:
        ; (smooth scroll upwards)
        ldx # $03               ; set scroll speed
        stx zp_read_scroll      ; this will be applied at interrupt
        ; whenever scrolling down,
        ; allow scrolling up again
        sta zp_read_stop_up     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

        ; crsr-up
        ;-----------------------------------------------------------------------
        ; if at the top of the article,
        ; do not allow scrolling any further
@up     lda zp_read_stop_up     ; check flag set when scroll hits the top
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content up the page
        ; (smooth scroll downwards)
        ldx # $fd               ; set -1 scroll speed
        stx zp_read_scroll      ; this will be applied at interrupt
        ; whenever scrolling up,
        ; allow scrolling down again
        sta zp_read_stop_dn     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

@spc    cmp # $20
        bne @esc
        jmp read_screen

@esc    cmp # $1f               ; "<-" key
        beq @exit
        
@stop   cpy # %10000000
        bne +
        brk

+       jmp read_keyboard

        ;-----------------------------------------------------------------------
        jmp *

        ; TODO: transition out
@exit   jsr irqs_disable        ; tear down the custom interrupt handlers
        rts                     ; return to the menu

;===============================================================================
; table of interrupts to use for the reading screen:
;
read_irqs:
;-------------------------------------------------------------------------------
; hard scrolling the screen takes a lot of cycles and we must be ahead of the
; beam when we do this to avoid screen-tearing, therefore we begin scrolling
; the top of the screen whilst the beam is in the middle of the screen
;
.READ_IRQ1      = SCANLINE_VBLANK_BEGIN - (14 * 8)

; just before the visible screen begins we set the vertical smooth-scrolling
; offset -- we cannot change the vertical scroll inside the screen or we will
; get tearing / glitching!
;
; hard scrolling the screen up or down takes a long time and even if we start
; before vblank, the process will overrun into the screen before it finishes,
; causing screen tear. therefore it is necessary for this interrupt to
; interrupt the previous one(!) whilst it is still shifting the screen,
; to ensure that the smooth scrolling register is not changed within
; the visible portion of the screen when hard-scrolling is occuring
;
.READ_IRQ2      = SCANLINE_VBLANK_END - 8

read_irqs_addr_lo:
        !byte   <read_irq_scroll
        !byte   <read_irq_top
read_irqs_addr_hi:
        !byte   >read_irq_scroll
        !byte   >read_irq_top
read_irqs_scanline_lo:
        !byte   <.READ_IRQ1
        !byte   <.READ_IRQ2
read_irqs_scanline_hi:
        !byte   (>.READ_IRQ1) << 7
        !byte   (>.READ_IRQ2) << 7

read_irq_top:
        ;-----------------------------------------------------------------------
        ;;inc .VIC_BORDER
        
        lda zp_read_vpos_lo
        and # %00000111
        eor # %00000111
        ; update the screen/scroll register:
        ;     %---1---- = screen on
        ;     %----0--- = 24 rows (for smooth scrolling)
        ;     %-----??? = vertical scroll offset
        ora # %00010000
        sta .VIC_SCREEN_VERT
        
;;        lda zp_read_vpos_hi
;;        pha                     ; put original value aside
;;        sed                     ; enable decimal mode
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+0
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+1
;;        cld
;;
;;        lda zp_read_vpos_lo
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+2
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+3
;;
;;        cld                     ; disable decimal mode
;;        lda zp_read_vlen_hi
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+5
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+6
;;        cld                     ; disable decimal mode
;;        lda zp_read_vlen_lo
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+7
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+8
;;

-       ;;dec .VIC_BORDER
        rts

read_irq_scroll:
        ;-----------------------------------------------------------------------
        ;;inc .VIC_BORDER

        ; is there any scrolling to be done?
        ;
        lda zp_read_scroll      ; read requested scroll speed
        beq -                   ; if scroll-speed = 0, then skip

        ; apply the scroll to our current
        ; vertical position within the article
        clc
        lda zp_read_vpos_lo
        ; remember the article position *before* the move;
        ; we'll need to mask the bottom three bits later
        tay
        ; note that regardless of positive or negative scroll speed,
        ; adding will always produce the same result due to the
        ; wrap-around nature of negative numbers (e.g. -1 = +$FF)
        adc zp_read_scroll
        sta zp_read_vpos_lo

        ; beyond one byte, we do have to take into
        ; account the postive / negative direction
        lda zp_read_vpos_hi
        ; check the sign-bit of the scroll-speed
        bit zp_read_scroll
        bmi +
        ; for positive numbers,
        ; the carry can be applied
        adc # 0
       +bit_skip2
        ; for negative numbers,
        ; the carry becomes a borrow
+       sbc # 0
        sta zp_read_vpos_hi

        ; hit top/bottom of article?
        ;-----------------------------------------------------------------------
        ; have we gone above the top of the article?
        ; (pixel vertical position < $0000)
        ldx zp_read_vpos_hi
        bpl +
        ; gone above the article; move back to the top
        stx zp_read_stop_up     ; X = $FF, disable scrolling upwards
        inx                     ; X = $00
        stx zp_read_vpos_lo     ; set scroll position within article
        stx zp_read_vpos_hi     ; to $0000

@done:  ;;dec .VIC_BORDER
        rts

        ; check the end of the article:
        ; (X = ZP_READ_VPOS_HI)
+       ldx zp_read_vlen_hi
        cpx zp_read_vpos_hi
        beq +                   ; hi-bytes equal, compare lo-bytes
        bcs @scroll             ; scroll position < height, scroll ahead
        bcc @stop               ; scroll position > height, go back!
        ; check the low-bytes
+       ldx zp_read_vlen_lo
        cpx zp_read_vpos_lo
        bcs @scroll
        
        ; gone below the article!
        ; move back to the end
@stop   ldx # $ff               ; set the flag to disallow
        stx zp_read_stop_dn     ; scrolling down ($FF = stop, $00 = go)
        inx                     ; X = $00
        sta zp_read_scroll      ; set scroll speed to zero
        ldx zp_read_vlen_lo     ; change the moved-to position back a bit
        stx zp_read_vpos_lo     ; to the exact bottom of the article
        lda zp_read_vlen_hi
        sta zp_read_vpos_hi
        
        ; do we need to hard-scroll?
        ;-----------------------------------------------------------------------
@scroll tya                     ; article scroll position *before* scroll
        and # %00000111
        sta zp_read_row         ; (temporary use)

        lda zp_read_vpos_lo     ; article scroll position *after* scroll
        and # %00000111
        bit zp_read_scroll
        bpl +

        cmp zp_read_row         ; (temporary use)
        bcc @done

        jmp read_scroll_up

+       cmp zp_read_row         ; (temporary use)
        bcs @done

;===============================================================================
; scroll the article down a line:
;
read_scroll_down:
        ;-----------------------------------------------------------------------
        ; copy the screen up a row -- due to the number of rows, the loop has
        ; to be split into three otherwise the relative branches cannot reach
        ; the top (>128 bytes) but we do want to get as close to that limit
        ; as possible (about 41 load + stores) as this minimizes the number
        ; of cycles wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
-       ; row 1 -> row 0
        lda read_screen_row1, y ; the top line moves into the off-screen
        sta read_screen_row0, y ; buffer ready for if the user scrolls up
        lda read_colour_row1, y ; (=$D800)
        sta read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        ; row 2 -> row 1
        lda read_screen_row2, y
        sta read_screen_row1, y
        lda read_colour_row2, y
        sta read_colour_row1, y
        ; row 3 -> row 2
        lda read_screen_row3, y
        sta read_screen_row2, y
        lda read_colour_row3, y
        sta read_colour_row2, y
        ; row 4 -> row 3
        lda read_screen_row4, y
        sta read_screen_row3, y
        lda read_colour_row4, y
        sta read_colour_row3, y
        ; row 5 -> row 4
        lda read_screen_row5, y
        sta read_screen_row4, y
        lda read_colour_row5, y
        sta read_colour_row4, y
        ; row 6 -> row 5
        lda read_screen_row6, y
        sta read_screen_row5, y
        lda read_colour_row6, y
        sta read_colour_row5, y
        ; row 7 -> row 6
        lda read_screen_row7, y
        sta read_screen_row6, y
        lda read_colour_row7, y
        sta read_colour_row6, y
        ; row 8 -> row 7
        lda read_screen_row8, y
        sta read_screen_row7, y
        lda read_colour_row8, y
        sta read_colour_row7, y
        ; row 9 -> row 8
        lda read_screen_row9, y
        sta read_screen_row8, y
        lda read_colour_row9, y
        sta read_colour_row8, y
        ; row 10 -> row 9
        lda read_screen_row10, y
        sta read_screen_row9, y
        lda read_colour_row10, y
        sta read_colour_row9, y
        dey
        bpl -

        ldy # 39
        ; row 11 -> row 10
-       lda read_screen_row11, y
        sta read_screen_row10, y
        lda read_colour_row11, y
        sta read_colour_row10, y
        ; row 12 -> row 11
        lda read_screen_row12, y
        sta read_screen_row11, y
        lda read_colour_row12, y
        sta read_colour_row11, y
        ; row 13 -> row 12
        lda read_screen_row13, y
        sta read_screen_row12, y
        lda read_colour_row13, y
        sta read_colour_row12, y
        ; row 14 -> row 13
        lda read_screen_row14, y
        sta read_screen_row13, y
        lda read_colour_row14, y
        sta read_colour_row13, y
        ; row 15 -> row 14
        lda read_screen_row15, y
        sta read_screen_row14, y
        lda read_colour_row15, y
        sta read_colour_row14, y
        ; row 16 -> row 15
        lda read_screen_row16, y
        sta read_screen_row15, y
        lda read_colour_row16, y
        sta read_colour_row15, y
        ; row 17 -> row 16
        lda read_screen_row17, y
        sta read_screen_row16, y
        lda read_colour_row17, y
        sta read_colour_row16, y
        ; row 18 -> row 17
        lda read_screen_row18, y
        sta read_screen_row17, y
        lda read_colour_row18, y
        sta read_colour_row17, y
        ; row 19 -> row 18
        lda read_screen_row19, y
        sta read_screen_row18, y
        lda read_colour_row19, y
        sta read_colour_row18, y
        ; row 20 -> row 19
        lda read_screen_row20, y
        sta read_screen_row19, y
        lda read_colour_row20, y
        sta read_colour_row19, y
        dey
        bpl -

        ldy # 40
        ; row 21 -> row 20
-       lda read_screen_row21-1, y
        sta read_screen_row20-1, y
        lda read_colour_row21-1, y
        sta read_colour_row20-1, y
        ; row 22 -> row 21
        lda read_screen_row22-1, y
        sta read_screen_row21-1, y
        lda read_colour_row22-1, y
        sta read_colour_row21-1, y
        ; row 23 -> row 22
        lda read_screen_row23-1, y
        sta read_screen_row22-1, y
        lda read_colour_row23-1, y
        sta read_colour_row22-1, y
        ; row 24 -> row 23
        lda read_screen_row24-1, y
        sta read_screen_row23-1, y
        lda read_colour_row24-1, y
        sta read_colour_row23-1, y
        ; row 25 -> row 24
        lda read_screen_row25-1, y
        sta read_screen_row24-1, y
        lda read_colour_row25-1, y
        sta read_colour_row24-1, y
        ; row 26 -> row 25
        ; copy the off-screen line into view
        lda read_screen_row26-1, y
        sta read_screen_row25-1, y
        ; note that the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row26-1, y
        sta read_colour_row25-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ;;dec .VIC_BORDER

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; blank the off-screen row so that we don't scroll in garbage
        ; if the new line is shorter than the previous line
        ldx # 40
        lda # ' '
-       sta nu_screen_after-1, x
        dex
        bne -                   ; stop when X = 0 (important for later!)

        ; read the length of the current line at the top of the screen,
        ; and move the line-pointer for the top screen line to the next line
        ;
        clc                     ; (note that Y = 0)
        lda (zp_read_lens), y   ; length of line above screen
        and # %00111111         ; (top two bits are flags)
        adc zp_read_top_lo      ; add line-length to the line address
        sta zp_read_top_lo      ; (move to next line)
        bcc +
        inc zp_read_top_hi
        clc

        ; do the same but with the line-pointer for the bottom row of the
        ; screen, but also write the address into the print routine
        ;
+       ldy # 26                ; row to begin printing at (below screen)
        lda (zp_read_lens), y   ; length of line at bottom of screen
        and # %00111111         ; (top two bits are flags)
        adc zp_read_bot_lo      ; add line-length to the line address
        sta zp_read_bot_lo      ; (move to next line)
        sta zp_read_char_lo     ; set printing routine line-address (lo)
        lda zp_read_bot_hi
        adc # 0                 ; ripple the add
        sta zp_read_bot_hi
        sta zp_read_char_hi     ; set printing routine line-address (hi)

        ; move to the next entry in the line-lengths array
        inc zp_read_lens_lo
        bne +
        inc zp_read_lens_hi

+       inx                     ; X = 1; number of lines to print
        jmp read_print          ; note that Y = 26, row to print from

;===============================================================================
; scroll the article up a line:
;
read_scroll_up:
        ;-----------------------------------------------------------------------
        ; copy the screen down a row:
        ;
        ; credit for this particular methodology must go to Richard Bayliss
        ; of The New Dimenson for producing a copy routine fast enough to
        ; copy the screen bottom-up before the scanline catches up
        ; <http://tnd64.unikat.sk/assemble_it6.html>
        ;
        ; due to the number of rows, the loop has to be split into three
        ; otherwise the relative branches cannot reach the top (>128 bytes)
        ; but we do want to get close to that limit as possible (about
        ; 41 load + stores) as this minimizes the amount of cycles
        ; wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
        ; row 9 -> row ...
-       lda read_screen_row9, y
        sta nu_screen_temp, y
        lda read_colour_row9, y
        sta nu_colour_temp, y
        ; row 8 -> row 9
        lda read_screen_row8, y
        sta read_screen_row9, y
        lda read_colour_row8, y
        sta read_colour_row9, y
        ; row 7 -> row 8
        lda read_screen_row7, y
        sta read_screen_row8, y
        lda read_colour_row7, y
        sta read_colour_row8, y
        ; row 6 -> row 7
        lda read_screen_row6, y
        sta read_screen_row7, y
        lda read_colour_row6, y
        sta read_colour_row7, y
        ; row 5 -> row 6
        lda read_screen_row5, y
        sta read_screen_row6, y
        lda read_colour_row5, y
        sta read_colour_row6, y
        ; row 4 -> row 5
        lda read_screen_row4, y
        sta read_screen_row5, y
        lda read_colour_row4, y
        sta read_colour_row5, y
        ; row 3 -> row 4
        lda read_screen_row3, y
        sta read_screen_row4, y
        lda read_colour_row3, y
        sta read_colour_row4, y
        ; row 2 -> row 3
        lda read_screen_row2, y
        sta read_screen_row3, y
        lda read_colour_row2, y
        sta read_colour_row3, y
        ; row 1 -> row 2
        lda read_screen_row1, y
        sta read_screen_row2, y
        lda read_colour_row1, y
        sta read_colour_row2, y
        ; row 0 -> row 1
        ; (copy the off-screen line into view)
        lda read_screen_row0, y
        sta read_screen_row1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $D800-40 when I/O is on!
        lda read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        sta read_colour_row1, y ; (=$D800)
        dey
        bpl -

        ldy # 39
        ; row 18 -> row ...
        ; (we use the off-screen row above temporarily as it is "garbage" at
        ;  this point until after the screen copy, when it will be populated)
-       lda read_screen_row18, y
        sta read_screen_row0, y
        lda read_colour_row18, y
        sta read_colour_row0, y
        ; row 17 -> row 18
        lda read_screen_row17, y
        sta read_screen_row18, y
        lda read_colour_row17, y
        sta read_colour_row18, y
        ; row 16 -> row 17
        lda read_screen_row16, y
        sta read_screen_row17, y
        lda read_colour_row16, y
        sta read_colour_row17, y
        ; row 15 -> row 16
        lda read_screen_row15, y
        sta read_screen_row16, y
        lda read_colour_row15, y
        sta read_colour_row16, y
        ; row 14 -> row 15
        lda read_screen_row14, y
        sta read_screen_row15, y
        lda read_colour_row14, y
        sta read_colour_row15, y
        ; row 13 -> row 14
        lda read_screen_row13, y
        sta read_screen_row14, y
        lda read_colour_row13, y
        sta read_colour_row14, y
        ; row 12 -> row 13
        lda read_screen_row12, y
        sta read_screen_row13, y
        lda read_colour_row12, y
        sta read_colour_row13, y
        ; row 11 -> row 12
        lda read_screen_row11, y
        sta read_screen_row12, y
        lda read_colour_row11, y
        sta read_colour_row12, y
        ; row 10 -> row 11
        lda read_screen_row10, y
        sta read_screen_row11, y
        lda read_colour_row10, y
        sta read_colour_row11, y
        ; row ... -> row 10
        lda nu_screen_temp, y
        sta read_screen_row10, y
        lda nu_colour_temp, y
        sta read_colour_row10, y
        dey
        bpl -

        ldy # 40
        ; row 25 -> row 26
        ; the bottom line moves into the off-screen
        ; buffer ready for if the user scrolls down
-       lda read_screen_row25-1, y
        sta read_screen_row26-1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row25-1, y
        sta read_colour_row26-1, y
        ; row 24 -> row 25
        lda read_screen_row24-1, y
        sta read_screen_row25-1, y
        lda read_colour_row24-1, y
        sta read_colour_row25-1, y
        ; row 23 -> row 24
        lda read_screen_row23-1, y
        sta read_screen_row24-1, y
        lda read_colour_row23-1, y
        sta read_colour_row24-1, y
        ; row 22 -> row 23
        lda read_screen_row22-1, y
        sta read_screen_row23-1, y
        lda read_colour_row22-1, y
        sta read_colour_row23-1, y
        ; row 21 -> row 22
        lda read_screen_row21-1, y
        sta read_screen_row22-1, y
        lda read_colour_row21-1, y
        sta read_colour_row22-1, y
        ; row 20 -> row 21
        lda read_screen_row20-1, y
        sta read_screen_row21-1, y
        lda read_colour_row20-1, y
        sta read_colour_row21-1, y
        ; row 19 -> row 20
        lda read_screen_row19-1, y
        sta read_screen_row20-1, y
        lda read_colour_row19-1, y
        sta read_colour_row20-1, y
        ; row ... -> row 19
        lda read_screen_row0-1, y
        sta read_screen_row19-1, y
        lda read_colour_row0-1, y
        sta read_colour_row19-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ;;dec .VIC_BORDER

        ; print the next row in the off-screen space
        ;-----------------------------------------------------------------------
        ldx # 40
        lda # ' '
-       sta nu_screen_before-1, x
        dex
        bne -                   ; stop when X = 0 (important for later!)

        sec
        lda zp_read_lens_lo     ; move the index in the line-lengths array...
        sbc # 1                 ; ...back one line
        sta zp_read_lens_lo
        bcs +
        dec zp_read_lens_hi
        sec

        ; move the address of the line above the screen
        ; backwards to the previous line address
        ;
        ; TODO: anyway to do this subtraction faster? (EOR-1?)
        ;       the need to mask the top bits prevents us
        ;       from using `sbc (ZP_READ_LENS), y`
        ;
+       lda (zp_read_lens), y
        and # %00111111         ; (top two bits are flags)
        sta zp_read_row         ; (temporary use)

        lda zp_read_top_lo
        sbc zp_read_row         ; (length of line-data, in bytes)
        sta zp_read_top_lo
        sta zp_read_char_lo     ; also set in the printing routine
        lda zp_read_top_hi
        sbc # 0                 ; ripple the subtract
        sta zp_read_top_hi
        sta zp_read_char_hi     ; also set in the printing routine

        ; repeat this for the off-screen
        ; line after the screen RAM
        ;
        ; TODO: anyway to do this subtraction faster? (EOR-1?)
        ;       the need to mask the top bits prevents us
        ;       from using `sbc (ZP_READ_LENS), y`
        ;
        ldy # 26
        lda (zp_read_lens), y   ; length of line-data, in bytes
        and # %00111111         ; (top two bits are flags)
        sta zp_read_row         ; (temporary use)

        lda zp_read_bot_lo
        sbc zp_read_row         ; (length of line-data, in bytes)
        sta zp_read_bot_lo
        bcs +
        dec zp_read_bot_hi

+       ldy # 0                 ; starting row
        inx                     ; X = 1; number of rows to print

;===============================================================================
; print a number of lines from the article to the screen:
;
;       Y = row to begin printing
;       X = number of lines to print (1-based)
;       
; the address to read data from must already be set in:
;
;       zp_read_char_lo &
;       zp_read_char_hi
;
read_print:
        ;-----------------------------------------------------------------------
        ; prepare for printing:
        ;
        stx zp_read_rows        ; number of lines to print (1-based)
        sty zp_read_row         ; current row being printed

        ; print a line:
        ;-----------------------------------------------------------------------
@line:  ldy zp_read_row         ; current row...

        ; set the screen address from the row number
        lda read_screen_rows_lo, y
        sta @out+1
        lda read_screen_rows_hi, y
        sta @out+2
        ; get the number of *compressed* bytes for this line;
        ; this is not the number of characters on the line,
        ; and the upper two-bits are used as flags
        lda (zp_read_lens), y

        ; most lines of text will not require colour data, resorting to the
        ; 'default' style. if we included a byte for every line to indicate
        ; if it had colour-data or not, this would waste a lot of bytes very
        ; quickly; 500 extra bytes for 500 lines is a lot of wasted bytes!
        ;
        ; instead, the upper-bit of the line-length is used to indicate the
        ; presence of colour-data in the line-data. the compare instruction
        ; that follows will check the high-bit of the line-length; if it's 0,
        ; carry is set; if 1, carry is cleared. we use this as our indicator
        ; for reading & processing colour-data from the line-data
        ;
        cmp # %10000000         ; check for high-bit on the byte-count
        beq @eof                ; terminator mark ($80), article ends
        
        and # %00111111         ; (strip flags from byte-count)

        tay                     ; Y = length of line-data (in bytes)
        ; whilst we count Y down to zero, we keep a copy of the line-length
        ; to move the character pointer forward to the next line (the flags
        ; in the upper bits have been been stripped now)
        sty zp_read_len

        ; skip a zero-length line
        ; (line-length must be recorded first)
        beq @eol

        ; if colour data is present, go process it first
        ; (note that the carry bit has not been modified
        ;  since the CMP instruction above)
        bcs @cdata

        ; when no colour data is present, we still have to
        ; colour the whole line with the default style
        lda read_style0_colour
        jsr read_colour_row

        ; decompress the line into the zero-page buffer;
        ;-----------------------------------------------------------------------
        ; Y is the number of compressed bytes remaining to read; these will
        ; be decompressed into a buffer of screen-codes ready to print.
        ; the number of characters to print (0-based) will be returned in X
@print: jsr read_decompress

-       lda zp_read_buffer, x   ; read a character from the buffer
@out    sta nu_screen, x        ; print the character
        dex                     ; more characters remain in the buffer?
        bpl -                   ; keep printing whilst characters remain

        ; end-of-line:
        ;-----------------------------------------------------------------------
@eol:   dec zp_read_rows        ; all rows printed?
        beq @eof                ; yes -- stop printing

        inc zp_read_row         ; move to the next screen row

        ; move the data-pointer forward to the beginning of the next line,
        ; that is, add the length of the line (in bytes) to the pointer
        clc
        lda zp_read_char_lo
        adc zp_read_len
        sta zp_read_char_lo
        bcc @line
        inc zp_read_char_hi
        bne @line

        brk

@eof:   rts

        ; colour whole row:
        ;=======================================================================
@whole: and # %00000111         ; which style class
        tax                     ; (we know this is the first byte, so reuse X)
        
        ; get the colour for the given style class
        lda read_styles_colour, x
        jsr read_colour_row

        ; begin printing text:
        dey                     ; move to the next line-data byte
        bne @print              ; (always branches, Y != 0)

        brk

        ; decode colour-data:
        ;=======================================================================
        ; the first colour byte is special:
        ;
        ; if the upper bit is set, this indicates that the whole line is
        ; coloured a non-default colour and no other colour data will follow
        ;
@cdata: lda (zp_read_char), y   ; read first colour-data byte
        bmi @whole              ; colour whole row one colour?

        dey                     ; move to the next data-byte
        sty zp_read_index_data  ; save the current position

        ; if the first byte upper-bit is not set, the first byte represents
        ; an initial column offset before the first colour change occurs
        ; (colour spans are limited to 32-chars, but the initial-offset can
        ;  be higher, though obviously limited to the width of the screen)
        ;
        ; now that we know we will be reading more than 1-byte of colour
        ; data, we set up the colour-RAM address we'll be writing to:
        ;
        pha                     ; backup the first data-byte

        ldx zp_read_row         ; current row being printed
        lda read_colour_rows_hi, x
        sta @clram+2
        lda read_colour_rows_lo, x
        sbc # 1                 ; (carry is still set from way, way back!)
        sta @clram+1

        ldx # 40                ; starting column
        stx zp_read_index_col   ; (colouring right-to-left!)

        pla                     ; length of first span (can be > 32)
        beq @cread              ; if there's no initial offset, ignore it

        tay                     ; number of characters to colour
        dey                     ; (adjust to 0-based for the colouring loop)
        lda read_style0_colour  ; use the default line colour
        bne @clram              ; (always branches, != 0)

        brk

        ; process colour-spans:
        ;-----------------------------------------------------------------------
        ; after the first byte is processed, all colour-data bytes that follow
        ; use a fixed format:
        ;
        ;       %sssnnnnn       s = style class to change to (0-7)
        ;                       n = length of span (0-31, represents 1 to 32)
        ;
@cread: ldy zp_read_index_data  ; retrieve the data-index before reading
        lda (zp_read_char), y   ; read a byte of colour-data
        tax                     ; (put-aside to extract the style-class later)
        dec zp_read_index_data  ; move to the next data-byte
        and # %00011111         ; extract the span-length from the byte,
        tay                     ; and use this as a count-down

        ; decode the style-class from the top three bits;
        ; we need to rotate these into the bottom three bits
        ;
        txa                     ; retrieve the data-byte again
        and # %11100000         ; keep top three bits (also, no carry at end)
        asl                     ; pop bit 7 off
        rol                     ; shift bit 7 in, pop bit 6 off
        rol                     ; shift bit 6 in, pop bit 5 off
        rol                     ; shift bit 5 in
        tax                     ; we now have the style class 0-7
        lda read_styles, x      ; look up the style class from the index

        ldx zp_read_index_col   ; restore our current column number
@clram  sta $d800, x            ; set the colour
        dex
        beq @cdone
        dey                     ; one less cell to colour...
        bpl @clram              ; keep going?
        
        stx zp_read_index_col   ; remember current column for the next span
        bmi @cread              ; read the next span from the colour-data?

        brk

        ; finished colour-data, begin printing text:
        ;-----------------------------------------------------------------------
@cdone: ldy zp_read_index_data  ; retrieve the data-index for reading bytes
        bne @print              ; (always branches, Y != 0)
        
        brk
        !byte   $42
        !pet    "impossible branch!", 0

;===============================================================================
; colour a whole row:
;
;       A = colour
;       (Y is preserved)
;
read_colour_row:
        ;-----------------------------------------------------------------------
        ; which row are we on?
        ; (there are speed-paths for the off-screen rows)
        ldx zp_read_row
        beq @before             ; row = 0, colour off-screen row above screen
        cpx # 26                ; row = 26?
        beq @after              ; row = 26, colour off-screen row below screen

        ; rows 1-25: use the general slow path:
        ;-----------------------------------------------------------------------
        pha                     ; put colour aside

        ; look up the address to write to
        ; (X is the current row)
        lda read_colour_rows_lo, x
        sta @color+1
        lda read_colour_rows_hi, x
        sta @color+2

        pla                     ; get the colour back
        ldx # 40-1              ; colour 40 columns...
@color  sta $d800, x
        dex
        bpl @color

        rts

        ; colour offscreen row after screen:
        ;-----------------------------------------------------------------------
@after  ; fast-fill the row colour:
        ; (A = colour)
        ; (X offset = start of row)
        ; (JSR offset = colour 40 chars)
        ldx # 0
        jmp read_set_colour_after+0

        ; colour offscreen row before screen:
        ;-----------------------------------------------------------------------
@before ; fast-fill the row colour:
        ; (A = colour)
        ; (X offset = start of row), note that X is already 0
        ; (JSR offset = colour 40 chars)
        ;
        ;;jmp read_set_colour_before+0

;===============================================================================
; set the colour for some, or all, of the off-screen top row:
;
; this is a "fast path" to set a colour on the characters of the off-screen
; row above the screen; the idea is to jump into the routine at the point
; where the number of characters you want to colour remain; X can be used
; to offset from the first column
;
;       A = colour
;       X = character offset
;
read_set_colour_before:
        ;-----------------------------------------------------------------------
        sta nu_colour_before+0,  x      ; jsr +   0: colour 40 chars
        sta nu_colour_before+1,  x      ; jsr +   3: colour 39 chars
        sta nu_colour_before+2,  x      ; jsr +   6: colour 38 chars
        sta nu_colour_before+3,  x      ; jsr +   9: colour 37 chars
        sta nu_colour_before+4,  x      ; jsr +  12: colour 36 chars
        sta nu_colour_before+5,  x      ; jsr +  15: colour 35 chars
        sta nu_colour_before+6,  x      ; jsr +  18: colour 34 chars
        sta nu_colour_before+7,  x      ; jsr +  21: colour 33 chars
        sta nu_colour_before+8,  x      ; jsr +  24: colour 32 chars
        sta nu_colour_before+9,  x      ; jsr +  27: colour 31 chars
        sta nu_colour_before+10, x      ; jsr +  30: colour 30 chars
        sta nu_colour_before+11, x      ; jsr +  33: colour 29 chars
        sta nu_colour_before+12, x      ; jsr +  36: colour 28 chars
        sta nu_colour_before+13, x      ; jsr +  39: colour 27 chars
        sta nu_colour_before+14, x      ; jsr +  42: colour 26 chars
        sta nu_colour_before+15, x      ; jsr +  45: colour 25 chars
        sta nu_colour_before+16, x      ; jsr +  48: colour 24 chars
        sta nu_colour_before+17, x      ; jsr +  51: colour 23 chars
        sta nu_colour_before+18, x      ; jsr +  54: colour 22 chars
        sta nu_colour_before+19, x      ; jsr +  57: colour 21 chars
        sta nu_colour_before+20, x      ; jsr +  60: colour 20 chars
        sta nu_colour_before+21, x      ; jsr +  63: colour 19 chars
        sta nu_colour_before+22, x      ; jsr +  66: colour 18 chars
        sta nu_colour_before+23, x      ; jsr +  69: colour 17 chars
        sta nu_colour_before+24, x      ; jsr +  72: colour 16 chars
        sta nu_colour_before+25, x      ; jsr +  75: colour 15 chars
        sta nu_colour_before+26, x      ; jsr +  78: colour 14 chars
        sta nu_colour_before+27, x      ; jsr +  81: colour 13 chars
        sta nu_colour_before+28, x      ; jsr +  84: colour 12 chars
        sta nu_colour_before+29, x      ; jsr +  87: colour 11 chars
        sta nu_colour_before+30, x      ; jsr +  90: colour 10 chars
        sta nu_colour_before+31, x      ; jsr +  93: colour 9 chars
        sta nu_colour_before+32, x      ; jsr +  96: colour 8 chars
        sta nu_colour_before+33, x      ; jsr +  99: colour 7 chars
        sta nu_colour_before+34, x      ; jsr + 102: colour 6 chars
        sta nu_colour_before+35, x      ; jsr + 105: colour 5 chars
        sta nu_colour_before+36, x      ; jsr + 108: colour 4 chars
        sta nu_colour_before+37, x      ; jsr + 111: colour 3 chars
        sta nu_colour_before+38, x      ; jsr + 114: colour 2 chars
        sta nu_colour_before+39, x      ; jsr + 117: colour 1 char
        
        rts

;===============================================================================
; set the colour for some, or all, of the off-screen bottom row:
;
; this is a "fast path" to set a colour on the characters of the off-screen
; row below the screen; the idea is to jump into the routine at the point
; where the number of characters you want to colour remain; X can be used
; to offset from the first column
;
;       A = colour
;       X = character offset
;
read_set_colour_after:
        ;-----------------------------------------------------------------------
        sta nu_colour_after+0,  x       ; jsr +   0: colour 40 chars
        sta nu_colour_after+1,  x       ; jsr +   3: colour 39 chars
        sta nu_colour_after+2,  x       ; jsr +   6: colour 38 chars
        sta nu_colour_after+3,  x       ; jsr +   9: colour 37 chars
        sta nu_colour_after+4,  x       ; jsr +  12: colour 36 chars
        sta nu_colour_after+5,  x       ; jsr +  15: colour 35 chars
        sta nu_colour_after+6,  x       ; jsr +  18: colour 34 chars
        sta nu_colour_after+7,  x       ; jsr +  21: colour 33 chars
        sta nu_colour_after+8,  x       ; jsr +  24: colour 32 chars
        sta nu_colour_after+9,  x       ; jsr +  27: colour 31 chars
        sta nu_colour_after+10, x       ; jsr +  30: colour 30 chars
        sta nu_colour_after+11, x       ; jsr +  33: colour 29 chars
        sta nu_colour_after+12, x       ; jsr +  36: colour 28 chars
        sta nu_colour_after+13, x       ; jsr +  39: colour 27 chars
        sta nu_colour_after+14, x       ; jsr +  42: colour 26 chars
        sta nu_colour_after+15, x       ; jsr +  45: colour 25 chars
        sta nu_colour_after+16, x       ; jsr +  48: colour 24 chars
        sta nu_colour_after+17, x       ; jsr +  51: colour 23 chars
        sta nu_colour_after+18, x       ; jsr +  54: colour 22 chars
        sta nu_colour_after+19, x       ; jsr +  57: colour 21 chars
        sta nu_colour_after+20, x       ; jsr +  60: colour 20 chars
        sta nu_colour_after+21, x       ; jsr +  63: colour 19 chars
        sta nu_colour_after+22, x       ; jsr +  66: colour 18 chars
        sta nu_colour_after+23, x       ; jsr +  69: colour 17 chars
        sta nu_colour_after+24, x       ; jsr +  72: colour 16 chars
        sta nu_colour_after+25, x       ; jsr +  75: colour 15 chars
        sta nu_colour_after+26, x       ; jsr +  78: colour 14 chars
        sta nu_colour_after+27, x       ; jsr +  81: colour 13 chars
        sta nu_colour_after+28, x       ; jsr +  84: colour 12 chars
        sta nu_colour_after+29, x       ; jsr +  87: colour 11 chars
        sta nu_colour_after+30, x       ; jsr +  90: colour 10 chars
        sta nu_colour_after+31, x       ; jsr +  93: colour 9 chars
        sta nu_colour_after+32, x       ; jsr +  96: colour 8 chars
        sta nu_colour_after+33, x       ; jsr +  99: colour 7 chars
        sta nu_colour_after+34, x       ; jsr + 102: colour 6 chars
        sta nu_colour_after+35, x       ; jsr + 105: colour 5 chars
        sta nu_colour_after+36, x       ; jsr + 108: colour 4 chars
        sta nu_colour_after+37, x       ; jsr + 111: colour 3 chars
        sta nu_colour_after+38, x       ; jsr + 114: colour 2 chars
        sta nu_colour_after+39, x       ; jsr + 117: colour 1 char
        
        rts

;===============================================================================
; decompress text:
;
; params:
;       Y = number of [compressed] bytes to read
;           (value is clobbered on return)
;
; returns:
;       X = number of characters in the buffer to print
;
read_decompress:
        ;-----------------------------------------------------------------------
        ; initialise our position within the decompression buffer
        ;
        lda # 0
        sta zp_read_buffer_index

        iny

        ;-----------------------------------------------------------------------
        ; the stack has been emptied, fetch more tokens:
        ;
@fetch: dey                     ; move to next token
        beq @done               ; if we reach the end, stop decompressing
        
        ; rather than check the height of the stack, it's easier and faster
        ; to just push a zero on the bottom and when it comes out, push it
        ; back in again. this way we don't have to numerically examine the
        ; stack pointer
        ;
        pha

        lda (zp_read_char), y   ; read a token
        pha                     ; push the token onto the stack for decoding

        ;-----------------------------------------------------------------------
        ; are there any tokens waiting to be decoded?
        ;
        ; a zero is placed on the bottom of the stack to indicate
        ; when there are no more tokens on the stack
        ;
@next:  pla
        beq @fetch              ; go fetch more tokens

        ; examine the token:
        ;-----------------------------------------------------------------------
        tax
        ; check the left-hand byte in the token
        lda nu_tokens_lo, x
        ; if this is zero, it indicates that the token is literal,
        ; and the right-hand byte contains the screen-code
        beq @lit
        
        ; process token-pair; the left-hand and right-hand bytes
        ; both represent additional tokens; push them onto the
        ; stack for further decoding
        ; TODO:
        brk

        ; token is a literal:
        ; read the screen-code from the right-hand byte
@lit:   lda nu_tokens_hi, x

        ; put into the buffer
        ldx zp_read_buffer_index
        sta zp_read_buffer, x
        ; move to the next byte in the output buffer
        inc zp_read_buffer_index

        bne @next
        brk

        ;-----------------------------------------------------------------------
        ; before we return, note that X is the length of the buffer (0-based)
@done:  rts
; the screen used when reading articles

; theme colours
READ_BORDER     = GREY
READ_FORE       = DKGREY
READ_BACK       = GREY

; address of the line that appears at the top
; of the screen, i.e. the scroll position
ZP_READ_LINE    = $fd
ZP_READ_LINE_LO = $fd
ZP_READ_LINE_HI = $fe

; current row on screen being printed
ZP_READ_ROW     = $fc
; number of rows to print
ZP_READ_ROWS    = $fb

; current line length
ZP_READ_LEN     = $fa

; address within the line-length array
; for the current line
ZP_READ_LENS    = $f8
ZP_READ_LENS_LO = $f8
ZP_READ_LENS_HI = $f9

;===============================================================================
read_screen:
        ; setup the screen:
        ;-----------------------------------------------------------------------
        ; turn the screen off whilst we clear it
        lda # %00001000
        sta VIC_SCREEN_CTL1

        ; set screen colour
        lda # READ_BORDER
        sta VIC_BORDER
        lda # READ_BACK
        sta VIC_BACKGROUND

        ; erase the text-screen
        lda # READ_FORE
        sta ZP_COLOR
        jsr clear_screen

        ; load the article:
        jsr read_load

        ; turn screen on
        lda # %00011011
        sta VIC_SCREEN_CTL1

        ; prepare for printing
        ;-----------------------------------------------------------------------
        ; the first two bytes are the size of the line-length array;
        ; in other words, how far forward to skip to find the text data
        clc
        lda $2000
        adc #< $2000
        sta @char+1
        lda $2001
        adc #> $2000
        sta @char+2

        ; number of rows to print (1-based)
        lda # 25
        sta ZP_READ_ROWS

        ; ergo, the line-length array begins two bytes in
        ; and this is our intial index into the array
        lda #< $2002
        sta @lens+1
        lda #> $2002
        sta @lens+2

        ; set the output address in the printing
        ; code based on this row+col
        lda # 0
        sta ZP_READ_ROW
        tay
        ; screen memory offset for the line
        ; (increases as each character is printed)
        tax

        ; set the initial screen address
        clc
        adc screen_rows_lo, y
        sta @out+1
        lda screen_rows_hi, y
        adc # 0
        sta @out+2

        ; print line!
        ;-----------------------------------------------------------------------
        ; get the number of bytes for this line
@lens   ldy $8888
        sty ZP_READ_LEN

        ; 0-length line is skipped,
        ; nothing to print
        beq @eol

        ; read a byte from the binary string
@char   lda $8888, y
        
        ; print the character
@out    sta $0400, x
        inx
        
        dey
        bne @char

        ; end-of-line:
@eol    ; (note that Y is now zero due to line-bytes counting toward zero)
        tya
        tax             ; reset screen address offset for the next line
        
        ; this to be optimized
        inc ZP_READ_ROW
        ldy ZP_READ_ROW
        dec ZP_READ_ROWS
        beq @eof

        ; look up the screen-address of the next row.
        ; faster than adding 40 to the existing address,
        ; since we don't need to read back the current value
        lda screen_rows_lo, y
        sta @out+1
        lda screen_rows_hi, y
        sta @out+2

        clc
        lda @char+1
        adc ZP_READ_LEN
        sta @char+1
        bcc +
        inc @char+2

+       inc @lens+1
        bne @lens
        inc @lens+2
        bne @lens

@eof
        jmp *

        ; tear down the custom interrupt handlers
        jsr disable_interrupts
        rts

;===============================================================================
; load the article:
;
; TODO: obviously this would happen at some other stage and use an IRQ-driven
;       fast-loader such as Krill's
;
read_filename:
        ;-----------------------------------------------------------------------
        !pet    "lorem-ipsum"

read_load:
        ;-----------------------------------------------------------------------
        sei                     ; disable interrupts

        ; turn on the KERNAL
        inc CPU_CONTROL

        ; get the last-used device number set by the KERNAL
        lda $ba
        bne +                   ; not 0? good
+       ldx # DEV_DRV8          ; default to drive 8
        ldy # $00               ; use custom load address
        tya                     ; logical file number
        jsr KERNAL_SETLFS

        lda # 11                ; string-length
        ldx #< read_filename
        ldy #> read_filename
        jsr KERNAL_SETNAM

        lda # 0                 ; load, not verify
        ldx #< $2000
        ldy #> $2000
        jsr KERNAL_LOAD

        ; TODO: error handling, fastloader et al

        dec CPU_CONTROL         ; turn KERNAL off
        rts

;===============================================================================
; print a number of lines from the article to the screen:
;
read_lines:

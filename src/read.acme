; the screen used when reading articles

; theme colours
READ_BORDER     = GREY
READ_FORE       = DKGREY
READ_BACK       = GREY

; pointer into the line-length array
ZP_READ_LENS    = $10
ZP_READ_LENS_LO = $10
ZP_READ_LENS_HI = $11
; address of the line data that appears at the top of the screen
; (changes only when scrolling, not during printing)
ZP_READ_TOP     = $12
ZP_READ_TOP_LO  = $12
ZP_READ_TOP_HI  = $13
; current row on screen being printed (0-24)
ZP_READ_ROW     = $14
; current line length
ZP_READ_LEN     = $15
; number of rows to print
ZP_READ_ROWS    = $16
; address of the line that appears at the bottom of the screen
; (changes only when scrolling, not during printing)
ZP_READ_BOT     = $17
ZP_READ_BOT_LO  = $17
ZP_READ_BOT_HI  = $18

;===============================================================================
read_screen:
        ; setup the screen:
        ;-----------------------------------------------------------------------
        ; turn the screen off whilst we clear it
        lda # %00001000
        sta VIC_SCREEN_CTL1

        ; set screen colour
        lda # READ_BORDER
        sta VIC_BORDER
        lda # READ_BACK
        sta VIC_BACKGROUND

        ; erase the text-screen
        lda # READ_FORE
        sta ZP_COLOR
        jsr clear_screen

        ; for vertical scrolling, we place spaces before and after the
        ; screen RAM so that a blind copy of rows up/down one position
        ; automatically fills the top/bottom screen row with spaces
        ldx # $3f
        lda # ' '
-       sta $0400 - $40, x
        sta $07e8, x
        dex
        bpl -

        ; load the article and populate
        ; the first screen-full of text
        jsr read_load

        ; turn screen on
        lda # %00011011
        sta VIC_SCREEN_CTL1

        ;-----------------------------------------------------------------------
        ; read keyboard
        ;
        ; wait for no-key (debounce)
@key    jsr Keyboard
        bcc @key
        ; wait for key
-       jsr Keyboard
        bcs -

        cmp # $20
        bne +
        inc VIC_BORDER
        jmp read_screen

+       cpy # %10000000
        bne +
        brk

+       cpx # %10000000
        bne +
        jsr read_scroll_up
        beq @key

+       jsr read_scroll_down
        beq @key

        jmp *

        ; tear down the custom interrupt handlers
        jsr disable_interrupts
        rts

;===============================================================================
; load the article:
;
; TODO: obviously this would happen at some other stage and use an IRQ-driven
;       fast-loader such as Krill's
;
read_filename:
        ;-----------------------------------------------------------------------
        !pet    "lorem-ipsum"

read_load:
        ;-----------------------------------------------------------------------
        sei                     ; disable interrupts

        ; turn on the KERNAL
        inc CPU_CONTROL

        ; get the last-used device number set by the KERNAL
        ldx $ba
        bne +                   ; not 0? good
        ldx # DEV_DRV8          ; default to drive 8
+       ldy # $00               ; use custom load address
        tya                     ; logical file number
        jsr KERNAL_SETLFS

        lda # 11                ; string-length
        ldx #< read_filename
        ldy #> read_filename
        jsr KERNAL_SETNAM

        lda # 0                 ; load, not verify
        ldx #< $1ffe
        ldy #> $1ffe
        jsr KERNAL_LOAD

        ; TODO: error handling, fastloader et al

        dec CPU_CONTROL         ; turn KERNAL off

        ; file-read, initialise printing:
        ;-----------------------------------------------------------------------
        ; the first two bytes are the size of the line-length array;
        ; in other words, how far forward to skip to find the text data.
        ; we set the address of the first line to print
        clc
        lda $1ffe
        adc #< $1ffe
        sta READ_CHAR_LO
        sta ZP_READ_TOP_LO
        lda $1fff
        adc #> $1fff
        sta READ_CHAR_HI
        sta ZP_READ_TOP_HI

        ; ergo, the line-length array begins two bytes in
        ; and this is our intial pointer in the array
        ; -- we begin printing at article line 1
        lda #< $2000
        sta ZP_READ_LENS_LO
        lda #> $2000
        sta ZP_READ_LENS_HI

        ; set the initial screen address
        ; (row 0, col 0)
        lda # 0
        sta ZP_READ_ROW
        ; set the output address in the printing
        ; routine based on this row+col
        lda screen_rows_lo
        sta READ_OUT_LO
        lda screen_rows_hi
        sta READ_OUT_HI

        ; print the article's first screen full of text
        ;-----------------------------------------------------------------------
        ; number of rows to print (1-based)
        lda # 25
        sta ZP_READ_ROWS

        jsr read_lines

        ; now that 25 rows have been printed, the routine will have left
        ; the details of the last row behind which we can make use of
        lda READ_CHAR_LO
        sta ZP_READ_BOT_LO
        lda READ_CHAR_HI
        sta ZP_READ_BOT_HI

        rts

;===============================================================================
; scroll the article up a line:
;
read_scroll_up:
        ; are we at the top of the article?
        ;-----------------------------------------------------------------------
        ; check the address of the current line in the line array;
        ; if this is $2000 then we are on the first line of the article
        ;
        lda ZP_READ_LENS_LO     ; the lo-byte of the address...
        bne +                   ; must be $00
        lda ZP_READ_LENS_HI     ; and the hi-byte
        cmp #> $2000            ; must be $00
        bne +
        ; we are at the top of the article
        sec                     ; set carry for error,
        rts                     ; and make like a tree
+
        ; copy the screen down a row -- the bytes before the screen characters
        ; are filled with spaces so as to automatically blank the first row!
        ; 
        ldy # $ff
-       lda $06d8, y
        sta $0700, y
        dey
        cpy # $ff
        bne -
-       lda $05d8, y
        sta $0600, y
        dey
        cpy # $ff
        bne -
-       lda $04d8, y
        sta $0500, y
        dey
        cpy # $ff
        bne -
-       lda $03d8, y
        sta $0400, y
        dey
        cpy # $ff
        bne -
        ; set Y to 0
        iny

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; set the screen address to print at
        sty ZP_READ_ROW
        lda #< $0400
        sta READ_OUT_LO
        lda #> $0400
        sta READ_OUT_HI

        ; move the index in the line-lengths array back one line
        sec
        lda ZP_READ_LENS_LO
        sbc # 1
        sta ZP_READ_LENS_LO
        bcs +
        dec ZP_READ_LENS_HI
        sec
+
        ; move the address of the line at the top
        ; of the screen backwards to the previous line
        ;
        lda ZP_READ_TOP_LO
        sbc (ZP_READ_LENS), y
        sta ZP_READ_TOP_LO
        sta READ_CHAR_LO        ; also set in the printing routine
        lda ZP_READ_TOP_HI
        sbc # 0                 ; ripple the subtract
        sta ZP_READ_TOP_HI
        sta READ_CHAR_HI

        ; number of rows to print
        iny                     ; (1-based)
        sty ZP_READ_ROWS

        ; repeat this for the line at the bottom of the screen
        ldy # 24
        lda ZP_READ_BOT_LO
        sbc (ZP_READ_LENS), y
        sta ZP_READ_BOT_LO
        bcs +
        dec ZP_READ_BOT_HI

+       jmp read_lines

;===============================================================================
; scroll the article down a line:
;
read_scroll_down:
        ; are we at the bottom of the article?
        ;-----------------------------------------------------------------------
        ldy # 24
        lda (ZP_READ_LENS), y   ; read length of line at bottom of screen
        cmp # $ff               ; if this is $FF then we've hit the bottom
        bne +                   ; more lines to go?
        sec                     ; set carry for error,
        rts                     ; and make like a tree

        ; copy the screen up a row -- the bytes after the screen characters
        ; are filled with spaces so as to automatically blank the last row!
        ; 
+       ldy # 0
-       lda $0428, y            ; row below...
        sta $0400, y            ; to row above
        iny
        bne -
-       lda $0528, y
        sta $0500, y
        iny
        bne -
-       lda $0628, y
        sta $0600, y
        iny
        bne -
-       lda $0728, y
        sta $0700, y
        iny
        bne -

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; read the length of the current line at the top of the screen,
        ; and move the line-pointer for the top screen line to the next line
        ; (note that Y is now zero due to loop above)
        ;
        clc
        lda (ZP_READ_LENS), y   ; length of line at top of screen
        adc ZP_READ_TOP_LO      ; add line-length to the line address
        sta ZP_READ_TOP_LO      ; (move to next line)
        bcc +
        inc ZP_READ_TOP_HI
        clc

        ; number of rows to print
+       iny                     ; (1-based)
        sty ZP_READ_ROWS

        ; set the screen address to print at
        ; (last row)
        ldy # 24                ; (bottom of screen)
        sty ZP_READ_ROW
        lda screen_rows_lo, y   ; address of last row of screen, lo-byte
        sta READ_OUT_LO
        lda screen_rows_hi, y   ; address of last row of screen, hi-byte
        sta READ_OUT_HI

        ; do the same but with the line-pointer for the bottom row of the
        ; screen, but also write the address into the print routine
        ;
        clc
        lda (ZP_READ_LENS), y   ; length of line at bottom of screen
        adc ZP_READ_BOT_LO      ; add line-length to the line address
        sta ZP_READ_BOT_LO      ; (move to next line)
        sta READ_CHAR_LO        ; set printing routine line-address (lo)
        lda ZP_READ_BOT_HI
        adc # 0                 ; ripple the add
        sta ZP_READ_BOT_HI
        sta READ_CHAR_HI        ; set printing routine line-address (hi)

        ; move to the next entry in the line-lengths array
        inc ZP_READ_LENS_LO
        bne +
        inc ZP_READ_LENS_HI
+

;===============================================================================
; print a number of lines from the article to the screen:
;
read_lines:
        ; prepare for printing
        ;-----------------------------------------------------------------------
        ; get the number of bytes for this line:
        ; begin with the on-screen row index
@lens   ldy ZP_READ_ROW
        lda (ZP_READ_LENS), y   ; get length of the line
        tay

        ; whilst we count Y down to zero, we keep a copy of the line-length
        ; to move the character pointer forward to the next line
        sty ZP_READ_LEN
        ; 0-length line is skipped,
        ; nothing to print
        beq @eol
        ; if this is $FF it's the indicator for the bottom of the article
        cpy # $ff
        beq @eof

.read_line:
        ;-----------------------------------------------------------------------
!addr   read_line       = .read_line

!addr   READ_CHAR       = @char+1
!addr   READ_CHAR_LO    = @char+1
!addr   READ_CHAR_HI    = @char+2

!addr   READ_OUT        = @out+1
!addr   READ_OUT_LO     = @out+1
!addr   READ_OUT_HI     = @out+2

        ; screen memory offset for the line
        ; (increases as each character is printed)
        ldx # 0

        ; read a byte from the binary string
@char   lda $8888, y
        
        ; print the character
@out    sta $0400, x
        inx
        dey
        bne @char

        ; end-of-line:
@eol    ; (note that Y is now zero due to line-bytes counting toward zero)
        tya
        ; reset screen address offset for the next line
        tax
        
        ; move to the next screen row
        inc ZP_READ_ROW
        ; all rows printed?
        dec ZP_READ_ROWS
        beq @eof

        ; look up the screen-address of the next row.
        ; faster than adding 40 to the existing address,
        ; since we don't need to read back the current value
        ldy ZP_READ_ROW
        lda screen_rows_lo, y
        sta READ_OUT_LO
        lda screen_rows_hi, y
        sta READ_OUT_HI

        ; move the data-pointer forward to the beginning of the next line,
        ; that is, add the length of the line (in bytes) to the pointer
        clc
        lda READ_CHAR_LO
        adc ZP_READ_LEN
        sta READ_CHAR_LO
        bcc @lens
        inc READ_CHAR_HI
        bne @lens

@eof    rts
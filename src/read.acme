; the screen used when reading articles

; theme colours
READ_BORDER             = GREY
READ_FORE               = DKGREY
READ_BACK               = GREY

; number of lines in the complete article
!addr   ZP_READ_LINES           = $10
!addr   ZP_READ_LINES_LO        = $10
!addr   ZP_READ_LINES_HI        = $11

; height of the complete article -- in pixels!
; this is used to determine the exact point to
; clip smooth scrolling when scrolling quickly
!addr   ZP_READ_VLEN            = $11
!addr   ZP_READ_VLEN_LO         = $11
!addr   ZP_READ_VLEN_HI         = $12

; exact scroll position -- in pixels!
!addr   ZP_READ_VPOS            = $13
!addr   ZP_READ_VPOS_LO         = $13
!addr   ZP_READ_VPOS_HI         = $14

; scroll accumulator, used for changing the speed
; of smooth scrolling; a signed byte
!addr   ZP_READ_SCROLL          = $15

; flag to indicate to stop allowing upward scrolling
; (prevents smooth scrolling at top of article)
!addr   ZP_READ_STOP_UP         = $16   ; $00 = go, $FF = stop
; flag to indicate to stop allowing downward scrolling
; (prevents smooth scrolling at bottom of article)
!addr   ZP_READ_STOP_DN         = $17   ; $00 = go, $FF = stop

; pointer into the line-length array
!addr   ZP_READ_LENS            = $18
!addr   ZP_READ_LENS_LO         = $18
!addr   ZP_READ_LENS_HI         = $19
; address of the line data that appears at the top of the screen
; (changes only when scrolling, not during printing)
!addr   ZP_READ_TOP             = $1a
!addr   ZP_READ_TOP_LO          = $1a
!addr   ZP_READ_TOP_HI          = $1b
; current row on screen being printed (0-24)
!addr   ZP_READ_ROW             = $1c
; current line length
!addr   ZP_READ_LEN             = $1d
; number of rows to print
!addr   ZP_READ_ROWS            = $1e
; address of the line that appears at the bottom of the screen
; (changes only when scrolling, not during printing)
!addr   ZP_READ_BOT             = $1f
!addr   ZP_READ_BOT_LO          = $1f
!addr   ZP_READ_BOT_HI          = $20

;===============================================================================
read_screen:
        ; setup the screen:
        ;-----------------------------------------------------------------------
        ; turn the screen off whilst we clear it
        lda # %00000000
        sta VIC_SCREEN_CTL1

        ; set screen colour
        lda # READ_BORDER
        sta VIC_BORDER
        lda # READ_BACK
        sta VIC_BACKGROUND

        ; erase the text-screen
        lda # READ_FORE
        sta ZP_COLOR
        jsr clear_screen

        ; for vertical scrolling, we place spaces before and after the
        ; screen RAM so that a blind copy of rows up/down one position
        ; automatically fills the top/bottom screen row with spaces
        ldx # $3f
        lda # ' '
-       sta $0400 - $40, x
        sta $07e8, x
        dex
        bpl -

        ; load the article and populate
        ; the first screen-full of text
        jsr read_load

        ; set our own interrupt handlers
        ; A = address of IRQ table, lo-byte
        ; X = address of IRQ table, hi-byte
        ; Y = number of entries in the table (1-based)
        ;
        lda #< read_irqs
        ldx #> read_irqs
        ldy # 2
        jsr irqs_load

        ; turn screen on
        ;     %---1---- = screen on
        ;     %----0--- = 24 rows
        ;     %-----111 = default vertical scroll offset
        lda # %00010111
        sta VIC_SCREEN_CTL1

        ; reset the smooth scrolling variables
        ldx # $00
        stx ZP_READ_SCROLL      ; scroll-speed = 0
        stx ZP_READ_STOP_DN     ; allow scrolling down; $00 = go, $FF = stop
        stx ZP_READ_VPOS_LO     ; set the exact pixel vertical position
        stx ZP_READ_VPOS_HI     ; within the article to zero
        ; we begin at the top of the article,
        ; so disallow scrolling upwards
        dex                     ; X = $FF
        stx ZP_READ_STOP_UP     ; $00 = go, $FF = stop

read_keyboard:
        ;-----------------------------------------------------------------------
        jsr Keyboard
        bcc @crsr

        ; when no keys are pressed, or the scroll keys
        ; are released, stop the smooth scrolling
        lda # $00
        sta ZP_READ_SCROLL
        ; no key code to process,
        ; go back to waiting
        bpl read_keyboard       ; (always branches)

        ; cursor up/down
        ;-----------------------------------------------------------------------
@crsr   cpx # %10000000
        bne @spc

        ; up, or down?
        tya
        and # %01010000         ; are either of the shift keys pressed?
        bne @up                 ; if yes, it's CRSR-UP

        ; crsr-dn
        ;-----------------------------------------------------------------------
        ; if at the bottom of the article,
        ; do not allow scrolling any further
        ;
@dn     lda ZP_READ_STOP_DN     ; check flag set when scroll hits the bottom
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content down the page:
        ; (smooth scroll upwards)
        ldx # $03               ; set scroll speed
        stx ZP_READ_SCROLL      ; this will be applied at interrupt
        ; whenever scrolling down,
        ; allow scrolling up again
        sta ZP_READ_STOP_UP     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

        ; crsr-up
        ;-----------------------------------------------------------------------
        ; if at the top of the article,
        ; do not allow scrolling any further
@up     lda ZP_READ_STOP_UP     ; check flag set when scroll hits the top
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content up the page
        ; (smooth scroll downwards)
        ldx # $fd               ; set -1 scroll speed
        stx ZP_READ_SCROLL      ; this will be applied at interrupt
        ; whenever scrolling up,
        ; allow scrolling down again
        sta ZP_READ_STOP_DN     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

@spc    cmp # $20
        bne @stop
        jmp read_screen

@stop   cpy # %10000000
        bne +
        brk

+       jmp read_keyboard

        ;-----------------------------------------------------------------------
        jmp *

        ; tear down the custom interrupt handlers
        jsr disable_interrupts
        rts

;===============================================================================
; table of interrupts to use for the reading screen:
;
read_irqs:
        ; when copying the screen up/down a row, the copy *must* occur before
        ; the raster-beam enters the visible portion of the screen otherwise
        ; flickering occurs. because the IRQ handler has a bunch of preliminary
        ; work to do before we get to scrolling, we can compensate for that
        ; time by moving the interrupt line back a little -- too far back,
        ; and the bottom of the screen will begin to flicker!
        ;
        +irqs_table_item read_irq_bottom,       SCANLINE_VBLANK_BEGIN - 2
        +irqs_table_item read_irq_top,          SCANLINE_VBLANK_END

read_irq_top:
        ;-----------------------------------------------------------------------
        rts

        lda ZP_READ_VPOS_HI
        pha                     ; put original value aside
        sed                     ; enable decimal mode

        lsr                     ; shift upper nybble down
        lsr                     ; ...
        lsr                     ; ...
        lsr                     ; ...
        cmp #9+1
        adc # $30               ; rebase to PETSCII '0' and above
        sta $0400+(10*40)+0

        pla                     ; retrieve original value
        and # $0f               ; extract lower nybble
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above
        sta $0400+(10*40)+1
        cld

        lda ZP_READ_VPOS_LO
        pha                     ; put original value aside
        sed

        lsr                     ; shift upper nybble down
        lsr                     ; ...
        lsr                     ; ...
        lsr                     ; ...
        cmp #9+1
        adc # $30               ; rebase to PETSCII '0' and above
        sta $0400+(10*40)+2

        pla                     ; retrieve original value
        and # $0f               ; extract lower nybble
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above
        sta $0400+(10*40)+3

        cld                     ; disable decimal mode

-       rts

read_irq_bottom:
        ;-----------------------------------------------------------------------
        ; is there any scrolling to be done?
        ;
        lda ZP_READ_SCROLL      ; read requested scroll speed
        beq -                   ; if scroll-speed = 0, then skip

        ; apply the scroll to our current
        ; vertical position within the article
        clc
        lda ZP_READ_VPOS_LO
        ; remember the article position *before* the move;
        ; we'll need to mask the bottom three bits later
        tay
        ; note that regardless of positive or negative scroll speed,
        ; adding will always produce the same result due to the
        ; wrap-around nature of negative numbers (e.g. -1 = +$FF)
        adc ZP_READ_SCROLL
        sta ZP_READ_VPOS_LO

        ; beyond one byte, we do have to take into
        ; account the postive / negative direction
        lda ZP_READ_VPOS_HI
        ; check the sign-bit of the scroll-speed
        bit ZP_READ_SCROLL
        bmi +
        ; for positive numbers,
        ; the carry can be applied
        adc # 0
       +bit_skip2
+       sbc # 0
        sta ZP_READ_VPOS_HI

        ; hit top/bottom of article?
        ;-----------------------------------------------------------------------
        ; have we gone above the top of the article?
        ; (pixel vertical position < $0000)
        ldx ZP_READ_VPOS_HI
        bpl +
        ; gone above the article; move back to the top
        stx ZP_READ_STOP_UP
        inx
        stx ZP_READ_VPOS_LO
        stx ZP_READ_VPOS_HI
        lda # %00010111
        sta VIC_SCREEN_CTL1
        rts
+
        ; soft/hard-scroll the screen:
        ;-----------------------------------------------------------------------
        ; retrieve the vertical scroll-offset 0-7
        lda ZP_READ_VPOS_LO
        and # %00000111
        eor # %00000111
        ; update the screen/scroll register:
        ;     %---1---- = screen on
        ;     %----0--- = 24 rows (for smooth scrolling)
        ;     %-----??? = vertical scroll offset
        ora # %00010000
        sta VIC_SCREEN_CTL1

        tya
        and # %00000111
        sta ZP_READ_ROW

        lda ZP_READ_VPOS_LO
        and # %00000111
        bit ZP_READ_SCROLL
        bpl +

        cmp ZP_READ_ROW
        bcc @end

        jmp read_scroll_up

+       cmp ZP_READ_ROW
        bcs @end

        jmp read_scroll_down

@end    rts

;===============================================================================
; load the article:
;
; TODO: obviously this would happen at some other stage and use an IRQ-driven
;       fast-loader such as Krill's
;
read_filename:
        ;-----------------------------------------------------------------------
        !pet    "lorem-ipsum"

read_load:
        ;-----------------------------------------------------------------------
        sei                     ; disable interrupts

        ; turn on the KERNAL
        inc CPU_CONTROL

        ; get the last-used device number set by the KERNAL
        ldx $ba
        bne +                   ; not 0? good
        ldx # DEV_DRV8          ; default to drive 8
+       ldy # $00               ; use custom load address
        tya                     ; logical file number
        jsr KERNAL_SETLFS

        lda # 11                ; string-length
        ldx #< read_filename
        ldy #> read_filename
        jsr KERNAL_SETNAM

        lda # 0                 ; load, not verify
        ldx #< $1ffe
        ldy #> $1ffe
        jsr KERNAL_LOAD

        ; TODO: error handling, fastloader et al

        dec CPU_CONTROL         ; turn KERNAL off

        ; file-read, initialise printing:
        ;-----------------------------------------------------------------------
        ; the first two bytes are the size of the line-length array;
        ; in other words, how many lines in the article there are,
        ; and how far forward to skip to find the text data.
        ; we set the address of the first line to print
        clc
        lda $1ffe
        adc #< $1ffe
        sta READ_CHAR_LO
        sta ZP_READ_TOP_LO
        lda $1fff
        adc #> $1fff
        sta READ_CHAR_HI
        sta ZP_READ_TOP_HI

        ; ergo, the line-length array begins two bytes in
        ; and this is our intial pointer in the array
        ; -- we begin printing at article line 1
        lda #< $2000
        sta ZP_READ_LENS_LO
        lda #> $2000
        sta ZP_READ_LENS_HI

        ; set the initial screen address
        ; (row 0, col 0)
        lda # 0
        sta ZP_READ_ROW
        ; set the output address in the printing
        ; routine based on this row+col
        lda screen_rows_lo
        sta READ_OUT_LO
        lda screen_rows_hi
        sta READ_OUT_HI

        ; print the article's first screen full of text
        ;-----------------------------------------------------------------------
        ; number of rows to print (1-based)
        lda # 25
        sta ZP_READ_ROWS

        jsr read_lines

        ; now that 25 rows have been printed, the routine will have left
        ; the details of the last row behind which we can make use of
        lda READ_CHAR_LO
        sta ZP_READ_BOT_LO
        lda READ_CHAR_HI
        sta ZP_READ_BOT_HI

        rts

;===============================================================================
; scroll the article up a line:
;
read_scroll_up:
        ; are we at the top of the article?
        ;-----------------------------------------------------------------------
        ; check the address of the current line in the line array;
        ; if this is $2000 then we are on the first line of the article
        ;
        lda ZP_READ_LENS_LO     ; the lo-byte of the address...
        bne +                   ; must be $00
        lda ZP_READ_LENS_HI     ; and the hi-byte
        cmp #> $2000            ; must be $00
        bne +
        ; we are at the top of the article:
        ; set the flag to stop smooth scrolling
;;        lda # $ff
;;        sta ZP_READ_STOP_UP
;;        sec                     ; set carry for error,
        rts                     ; and make like a tree
+
        ; copy the screen down a row
        ;-----------------------------------------------------------------------
        ; credit for this particular methodology must go to Richard Bayliss
        ; of The New Dimenson for producing a copy routine fast enough to
        ; copy the screen from the bottom up before the scanline gets
        ; past the vblank (which would cause flickering)
        ; <http://tnd64.unikat.sk/assemble_it6.html>
        ;
        ldy # $27               ; as always, loop backwards for speed

        ; due to the number of rows, the loop has to be split into two
        ; otherwise the relative branch cannot reach the top (>128 bytes)
-       lda $0400+(10 * 40), y
        sta read_scroll_temp, y
        lda $0400+( 9 * 40), y
        sta $0400+(10 * 40), y
        lda $0400+( 8 * 40), y
        sta $0400+( 9 * 40), y
        lda $0400+( 7 * 40), y
        sta $0400+( 8 * 40), y
        lda $0400+( 6 * 40), y
        sta $0400+( 7 * 40), y
        lda $0400+( 5 * 40), y
        sta $0400+( 6 * 40), y
        lda $0400+( 4 * 40), y
        sta $0400+( 5 * 40), y
        lda $0400+( 3 * 40), y
        sta $0400+( 4 * 40), y
        lda $0400+( 2 * 40), y
        sta $0400+( 3 * 40), y
        lda $0400+( 1 * 40), y
        sta $0400+( 2 * 40), y
        lda $0400+( 0 * 40), y
        sta $0400+( 1 * 40), y
        ; blank the top-row by copying in the spaces
        ; stored just before the screen ram
        lda $0400-( 1 * 40), y
        sta $0400+( 0 * 40), y
        dey
        bpl -
               
        ldy # $27
-       lda $0400+(23 * 40), y
        sta $0400+(24 * 40), y
        lda $0400+(22 * 40), y
        sta $0400+(23 * 40), y
        lda $0400+(21 * 40), y
        sta $0400+(22 * 40), y
        lda $0400+(20 * 40), y
        sta $0400+(21 * 40), y
        lda $0400+(19 * 40), y
        sta $0400+(20 * 40), y
        lda $0400+(18 * 40), y
        sta $0400+(19 * 40), y
        lda $0400+(17 * 40), y
        sta $0400+(18 * 40), y
        lda $0400+(16 * 40), y
        sta $0400+(17 * 40), y
        lda $0400+(15 * 40), y
        sta $0400+(16 * 40), y
        lda $0400+(14 * 40), y
        sta $0400+(15 * 40), y
        lda $0400+(13 * 40), y
        sta $0400+(14 * 40), y
        lda $0400+(12 * 40), y
        sta $0400+(13 * 40), y
        lda $0400+(11 * 40), y
        sta $0400+(12 * 40), y
        lda read_scroll_temp, y
        sta $0400+(11 * 40), y
        dey
        bpl -
        iny                     ; set Y to 0

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; set the screen address to print at
        sty ZP_READ_ROW
        lda #< $0400
        sta READ_OUT_LO
        lda #> $0400
        sta READ_OUT_HI

        ; move the index in the line-lengths array back one line
        sec
        lda ZP_READ_LENS_LO
        sbc # 1
        sta ZP_READ_LENS_LO
        bcs +
        dec ZP_READ_LENS_HI
        sec
+
        ; move the address of the line at the top
        ; of the screen backwards to the previous line
        ;
        lda ZP_READ_TOP_LO
        sbc (ZP_READ_LENS), y
        sta ZP_READ_TOP_LO
        sta READ_CHAR_LO        ; also set in the printing routine
        lda ZP_READ_TOP_HI
        sbc # 0                 ; ripple the subtract
        sta ZP_READ_TOP_HI
        sta READ_CHAR_HI

        ; number of rows to print
        iny                     ; (1-based)
        sty ZP_READ_ROWS

        ; repeat this for the line at the bottom of the screen
        ldy # 24
        lda ZP_READ_BOT_LO
        sbc (ZP_READ_LENS), y
        sta ZP_READ_BOT_LO
        bcs +
        dec ZP_READ_BOT_HI

+       jmp read_lines

read_scroll_temp:
        ;-----------------------------------------------------------------------
        !fill   $28, $00

;===============================================================================
; scroll the article down a line:
;
read_scroll_down:
        ; are we at the bottom of the article?
        ;-----------------------------------------------------------------------
        ldy # 24
        lda (ZP_READ_LENS), y   ; read length of line at bottom of screen
        cmp # $ff               ; if this is $FF then we've hit the bottom
        bne +                   ; more lines to go?

        ; we are at the bottom of the article:
        ; set the flag to stop smooth scrolling
;;        lda # $ff
;;        sta ZP_READ_STOP_DN
;;        sec                     ; set carry for error,
        rts                     ; and make like a tree

        ; copy the screen up a row -- the bytes after the screen characters
        ; are filled with spaces so as to automatically blank the last row!
        ; 
+       ldy # 0
-       lda $0428, y            ; row below...
        sta $0400, y            ; to row above
        iny
        bne -
-       lda $0528, y
        sta $0500, y
        iny
        bne -
-       lda $0628, y
        sta $0600, y
        iny
        bne -
-       lda $0728, y
        sta $0700, y
        iny
        bne -

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; read the length of the current line at the top of the screen,
        ; and move the line-pointer for the top screen line to the next line
        ; (note that Y is now zero due to loop above)
        ;
        clc
        lda (ZP_READ_LENS), y   ; length of line at top of screen
        adc ZP_READ_TOP_LO      ; add line-length to the line address
        sta ZP_READ_TOP_LO      ; (move to next line)
        bcc +
        inc ZP_READ_TOP_HI
        clc

        ; number of rows to print
+       iny                     ; (1-based)
        sty ZP_READ_ROWS

        ; set the screen address to print at
        ; (last row)
        ldy # 24                ; (bottom of screen)
        sty ZP_READ_ROW
        lda screen_rows_lo, y   ; address of last row of screen, lo-byte
        sta READ_OUT_LO
        lda screen_rows_hi, y   ; address of last row of screen, hi-byte
        sta READ_OUT_HI

        ; do the same but with the line-pointer for the bottom row of the
        ; screen, but also write the address into the print routine
        ;
        clc
        lda (ZP_READ_LENS), y   ; length of line at bottom of screen
        adc ZP_READ_BOT_LO      ; add line-length to the line address
        sta ZP_READ_BOT_LO      ; (move to next line)
        sta READ_CHAR_LO        ; set printing routine line-address (lo)
        lda ZP_READ_BOT_HI
        adc # 0                 ; ripple the add
        sta ZP_READ_BOT_HI
        sta READ_CHAR_HI        ; set printing routine line-address (hi)

        ; move to the next entry in the line-lengths array
        inc ZP_READ_LENS_LO
        bne +
        inc ZP_READ_LENS_HI
+

;===============================================================================
; print a number of lines from the article to the screen:
;
read_lines:
        ; prepare for printing
        ;-----------------------------------------------------------------------
        ; get the number of bytes for this line:
        ; begin with the on-screen row index
@lens   ldy ZP_READ_ROW
        lda (ZP_READ_LENS), y   ; get length of the line
        tay

        ; whilst we count Y down to zero, we keep a copy of the line-length
        ; to move the character pointer forward to the next line
        sty ZP_READ_LEN
        ; 0-length line is skipped,
        ; nothing to print
        beq @eol
        ; if this is $FF it's the indicator for the bottom of the article
        cpy # $ff
        beq @eof

.read_line:
        ;-----------------------------------------------------------------------
!addr   read_line       = .read_line

!addr   READ_CHAR       = @char+1
!addr   READ_CHAR_LO    = @char+1
!addr   READ_CHAR_HI    = @char+2

!addr   READ_OUT        = @out+1
!addr   READ_OUT_LO     = @out+1
!addr   READ_OUT_HI     = @out+2

        ; screen memory offset for the line
        ; (increases as each character is printed)
        ldx # 0

        ; read a byte from the binary string
@char   lda $8888, y
        
        ; print the character
@out    sta $0400, x
        inx
        dey
        bne @char

        ; end-of-line:
@eol    ; (note that Y is now zero due to line-bytes counting toward zero)
        tya
        ; reset screen address offset for the next line
        tax
        
        ; move to the next screen row
        inc ZP_READ_ROW
        ; all rows printed?
        dec ZP_READ_ROWS
        beq @eof

        ; look up the screen-address of the next row.
        ; faster than adding 40 to the existing address,
        ; since we don't need to read back the current value
        ldy ZP_READ_ROW
        lda screen_rows_lo, y
        sta READ_OUT_LO
        lda screen_rows_hi, y
        sta READ_OUT_HI

        ; move the data-pointer forward to the beginning of the next line,
        ; that is, add the length of the line (in bytes) to the pointer
        clc
        lda READ_CHAR_LO
        adc ZP_READ_LEN
        sta READ_CHAR_LO
        bcc @lens
        inc READ_CHAR_HI
        bne @lens

@eof    rts
; n√ºcomer magazine (c) copyright Kroc Camen 2019. unless otherwise noted,
; licenced under Creative Commons Attribution Non-Commercial Share-Alike 4.0
; licence; you may reuse and modify this code how you please as long as you:
;
; - retain the copyright notice
; - use the same licence for your derived code
; - do not use it for commercial purposes
;   (contact the author for a commercial licence)
;
; read.acme:
;===============================================================================
; the screen used when reading articles

; theme colours
READ_BORDER             = LTGREY
READ_FORE               = DKGREY
READ_BACK               = LTGREY

!addr {

; vertical scrolling register value to write at each vblank:
; this ensures that the change to the vertical smooth-scroll
; offset only ever occurs offscreen
ZP_READ_VERT            = $20

; number of lines in the complete article:
ZP_READ_LINES           = $21
ZP_READ_LINES_LO        = $21
ZP_READ_LINES_HI        = $22

; height of the complete article -- in pixels! this is used to determine the
; exact point to clip smooth scrolling when scrolling quickly. the high-bit
; is used to determine the top of the article, so in practice the article
; is limited to $7FFF (32'767) pixels high, equivalant to 4'095 lines,
; or 170 screens high!
;
ZP_READ_VLEN            = $23
ZP_READ_VLEN_LO         = $23
ZP_READ_VLEN_HI         = $24

; exact scroll position -- in pixels!
ZP_READ_VPOS            = $25
ZP_READ_VPOS_LO         = $25
ZP_READ_VPOS_HI         = $26

; scroll accumulator, used for changing the speed
; of smooth scrolling; a signed byte
ZP_READ_SCROLL          = $27

; flag to indicate to disallow upward scrolling
; (prevents smooth scrolling at top of article)
ZP_READ_STOP_UP         = $28   ; $00 = go, $FF = stop
; flag to indicate to disallow downward scrolling
; (prevents smooth scrolling at bottom of article)
ZP_READ_STOP_DN         = $29   ; $00 = go, $FF = stop

; pointer into the line-length array:
ZP_READ_LENS            = $2a
ZP_READ_LENS_LO         = $2a
ZP_READ_LENS_HI         = $2b
; address of the line data that appears at the top of the screen:
; (changes only when scrolling, not during printing)
ZP_READ_TOP             = $2c
ZP_READ_TOP_LO          = $2c
ZP_READ_TOP_HI          = $2d
; current row on screen being printed: (0-26)
ZP_READ_ROW             = $2e
; current line data-length, in bytes:
ZP_READ_LEN             = $2f
; number of rows to print: (1-based)
ZP_READ_ROWS            = $30
; address of the line that appears at the bottom of the screen:
; (changes only when scrolling, not during printing)
ZP_READ_BOT             = $31
ZP_READ_BOT_LO          = $31
ZP_READ_BOT_HI          = $32

; default printing colour for the line:
ZP_READ_COLOR_LINE      = $33
; current printing colour:
ZP_READ_COLOR           = $34

}
;===============================================================================
read_screen_rows:
;-------------------------------------------------------------------------------
; this is a lookup table of row-number to screen address, but the screen is
; 27 rows high, this means that when printing row '0', it will be off-screen
; and likewise with row '26'
;
read_screen_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <nu_screen_before
        !for    row, 0, 24 {
                !byte   <(nu_screen + (row * 40))
        }
        !byte   <nu_screen_after

read_screen_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >nu_screen_before
        !for    row, 0, 24 {
                !byte   >(nu_screen + (row * 40))
        }
        !byte   >nu_screen_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_screen_row0        = nu_screen_before      ; off-screen row
read_screen_row1        = nu_screen+( 0*40)
read_screen_row2        = nu_screen+( 1*40)
read_screen_row3        = nu_screen+( 2*40)
read_screen_row4        = nu_screen+( 3*40)
read_screen_row5        = nu_screen+( 4*40)
read_screen_row6        = nu_screen+( 5*40)
read_screen_row7        = nu_screen+( 6*40)
read_screen_row8        = nu_screen+( 7*40)
read_screen_row9        = nu_screen+( 8*40)
read_screen_row10       = nu_screen+( 9*40)
read_screen_row11       = nu_screen+(10*40)
read_screen_row12       = nu_screen+(11*40)
read_screen_row13       = nu_screen+(12*40)
read_screen_row14       = nu_screen+(13*40)
read_screen_row15       = nu_screen+(14*40)
read_screen_row16       = nu_screen+(15*40)
read_screen_row17       = nu_screen+(16*40)
read_screen_row18       = nu_screen+(17*40)
read_screen_row19       = nu_screen+(18*40)
read_screen_row20       = nu_screen+(19*40)
read_screen_row21       = nu_screen+(20*40)
read_screen_row22       = nu_screen+(21*40)
read_screen_row23       = nu_screen+(22*40)
read_screen_row24       = nu_screen+(23*40)
read_screen_row25       = nu_screen+(24*40)
read_screen_row26       = nu_screen_after       ; off-screen-row
}

read_colour_rows:
;-------------------------------------------------------------------------------
; and as before with screen RAM, a lookup table of colour-RAM addresses
; for each row, but accounting for our before & after rows (above)
;
read_colour_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <nu_colour_before
        !for    row, 0, 24 {
                !byte   <($d800 + (row * 40))
        }
        !byte   <nu_colour_after

read_colour_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >nu_colour_before
        !for    row, 0, 24 {
                !byte   >($d800 + (row * 40))
        }
        !byte   >nu_colour_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_colour_row0        = nu_colour_before
read_colour_row1        = $d800+( 0*40) ;=$D800
read_colour_row2        = $d800+( 1*40)
read_colour_row3        = $d800+( 2*40)
read_colour_row4        = $d800+( 3*40)
read_colour_row5        = $d800+( 4*40)
read_colour_row6        = $d800+( 5*40)
read_colour_row7        = $d800+( 6*40)
read_colour_row8        = $d800+( 7*40)
read_colour_row9        = $d800+( 8*40)
read_colour_row10       = $d800+( 9*40)
read_colour_row11       = $d800+(10*40)
read_colour_row12       = $d800+(11*40)
read_colour_row13       = $d800+(12*40)
read_colour_row14       = $d800+(13*40)
read_colour_row15       = $d800+(14*40)
read_colour_row16       = $d800+(15*40)
read_colour_row17       = $d800+(16*40)
read_colour_row18       = $d800+(17*40)
read_colour_row19       = $d800+(18*40)
read_colour_row20       = $d800+(19*40)
read_colour_row21       = $d800+(20*40)
read_colour_row22       = $d800+(21*40)
read_colour_row23       = $d800+(22*40)
read_colour_row24       = $d800+(23*40)
read_colour_row25       = $d800+(24*40)
read_colour_row26       = nu_colour_after
}

;===============================================================================
; TODO: put this into zero-page for a tiny bit of speed+size-gain?
read_styles:
read_styles_colour:
read_style0_colour:     !byte   READ_FORE
read_style1_colour:     !byte   BLACK
read_style2_colour:     !byte   WHITE
read_style3_colour:     !byte   WHITE
read_style4_colour:     !byte   WHITE
read_style5_colour:     !byte   WHITE
read_style6_colour:     !byte   WHITE
read_style7_colour:     !byte   WHITE

;===============================================================================
read_screen:
        ;-----------------------------------------------------------------------
        ; setup the screen:
        ; turn the screen off whilst we clear it
        lda # %00000000
        sta VIC_SCREEN_VERT

        ; set screen colour
        lda # READ_BORDER
        sta VIC_BORDER
        lda # READ_BACK
        sta VIC_BACKGROUND

        ; erase the text-screen
        lda # READ_FORE
        sta ZP_PRINT_COLOR
        jsr clear_screen

        ; whilst the lines before and after screen RAM will hold text
        ; waiting to be scrolled into view, we do need to fill these with
        ; spaces to begin with in case the first lines to be placed there
        ; do not fill 40-chars and we get screen garabge scrolling in
        ldx # 40-1
        lda # ' '
-       sta nu_screen_before, x
        sta nu_screen_after, x
        dex
        bpl -

        ; initialise printing:
        ;-----------------------------------------------------------------------
        ; the first two bytes are the size of the line-length array;
        ; in other words, how many lines in the article there are,
        ; and how far forward to skip to find the text data.
        ; we set the address of the first line to print
        clc
        lda nu_text-2
        adc #< (nu_text-2)
        sta READ_CHAR_LO
        sta ZP_READ_TOP_LO
        lda nu_text-1
        adc #> (nu_text-1)
        sta READ_CHAR_HI
        sta ZP_READ_TOP_HI

        ; ergo, the line-length array begins two bytes in
        ; and this is our intial pointer in the array
        ; -- we begin printing at article line 1
        lda #< nu_text
        sta ZP_READ_LENS_LO
        lda #> nu_text
        sta ZP_READ_LENS_HI

        ; for the smooth scrolling to not overshoot the bottom of the article,
        ; we need to calculate the height of the article in pixels; this is
        ; the number of lines multiplied by 8
        ;
        lda nu_text-2
        ; subtract 27 to account for where the top of the screen
        ; is when the bottom of the article is reached
        sec
        sbc # 27
        sta ZP_READ_VLEN_LO
        lda nu_text-1
        sbc # 0
        sta ZP_READ_VLEN_HI
        ; begin multiplying
        asl ZP_READ_VLEN_LO     ; x2
        rol ZP_READ_VLEN_HI     ; ...
        asl ZP_READ_VLEN_LO     ; x4
        rol ZP_READ_VLEN_HI     ; ...
        asl ZP_READ_VLEN_LO     ; x8
        rol ZP_READ_VLEN_HI     ; ...

        ; print the article's first screen full of text
        ;-----------------------------------------------------------------------
        ldy # 0                 ; begin on row 0 -- the off-screen row
        ldx # 27                ; number of rows to print (1-based)
        jsr read_lines

        ; now that 27 rows have been printed, the routine will have left
        ; the details of the last row behind which we can make use of
        lda READ_CHAR_LO
        sta ZP_READ_BOT_LO
        lda READ_CHAR_HI
        sta ZP_READ_BOT_HI

        ;-----------------------------------------------------------------------
        ; reset the smooth scrolling variables
        ldx # $00
        stx ZP_READ_VERT        ; set initial smooth-scroll offset
        stx ZP_READ_SCROLL      ; scroll-speed = 0
        stx ZP_READ_STOP_DN     ; allow scrolling down; $00 = go, $FF = stop
        stx ZP_READ_VPOS_LO     ; set the exact pixel vertical position
        stx ZP_READ_VPOS_HI     ; within the article to zero
        ; we begin at the top of the article,
        ; so disallow scrolling upwards
        dex                     ; X = $FF
        stx ZP_READ_STOP_UP     ; $00 = go, $FF = stop

        ; set our own interrupt handlers:
        lda #< read_irqs        ; A = address of IRQ table, lo-byte
        ldx #> read_irqs        ; X = address of IRQ table, hi-byte
        ldy # 2                 ; Y = number of entries in the table (1-based)
        jsr irqs_load

        ; note that the screen will automatically turn itself back on
        ; because the raster interrupt that handles smooth-scrolling
        ; always sets the screen control register every vblank

read_keyboard:
        ;-----------------------------------------------------------------------
        jsr Keyboard
        bcc @crsr

        ; when no keys are pressed, or the scroll keys
        ; are released, stop the smooth scrolling
        lda # $00
        sta ZP_READ_SCROLL
        ; no key code to process,
        ; go back to waiting
        bpl read_keyboard       ; (always branches)

        ; cursor up/down
        ;-----------------------------------------------------------------------
@crsr   cpx # %10000000
        bne @spc

        ; up, or down?
        tya
        and # %01010000         ; are either of the shift keys pressed?
        bne @up                 ; if yes, it's CRSR-UP

        ; crsr-dn
        ;-----------------------------------------------------------------------
        ; if at the bottom of the article,
        ; do not allow scrolling any further
        ;
@dn     lda ZP_READ_STOP_DN     ; check flag set when scroll hits the bottom
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content down the page:
        ; (smooth scroll upwards)
        ldx # $03               ; set scroll speed
        stx ZP_READ_SCROLL      ; this will be applied at interrupt
        ; whenever scrolling down,
        ; allow scrolling up again
        sta ZP_READ_STOP_UP     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

        ; crsr-up
        ;-----------------------------------------------------------------------
        ; if at the top of the article,
        ; do not allow scrolling any further
@up     lda ZP_READ_STOP_UP     ; check flag set when scroll hits the top
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content up the page
        ; (smooth scroll downwards)
        ldx # $fd               ; set -1 scroll speed
        stx ZP_READ_SCROLL      ; this will be applied at interrupt
        ; whenever scrolling up,
        ; allow scrolling down again
        sta ZP_READ_STOP_DN     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

@spc    cmp # $20
        bne @esc
        jmp read_screen

@esc    cmp # $1f               ; "<-" key
        beq @exit
        
@stop   cpy # %10000000
        bne +
        brk

+       jmp read_keyboard

        ;-----------------------------------------------------------------------
        jmp *

        ; TODO: transition out
@exit   jsr irqs_disable        ; tear down the custom interrupt handlers
        rts                     ; return to the menu

;===============================================================================
; table of interrupts to use for the reading screen:
;
read_irqs:
;-------------------------------------------------------------------------------
; hard scrolling the screen takes a lot of cycles and we must be ahead of the
; beam when we do this to avoid screen-tearing, therefore we begin scrolling
; the top of the screen whilst the beam is in the middle of the screen
;
READ_IRQ1 = SCANLINE_VBLANK_BEGIN - (14 * 8)

; just before the visible screen begins we set the vertical smooth-scrolling
; offset -- we cannot change the vertical scroll inside the screen or we will
; get tearing / glitching!
;
; hard scrolling the screen up or down takes a long time and even if we start
; before vblank, the process will overrun into the screen before it finishes,
; causing screen tear. therefore it is necessary for this interrupt to
; interrupt the previous one(!) whilst it is still shifting the screen,
; to ensure that the smooth scrolling register is not changed within
; the visible portion of the screen when hard-scrolling is occuring
;
READ_IRQ2 = SCANLINE_VBLANK_END - 8

read_irqs_addr_lo:
        !byte   <read_irq_scroll
        !byte   <read_irq_top
read_irqs_addr_hi:
        !byte   >read_irq_scroll
        !byte   >read_irq_top
read_irqs_scanline_lo:
        !byte   <READ_IRQ1
        !byte   <READ_IRQ2
read_irqs_scanline_hi:
        !byte   (>READ_IRQ1) << 7
        !byte   (>READ_IRQ2) << 7

read_irq_top:
        ;-----------------------------------------------------------------------
        ;;inc VIC_BORDER
        
        lda ZP_READ_VERT
        and # %00000111
        eor # %00000111
        ; update the screen/scroll register:
        ;     %---1---- = screen on
        ;     %----0--- = 24 rows (for smooth scrolling)
        ;     %-----??? = vertical scroll offset
        ora # %00010000
        sta VIC_SCREEN_VERT
        
;;        lda ZP_READ_VPOS_HI
;;        pha                     ; put original value aside
;;        sed                     ; enable decimal mode
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+0
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+1
;;        cld
;;
;;        lda ZP_READ_VPOS_LO
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+2
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+3
;;
;;        cld                     ; disable decimal mode
;;        lda ZP_READ_VLEN_HI
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+5
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+6
;;        cld                     ; disable decimal mode
;;        lda ZP_READ_VLEN_LO
;;        pha                     ; put original value aside
;;        sed
;;
;;        lsr                     ; shift upper nybble down
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        lsr                     ; ...
;;        cmp #9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+7
;;
;;        pla                     ; retrieve original value
;;        and # $0f               ; extract lower nybble
;;        cmp # 9+1
;;        adc # $30               ; rebase to PETSCII '0' and above
;;        sta nu_screen+(10*40)+8
;;

-       ;;dec VIC_BORDER
        rts

read_irq_scroll:
        ;-----------------------------------------------------------------------
        ;;inc VIC_BORDER

        ; is there any scrolling to be done?
        ;
        lda ZP_READ_SCROLL      ; read requested scroll speed
        beq -                   ; if scroll-speed = 0, then skip

        ; apply the scroll to our current
        ; vertical position within the article
        clc
        lda ZP_READ_VPOS_LO
        ; remember the article position *before* the move;
        ; we'll need to mask the bottom three bits later
        tay
        ; note that regardless of positive or negative scroll speed,
        ; adding will always produce the same result due to the
        ; wrap-around nature of negative numbers (e.g. -1 = +$FF)
        adc ZP_READ_SCROLL
        sta ZP_READ_VPOS_LO

        ; beyond one byte, we do have to take into
        ; account the postive / negative direction
        lda ZP_READ_VPOS_HI
        ; check the sign-bit of the scroll-speed
        bit ZP_READ_SCROLL
        bmi +
        ; for positive numbers,
        ; the carry can be applied
        adc # 0
       +bit_skip2
        ; for negative numbers,
        ; the carry becomes a borrow
+       sbc # 0
        sta ZP_READ_VPOS_HI

        ; hit top/bottom of article?
        ;-----------------------------------------------------------------------
        ; have we gone above the top of the article?
        ; (pixel vertical position < $0000)
        ldx ZP_READ_VPOS_HI
        bpl +
        ; gone above the article; move back to the top
        stx ZP_READ_STOP_UP     ; X = $FF, disable scrolling upwards
        inx                     ; X = $00
        stx ZP_READ_VPOS_LO     ; set scroll position within article
        stx ZP_READ_VPOS_HI     ; to $0000
        stx ZP_READ_VERT        ; reset vertical smooth-scroll register

@done:  ;;dec VIC_BORDER
        rts

        ; check the end of the article:
        ; (X = ZP_READ_VPOS_HI)
+       ldx ZP_READ_VLEN_HI
        cpx ZP_READ_VPOS_HI
        beq +                   ; hi-bytes equal, compare lo-bytes
        bcs @scroll             ; scroll position < height, scroll ahead
        bcc @stop               ; scroll position > height, go back!
        ; check the low-bytes
+       ldx ZP_READ_VLEN_LO
        cpx ZP_READ_VPOS_LO
        bcs @scroll
        
        ; gone below the article!
        ; move back to the end
@stop   ldx # $ff               ; set the flag to disallow
        stx ZP_READ_STOP_DN     ; scrolling down ($FF = stop, $00 = go)
        inx                     ; X = $00
        sta ZP_READ_SCROLL      ; set scroll speed to zero
        ldx ZP_READ_VLEN_LO     ; change the moved-to position back a bit
        stx ZP_READ_VPOS_LO     ; to the exact bottom of the article
        lda ZP_READ_VLEN_HI
        sta ZP_READ_VPOS_HI
        
        ; soft/hard-scroll the screen:
        ;-----------------------------------------------------------------------
        ; soft-scroll:
@scroll lda ZP_READ_VPOS_LO     ; retrieve the article scroll position
        sta ZP_READ_VERT        ; set the smooth-scrolling register at vblank

        ; do we need to hard-scroll?
        tya                     ; article scroll position *before* scroll
        and # %00000111
        sta ZP_READ_ROW         ; (temporary use)

        lda ZP_READ_VPOS_LO     ; article scroll position *after* scroll
        and # %00000111
        bit ZP_READ_SCROLL
        bpl +

        cmp ZP_READ_ROW         ; (temporary use)
        bcc @done

        jmp read_scroll_up

+       cmp ZP_READ_ROW         ; (temporary use)
        bcs @done

;===============================================================================
; scroll the article down a line:
;
read_scroll_down:
        ;-----------------------------------------------------------------------
        ; copy the screen up a row -- due to the number of rows, the loop has
        ; to be split into three otherwise the relative branches cannot reach
        ; the top (>128 bytes) but we do want to get as close to that limit as
        ; possible (about 41 load + stores) as this minimizes the number of
        ; cycles wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
-       ; row 1 -> row 0
        lda read_screen_row1, y ; the top line moves into the off-screen
        sta read_screen_row0, y ; buffer ready for if the user scrolls up
        lda read_colour_row1, y ; (=$D800)
        sta read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        ; row 2 -> row 1
        lda read_screen_row2, y
        sta read_screen_row1, y
        lda read_colour_row2, y
        sta read_colour_row1, y
        ; row 3 -> row 2
        lda read_screen_row3, y
        sta read_screen_row2, y
        lda read_colour_row3, y
        sta read_colour_row2, y
        ; row 4 -> row 3
        lda read_screen_row4, y
        sta read_screen_row3, y
        lda read_colour_row4, y
        sta read_colour_row3, y
        ; row 5 -> row 4
        lda read_screen_row5, y
        sta read_screen_row4, y
        lda read_colour_row5, y
        sta read_colour_row4, y
        ; row 6 -> row 5
        lda read_screen_row6, y
        sta read_screen_row5, y
        lda read_colour_row6, y
        sta read_colour_row5, y
        ; row 7 -> row 6
        lda read_screen_row7, y
        sta read_screen_row6, y
        lda read_colour_row7, y
        sta read_colour_row6, y
        ; row 8 -> row 7
        lda read_screen_row8, y
        sta read_screen_row7, y
        lda read_colour_row8, y
        sta read_colour_row7, y
        ; row 9 -> row 8
        lda read_screen_row9, y
        sta read_screen_row8, y
        lda read_colour_row9, y
        sta read_colour_row8, y
        ; row 10 -> row 9
        lda read_screen_row10, y
        sta read_screen_row9, y
        lda read_colour_row10, y
        sta read_colour_row9, y
        dey
        bpl -

        ldy # 39
        ; row 11 -> row 10
-       lda read_screen_row11, y
        sta read_screen_row10, y
        lda read_colour_row11, y
        sta read_colour_row10, y
        ; row 12 -> row 11
        lda read_screen_row12, y
        sta read_screen_row11, y
        lda read_colour_row12, y
        sta read_colour_row11, y
        ; row 13 -> row 12
        lda read_screen_row13, y
        sta read_screen_row12, y
        lda read_colour_row13, y
        sta read_colour_row12, y
        ; row 14 -> row 13
        lda read_screen_row14, y
        sta read_screen_row13, y
        lda read_colour_row14, y
        sta read_colour_row13, y
        ; row 15 -> row 14
        lda read_screen_row15, y
        sta read_screen_row14, y
        lda read_colour_row15, y
        sta read_colour_row14, y
        ; row 16 -> row 15
        lda read_screen_row16, y
        sta read_screen_row15, y
        lda read_colour_row16, y
        sta read_colour_row15, y
        ; row 17 -> row 16
        lda read_screen_row17, y
        sta read_screen_row16, y
        lda read_colour_row17, y
        sta read_colour_row16, y
        ; row 18 -> row 17
        lda read_screen_row18, y
        sta read_screen_row17, y
        lda read_colour_row18, y
        sta read_colour_row17, y
        ; row 19 -> row 18
        lda read_screen_row19, y
        sta read_screen_row18, y
        lda read_colour_row19, y
        sta read_colour_row18, y
        ; row 20 -> row 19
        lda read_screen_row20, y
        sta read_screen_row19, y
        lda read_colour_row20, y
        sta read_colour_row19, y
        dey
        bpl -

        ldy # 40
        ; row 21 -> row 20
-       lda read_screen_row21-1, y
        sta read_screen_row20-1, y
        lda read_colour_row21-1, y
        sta read_colour_row20-1, y
        ; row 22 -> row 21
        lda read_screen_row22-1, y
        sta read_screen_row21-1, y
        lda read_colour_row22-1, y
        sta read_colour_row21-1, y
        ; row 23 -> row 22
        lda read_screen_row23-1, y
        sta read_screen_row22-1, y
        lda read_colour_row23-1, y
        sta read_colour_row22-1, y
        ; row 24 -> row 23
        lda read_screen_row24-1, y
        sta read_screen_row23-1, y
        lda read_colour_row24-1, y
        sta read_colour_row23-1, y
        ; row 25 -> row 24
        lda read_screen_row25-1, y
        sta read_screen_row24-1, y
        lda read_colour_row25-1, y
        sta read_colour_row24-1, y
        ; row 26 -> row 25
        ; copy the off-screen line into view
        lda read_screen_row26-1, y
        sta read_screen_row25-1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row26-1, y
        sta read_colour_row25-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ;;dec VIC_BORDER

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; blank the off-screen row so that we don't scroll in garbage
        ; if the new line is shorter than the previous line
        ldx # 40
        lda # ' '
-       sta nu_screen_after-1, x
        dex
        bne -                   ; stop when X = 0 (important for later!)

        ; read the length of the current line at the top of the screen,
        ; and move the line-pointer for the top screen line to the next line
        ;
        clc                     ; (note that Y = 0)
        lda (ZP_READ_LENS), y   ; length of line above screen
        and # %00111111         ; (top two bits are flags)
        adc ZP_READ_TOP_LO      ; add line-length to the line address
        sta ZP_READ_TOP_LO      ; (move to next line)
        bcc +
        inc ZP_READ_TOP_HI
        clc

        ; do the same but with the line-pointer for the bottom row of the
        ; screen, but also write the address into the print routine
        ;
+       ldy # 26                ; row to begin printing at (below screen)
        lda (ZP_READ_LENS), y   ; length of line at bottom of screen
        and # %00111111         ; (top two bits are flags)
        adc ZP_READ_BOT_LO      ; add line-length to the line address
        sta ZP_READ_BOT_LO      ; (move to next line)
        sta READ_CHAR_LO        ; set printing routine line-address (lo)
        lda ZP_READ_BOT_HI
        adc # 0                 ; ripple the add
        sta ZP_READ_BOT_HI
        sta READ_CHAR_HI        ; set printing routine line-address (hi)

        ; move to the next entry in the line-lengths array
        inc ZP_READ_LENS_LO
        bne +
        inc ZP_READ_LENS_HI

+       inx                     ; X = 1; number of lines to print
        jmp read_lines          ; note that Y = 26, row to print from

;===============================================================================
; scroll the article up a line:
;
read_scroll_up:
        ;-----------------------------------------------------------------------
        ; copy the screen down a row:
        ;
        ; credit for this particular methodology must go to Richard Bayliss
        ; of The New Dimenson for producing a copy routine fast enough to
        ; copy the screen bottom-up before the scanline catches up
        ; <http://tnd64.unikat.sk/assemble_it6.html>
        ;
        ; due to the number of rows, the loop has to be split into three
        ; otherwise the relative branches cannot reach the top (>128 bytes)
        ; but we do want to get close to that limit as possible (about
        ; 41 load + stores) as this minimizes the amount of cycles
        ; wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
        ; row 9 -> row ...
-       lda read_screen_row9, y
        sta nu_screen_temp, y
        lda read_colour_row9, y
        sta nu_colour_temp, y
        ; row 8 -> row 9
        lda read_screen_row8, y
        sta read_screen_row9, y
        lda read_colour_row8, y
        sta read_colour_row9, y
        ; row 7 -> row 8
        lda read_screen_row7, y
        sta read_screen_row8, y
        lda read_colour_row7, y
        sta read_colour_row8, y
        ; row 6 -> row 7
        lda read_screen_row6, y
        sta read_screen_row7, y
        lda read_colour_row6, y
        sta read_colour_row7, y
        ; row 5 -> row 6
        lda read_screen_row5, y
        sta read_screen_row6, y
        lda read_colour_row5, y
        sta read_colour_row6, y
        ; row 4 -> row 5
        lda read_screen_row4, y
        sta read_screen_row5, y
        lda read_colour_row4, y
        sta read_colour_row5, y
        ; row 3 -> row 4
        lda read_screen_row3, y
        sta read_screen_row4, y
        lda read_colour_row3, y
        sta read_colour_row4, y
        ; row 2 -> row 3
        lda read_screen_row2, y
        sta read_screen_row3, y
        lda read_colour_row2, y
        sta read_colour_row3, y
        ; row 1 -> row 2
        lda read_screen_row1, y
        sta read_screen_row2, y
        lda read_colour_row1, y
        sta read_colour_row2, y
        ; row 0 -> row 1
        ; (copy the off-screen line into view)
        lda read_screen_row0, y
        sta read_screen_row1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $D800-40 when I/O is on!
        lda read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        sta read_colour_row1, y ; (=$D800)
        dey
        bpl -

        ldy # 39
        ; row 18 -> row ...
        ; (we use the off-screen row above temporarily as it is "garbage" at
        ;  this point until after the screen copy when it will be populated)
-       lda read_screen_row18, y
        sta read_screen_row0, y
        lda read_colour_row18, y
        sta read_colour_row0, y
        ; row 17 -> row 18
        lda read_screen_row17, y
        sta read_screen_row18, y
        lda read_colour_row17, y
        sta read_colour_row18, y
        ; row 16 -> row 17
        lda read_screen_row16, y
        sta read_screen_row17, y
        lda read_colour_row16, y
        sta read_colour_row17, y
        ; row 15 -> row 16
        lda read_screen_row15, y
        sta read_screen_row16, y
        lda read_colour_row15, y
        sta read_colour_row16, y
        ; row 14 -> row 15
        lda read_screen_row14, y
        sta read_screen_row15, y
        lda read_colour_row14, y
        sta read_colour_row15, y
        ; row 13 -> row 14
        lda read_screen_row13, y
        sta read_screen_row14, y
        lda read_colour_row13, y
        sta read_colour_row14, y
        ; row 12 -> row 13
        lda read_screen_row12, y
        sta read_screen_row13, y
        lda read_colour_row12, y
        sta read_colour_row13, y
        ; row 11 -> row 12
        lda read_screen_row11, y
        sta read_screen_row12, y
        lda read_colour_row11, y
        sta read_colour_row12, y
        ; row 10 -> row 11
        lda read_screen_row10, y
        sta read_screen_row11, y
        lda read_colour_row10, y
        sta read_colour_row11, y
        ; row ... -> row 10
        lda nu_screen_temp, y
        sta read_screen_row10, y
        lda nu_colour_temp, y
        sta read_colour_row10, y
        dey
        bpl -

        ldy # 40
        ; row 25 -> row 26
        ; the bottom line moves into the off-screen
        ; buffer ready for if the user scrolls down
-       lda read_screen_row25-1, y
        sta read_screen_row26-1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row25-1, y
        sta read_colour_row26-1, y
        ; row 24 -> row 25
        lda read_screen_row24-1, y
        sta read_screen_row25-1, y
        lda read_colour_row24-1, y
        sta read_colour_row25-1, y
        ; row 23 -> row 24
        lda read_screen_row23-1, y
        sta read_screen_row24-1, y
        lda read_colour_row23-1, y
        sta read_colour_row24-1, y
        ; row 22 -> row 23
        lda read_screen_row22-1, y
        sta read_screen_row23-1, y
        lda read_colour_row22-1, y
        sta read_colour_row23-1, y
        ; row 21 -> row 22
        lda read_screen_row21-1, y
        sta read_screen_row22-1, y
        lda read_colour_row21-1, y
        sta read_colour_row22-1, y
        ; row 20 -> row 21
        lda read_screen_row20-1, y
        sta read_screen_row21-1, y
        lda read_colour_row20-1, y
        sta read_colour_row21-1, y
        ; row 19 -> row 20
        lda read_screen_row19-1, y
        sta read_screen_row20-1, y
        lda read_colour_row19-1, y
        sta read_colour_row20-1, y
        ; row ... -> row 19
        lda read_screen_row0-1, y
        sta read_screen_row19-1, y
        lda read_colour_row0-1, y
        sta read_colour_row19-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ;;dec VIC_BORDER

        ; print the next row in the off-screen space
        ;-----------------------------------------------------------------------
        ldx # 40
        lda # ' '
-       sta nu_screen_before-1, x
        dex
        bne -                   ; stop when X = 0 (important for later!)

        sec
        lda ZP_READ_LENS_LO     ; move the index in the line-lengths array...
        sbc # 1                 ; ...back one line
        sta ZP_READ_LENS_LO
        bcs +
        dec ZP_READ_LENS_HI
        sec

        ; move the address of the line above the screen
        ; backwards to the previous line address
        ;
        ; TODO: anyway to do this subtraction faster? (EOR-1?)
        ;       the need to mask the top bits prevents us
        ;       from using `sbc (ZP_READ_LENS), y`
        ;
+       lda (ZP_READ_LENS), y
        and # %00111111         ; (top two bits are flags)
        sta ZP_READ_ROW         ; (temporary use)

        lda ZP_READ_TOP_LO
        sbc ZP_READ_ROW         ; (length of line-data, in bytes)
        sta ZP_READ_TOP_LO
        sta READ_CHAR_LO        ; also set in the printing routine
        lda ZP_READ_TOP_HI
        sbc # 0                 ; ripple the subtract
        sta ZP_READ_TOP_HI
        sta READ_CHAR_HI        ; also set in the printing routine

        ; repeat this for the off-screen
        ; line after the screen RAM
        ;
        ; TODO: anyway to do this subtraction faster? (EOR-1?)
        ;       the need to mask the top bits prevents us
        ;       from using `sbc (ZP_READ_LENS), y`
        ;
        ldy # 26
        lda (ZP_READ_LENS), y   ; length of line-data, in bytes
        and # %00111111         ; (top two bits are flags)
        sta ZP_READ_ROW         ; (temporary use)

        lda ZP_READ_BOT_LO
        sbc ZP_READ_ROW         ; (length of line-data, in bytes)
        sta ZP_READ_BOT_LO
        bcs +
        dec ZP_READ_BOT_HI

+       ldy # 0                 ; starting row
        inx                     ; X = 1; number of rows to print

;===============================================================================
; print a number of lines from the article to the screen:
;
;       Y = row to begin printing
;       X = number of lines to print (1-based)
;       
read_lines:
        ;-----------------------------------------------------------------------
        ; prepare for printing:
        ;
        stx ZP_READ_ROWS        ; number of lines to print (1-based)
        sty ZP_READ_ROW         ; current row being printed

        ; print a line:
        ;-----------------------------------------------------------------------
@line:  lda read_style0_colour
        sta ZP_READ_COLOR_LINE  ; set the default colour for the line
        sta ZP_READ_COLOR       ; and the 'current' colour accordingly

        ldy ZP_READ_ROW         ; current row...
        ; set the screen address from the row number
        lda read_screen_rows_lo, y
        sta @out+1
        lda read_screen_rows_hi, y
        sta @out+2
        ; get the number of bytes for this line
        lda (ZP_READ_LENS), y

        ; most lines of text will not require colour data, resorting to the
        ; 'default' style. if we included a byte for every line to indicate
        ; if it had colour-data or not, this would waste a lot of bytes very
        ; quickly; 500 extra bytes for 500 lines is a lot of wasted bytes!
        ; 
        ; instead, the upper-bit of the line-length is used to indicate the
        ; presence of colour-data in the line-data. the compare instruction
        ; that follows will check the high-bit of the line-length; if 0,
        ; carry is set; if 1, carry is clear. we use this as our indicator
        ; if colour-data should be read and processed from the line-data
        ;
        cmp # %10000000         ; check for high-bit on line-length
        beq @eof                ; terminator mark, article ends
        bcs +                   ; 

        ; colour the line with default colour
        ; TODO: so very messy
        tay
        lda ZP_READ_COLOR_LINE
        jsr read_colour_row
        tya
        clc

+       and # %00111111         ; (strip flags from line length)
        tay                     ; Y = length of line-data (in bytes)

        ; whilst we count Y down to zero, we keep a copy of the line-length
        ; to move the character pointer forward to the next line
        sty ZP_READ_LEN
        ; 0-length line is skipped,
        ; nothing to print
        beq @eol

        ;-----------------------------------------------------------------------
!addr   READ_CHAR       = @char+1
!addr   READ_CHAR_LO    = @char+1
!addr   READ_CHAR_HI    = @char+2

        ; screen memory offset for the line
        ; (increases as each character is printed)
@print  ldx # 0

@char   lda $8888, y            ; read a byte from the binary string
        bcs @cdata              ; is colour-data is being decoded?
@out    sta nu_screen, x        ; print the character
        inx                     ; move to next column on screen
        dey                     ; move to next data-byte
        bne @char               ; keep printing whilst data remains

        ; end-of-line:
        ;-----------------------------------------------------------------------
@eol:   dec ZP_READ_ROWS        ; all rows printed?
        beq @eof                ; yes -- stop printing

        inc ZP_READ_ROW         ; move to the next screen row

        ; move the data-pointer forward to the beginning of the next line,
        ; that is, add the length of the line (in bytes) to the pointer
        clc
        lda @char+1
        adc ZP_READ_LEN
        sta @char+1
        bcc @line
        inc @char+2
        bne @line

        brk

@eof:   rts

        ; decode colour-data:
        ;=======================================================================
        ; note that we must return carry set if we
        ; want to continue processing colour data
        ;
        ;       A = colour-data byte
        ;       Y = data-byte index (counts-down)
        ;
        ; note that the compare-Y will change carry:
        ; - first data byte = carry set
        ; - other data byte = carry clear
        ;
@cdata: cpy ZP_READ_LEN         ; is this the first data-byte?
        beq @first              ; yes, process differently

        dey
        clc
        bne @print

@first: ;;bpl @more
        
        ; colour whole row:
        ;-----------------------------------------------------------------------
        and # %00000111         ; which style class
        tax                     ; (we know this is the first byte, so reuse X)
        ; get the colour for the given style class
        lda read_styles_colour, x
        
        jsr read_colour_row
        
        dey                     ; move to the next line-data byte
        clc                     ; mark colour-data as finished
        ; begin printing text and set X
        ; (screen column) back to zero
        bne @print              ; (always branches, Y != 0)

;===============================================================================
; colour a whole row:
;
;       A = colour
;       (Y is preserved)
;
read_colour_row:
        ;-----------------------------------------------------------------------
        pha                     ; put aside colour for now

        ; which row are we on?
        ; (there are speed-paths for the offscreen rows)
        ldx ZP_READ_ROW
        beq @before             ; row = 0, colour offscreen row above screen
        cpx # 26                ; row = 26?
        beq @after              ; row = 26, colour offscreen row below screen

        ; rows 1-25: use the general slow path:
        ;-----------------------------------------------------------------------
        ; look up the address to write to
        lda read_colour_rows_lo, x
        sta @color+1
        lda read_colour_rows_hi, x
        sta @color+2

        pla                     ; retrieve colour for the given style class
        ldx # 40-1
@color  sta $d800, x
        dex
        bpl @color

        rts

        ; colour offscreen row before screen:
        ;-----------------------------------------------------------------------
@before pla                     ; retrieve the colour for the given style class
        
        ; fast-fill the row colour:
        ; (X offset = start of row)
        ; (JSR offset = colour 40 chars)
        ldx # 0
        jmp read_set_colour_before+0

        ; colour offscreen row after screen:
        ;-----------------------------------------------------------------------
@after  pla                     ; retrieve the colour for the given style class

        ; fast-fill the row colour:
        ; (X offset = start of row)
        ; (JSR offset = colour 40 chars)
        ldx # 0
        jmp read_set_colour_after+0

;===============================================================================
; set the colour for some, or all, of the off-screen top row:
;
; this is a "fast path" to set a colour on the characters of the off-screen
; row above the screen; the idea is to jump into the routine at the point
; where the number of characters you want to colour remain; X can be used
; to offset from the first column
;
;       A = colour
;       X = character offset
;
read_set_colour_before:
        ;-----------------------------------------------------------------------
        sta nu_colour_before+0,  x      ; jsr +   0: colour 40 chars
        sta nu_colour_before+1,  x      ; jsr +   3: colour 39 chars
        sta nu_colour_before+2,  x      ; jsr +   6: colour 38 chars
        sta nu_colour_before+3,  x      ; jsr +   9: colour 37 chars
        sta nu_colour_before+4,  x      ; jsr +  12: colour 36 chars
        sta nu_colour_before+5,  x      ; jsr +  15: colour 35 chars
        sta nu_colour_before+6,  x      ; jsr +  18: colour 34 chars
        sta nu_colour_before+7,  x      ; jsr +  21: colour 33 chars
        sta nu_colour_before+8,  x      ; jsr +  24: colour 32 chars
        sta nu_colour_before+9,  x      ; jsr +  27: colour 31 chars
        sta nu_colour_before+10, x      ; jsr +  30: colour 30 chars
        sta nu_colour_before+11, x      ; jsr +  33: colour 29 chars
        sta nu_colour_before+12, x      ; jsr +  36: colour 28 chars
        sta nu_colour_before+13, x      ; jsr +  39: colour 27 chars
        sta nu_colour_before+14, x      ; jsr +  42: colour 26 chars
        sta nu_colour_before+15, x      ; jsr +  45: colour 25 chars
        sta nu_colour_before+16, x      ; jsr +  48: colour 24 chars
        sta nu_colour_before+17, x      ; jsr +  51: colour 23 chars
        sta nu_colour_before+18, x      ; jsr +  54: colour 22 chars
        sta nu_colour_before+19, x      ; jsr +  57: colour 21 chars
        sta nu_colour_before+20, x      ; jsr +  60: colour 20 chars
        sta nu_colour_before+21, x      ; jsr +  63: colour 19 chars
        sta nu_colour_before+22, x      ; jsr +  66: colour 18 chars
        sta nu_colour_before+23, x      ; jsr +  69: colour 17 chars
        sta nu_colour_before+24, x      ; jsr +  72: colour 16 chars
        sta nu_colour_before+25, x      ; jsr +  75: colour 15 chars
        sta nu_colour_before+26, x      ; jsr +  78: colour 14 chars
        sta nu_colour_before+27, x      ; jsr +  81: colour 13 chars
        sta nu_colour_before+28, x      ; jsr +  84: colour 12 chars
        sta nu_colour_before+29, x      ; jsr +  87: colour 11 chars
        sta nu_colour_before+30, x      ; jsr +  90: colour 10 chars
        sta nu_colour_before+31, x      ; jsr +  93: colour 9 chars
        sta nu_colour_before+32, x      ; jsr +  96: colour 8 chars
        sta nu_colour_before+33, x      ; jsr +  99: colour 7 chars
        sta nu_colour_before+34, x      ; jsr + 102: colour 6 chars
        sta nu_colour_before+35, x      ; jsr + 105: colour 5 chars
        sta nu_colour_before+36, x      ; jsr + 108: colour 4 chars
        sta nu_colour_before+37, x      ; jsr + 111: colour 3 chars
        sta nu_colour_before+38, x      ; jsr + 114: colour 2 chars
        sta nu_colour_before+39, x      ; jsr + 117: colour 1 char
        
        rts

;===============================================================================
; set the colour for some, or all, of the off-screen bottom row:
;
; this is a "fast path" to set a colour on the characters of the off-screen
; row below the screen; the idea is to jump into the routine at the point
; where the number of characters you want to colour remain; X can be used
; to offset from the first column
;
;       A = colour
;       X = character offset
;
read_set_colour_after:
        ;-----------------------------------------------------------------------
        sta nu_colour_after+0,  x       ; jsr +   0: colour 40 chars
        sta nu_colour_after+1,  x       ; jsr +   3: colour 39 chars
        sta nu_colour_after+2,  x       ; jsr +   6: colour 38 chars
        sta nu_colour_after+3,  x       ; jsr +   9: colour 37 chars
        sta nu_colour_after+4,  x       ; jsr +  12: colour 36 chars
        sta nu_colour_after+5,  x       ; jsr +  15: colour 35 chars
        sta nu_colour_after+6,  x       ; jsr +  18: colour 34 chars
        sta nu_colour_after+7,  x       ; jsr +  21: colour 33 chars
        sta nu_colour_after+8,  x       ; jsr +  24: colour 32 chars
        sta nu_colour_after+9,  x       ; jsr +  27: colour 31 chars
        sta nu_colour_after+10, x       ; jsr +  30: colour 30 chars
        sta nu_colour_after+11, x       ; jsr +  33: colour 29 chars
        sta nu_colour_after+12, x       ; jsr +  36: colour 28 chars
        sta nu_colour_after+13, x       ; jsr +  39: colour 27 chars
        sta nu_colour_after+14, x       ; jsr +  42: colour 26 chars
        sta nu_colour_after+15, x       ; jsr +  45: colour 25 chars
        sta nu_colour_after+16, x       ; jsr +  48: colour 24 chars
        sta nu_colour_after+17, x       ; jsr +  51: colour 23 chars
        sta nu_colour_after+18, x       ; jsr +  54: colour 22 chars
        sta nu_colour_after+19, x       ; jsr +  57: colour 21 chars
        sta nu_colour_after+20, x       ; jsr +  60: colour 20 chars
        sta nu_colour_after+21, x       ; jsr +  63: colour 19 chars
        sta nu_colour_after+22, x       ; jsr +  66: colour 18 chars
        sta nu_colour_after+23, x       ; jsr +  69: colour 17 chars
        sta nu_colour_after+24, x       ; jsr +  72: colour 16 chars
        sta nu_colour_after+25, x       ; jsr +  75: colour 15 chars
        sta nu_colour_after+26, x       ; jsr +  78: colour 14 chars
        sta nu_colour_after+27, x       ; jsr +  81: colour 13 chars
        sta nu_colour_after+28, x       ; jsr +  84: colour 12 chars
        sta nu_colour_after+29, x       ; jsr +  87: colour 11 chars
        sta nu_colour_after+30, x       ; jsr +  90: colour 10 chars
        sta nu_colour_after+31, x       ; jsr +  93: colour 9 chars
        sta nu_colour_after+32, x       ; jsr +  96: colour 8 chars
        sta nu_colour_after+33, x       ; jsr +  99: colour 7 chars
        sta nu_colour_after+34, x       ; jsr + 102: colour 6 chars
        sta nu_colour_after+35, x       ; jsr + 105: colour 5 chars
        sta nu_colour_after+36, x       ; jsr + 108: colour 4 chars
        sta nu_colour_after+37, x       ; jsr + 111: colour 3 chars
        sta nu_colour_after+38, x       ; jsr + 114: colour 2 chars
        sta nu_colour_after+39, x       ; jsr + 117: colour 1 char
        
        rts

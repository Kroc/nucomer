; n√ºcomer magazine (c) copyright Kroc Camen 2019. unless otherwise noted,
; licenced under Creative Commons Attribution Non-Commercial Share-Alike 4.0
; licence; you may reuse and modify this code how you please as long as you:
;
; - retain the copyright notice
; - use the same licence for your derived code
; - do not use it for commercial purposes
;   (contact the author for a commercial licence)
;
; read.acme:
;===============================================================================
; the screen used for reading articles

; constants:
;-------------------------------------------------------------------------------
; scrolling speed for pressing cursor keys (cannot exceed 8!)
;
.SCROLL_SPEED = 3

; zero-page variables:
;-------------------------------------------------------------------------------
+alloc  $20

; height of the complete article -- in pixels! this is used to determine the
; exact point to clip smooth scrolling when scrolling quickly. the high-bit
; is used to determine the top of the article, so in practice the article
; is limited to $7FFF (32'767) pixels high, equivalant to 4'095 lines,
; or 170 screens high!
;
+word   ~zp_read_vlen

; exact scroll position -- in pixels!
+word   ~zp_read_vpos

; scroll accumulator, used for changing the speed
; of smooth scrolling; a signed byte
+byte   ~zp_read_scroll

; flag to indicate to disallow upward scrolling
; (prevents smooth scrolling at top of article)
+byte   ~zp_read_stop_up        ; $00 = go, $FF = stop
; flag to indicate to disallow downward scrolling
; (prevents smooth scrolling at bottom of article)
+byte   ~zp_read_stop_dn        ; $00 = go, $FF = stop

; pointer into the line-length array:
+word   ~zp_read_lens
; address of the line data that appears at the top of the screen:
; (changes only when scrolling, not during printing)
+word   ~zp_read_top
; number of rows to print: (1-based)
+byte   ~zp_read_rows
; current row on screen being printed: (0-26)
+byte   ~zp_read_row
; pointer to the current row's line-data;
; this is always where line-data is read from
+word   ~zp_read_char
; current line data-length, in bytes:
+byte   ~zp_read_len
; indexes used when processing line colour-data (it's faster in this
; instance to use zero-page than use the stack or self-modifying-code)
+byte   ~zp_read_index_data
+byte   ~zp_read_index_col
; address of the line that appears at the bottom of the screen:
; (changes only when scrolling, not during printing)
+word   ~zp_read_bot

; for text decompression, a buffer of 40 bytes is required; located in
; the zero-page for maximum speed. we _could_ decompress directly into
; screen RAM, but it would cause visual glitching when the beam goes
; through a line whilst un-packing
;
+addr   ~zp_read_buffer
+bytes  ~zp_read_buffer_screen, 40
+bytes  ~zp_read_buffer_colour, 40

; re-use the colour-data index for the decompression buffer,
; as the two won't ever be used at the same time
;
!addr   zp_read_buffer_index = zp_read_index_col


;===============================================================================
read_screen_rows:
;-------------------------------------------------------------------------------
; this is a lookup table of row-number to screen address, but the screen is
; 27 rows high; this means that when printing row '0', it will be off-screen
; and likewise with row '26'
;
read_screen_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <nu_screen_before
        !for    row, 0, 24 {
                !byte   <(nu_screen + (row * 40))
        }
        !byte   <nu_screen_after

read_screen_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >nu_screen_before
        !for    row, 0, 24 {
                !byte   >(nu_screen + (row * 40))
        }
        !byte   >nu_screen_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_screen_row0        = nu_screen_before      ; off-screen row
read_screen_row1        = nu_screen+( 0*40)
read_screen_row2        = nu_screen+( 1*40)
read_screen_row3        = nu_screen+( 2*40)
read_screen_row4        = nu_screen+( 3*40)
read_screen_row5        = nu_screen+( 4*40)
read_screen_row6        = nu_screen+( 5*40)
read_screen_row7        = nu_screen+( 6*40)
read_screen_row8        = nu_screen+( 7*40)
read_screen_row9        = nu_screen+( 8*40)
read_screen_row10       = nu_screen+( 9*40)
read_screen_row11       = nu_screen+(10*40)
read_screen_row12       = nu_screen+(11*40)
read_screen_row13       = nu_screen+(12*40)
read_screen_row14       = nu_screen+(13*40)
read_screen_row15       = nu_screen+(14*40)
read_screen_row16       = nu_screen+(15*40)
read_screen_row17       = nu_screen+(16*40)
read_screen_row18       = nu_screen+(17*40)
read_screen_row19       = nu_screen+(18*40)
read_screen_row20       = nu_screen+(19*40)
read_screen_row21       = nu_screen+(20*40)
read_screen_row22       = nu_screen+(21*40)
read_screen_row23       = nu_screen+(22*40)
read_screen_row24       = nu_screen+(23*40)
read_screen_row25       = nu_screen+(24*40)
read_screen_row26       = nu_screen_after       ; off-screen-row
}

read_colour_rows:
;-------------------------------------------------------------------------------
; and as before with screen RAM, a lookup table of colour-RAM addresses
; for each row, but accounting for our before & after rows (above)
;
read_colour_rows_lo:
;-------------------------------------------------------------------------------
        !byte   <nu_colour_before
        !for    row, 0, 24 {
                !byte   <($d800 + (row * 40))
        }
        !byte   <nu_colour_after

read_colour_rows_hi:
;-------------------------------------------------------------------------------
        !byte   >nu_colour_before
        !for    row, 0, 24 {
                !byte   >($d800 + (row * 40))
        }
        !byte   >nu_colour_after

!addr {
; provided purely for clarity in reading the code
; during the hard-scroll block copying
read_colour_row0        = nu_colour_before
read_colour_row1        = $d800+( 0*40) ;=$D800
read_colour_row2        = $d800+( 1*40)
read_colour_row3        = $d800+( 2*40)
read_colour_row4        = $d800+( 3*40)
read_colour_row5        = $d800+( 4*40)
read_colour_row6        = $d800+( 5*40)
read_colour_row7        = $d800+( 6*40)
read_colour_row8        = $d800+( 7*40)
read_colour_row9        = $d800+( 8*40)
read_colour_row10       = $d800+( 9*40)
read_colour_row11       = $d800+(10*40)
read_colour_row12       = $d800+(11*40)
read_colour_row13       = $d800+(12*40)
read_colour_row14       = $d800+(13*40)
read_colour_row15       = $d800+(14*40)
read_colour_row16       = $d800+(15*40)
read_colour_row17       = $d800+(16*40)
read_colour_row18       = $d800+(17*40)
read_colour_row19       = $d800+(18*40)
read_colour_row20       = $d800+(19*40)
read_colour_row21       = $d800+(20*40)
read_colour_row22       = $d800+(21*40)
read_colour_row23       = $d800+(22*40)
read_colour_row24       = $d800+(23*40)
read_colour_row25       = $d800+(24*40)
read_colour_row26       = nu_colour_after
}

;===============================================================================
.THEME_GREY_BACK        = .VIC_LTGREY
.THEME_GREY_BORDER      = .THEME_GREY_BACK
.THEME_GREY_FORE        = .VIC_DKGREY
.THEME_GREY_TITLE       = .VIC_BLACK
.THEME_GREY_BOLD        = .VIC_WHITE
.THEME_GREY_NOUN        = .VIC_ORANGE
.THEME_GREY_NAME        = .VIC_PURPLE
.THEME_GREY_SOFT        = .VIC_GREY
.THEME_GREY_URL         = .VIC_BLUE
.THEME_GREY_WARN        = .VIC_RED

.THEME_BLUE_BACK        = .VIC_BLUE
.THEME_BLUE_BORDER      = .THEME_BLUE_BACK
.THEME_BLUE_FORE        = .VIC_LTBLUE
.THEME_BLUE_TITLE       = .VIC_YELLOW
.THEME_BLUE_BOLD        = .VIC_WHITE
.THEME_BLUE_NOUN        = .VIC_LTGREEN
.THEME_BLUE_NAME        = .VIC_GREEN
.THEME_BLUE_SOFT        = .VIC_GREY
.THEME_BLUE_URL         = .VIC_CYAN
.THEME_BLUE_WARN        = .VIC_RED

; define the default theme,
; as is compiled into the assembly:
;
.THEME_BACK             = .THEME_BLUE_BACK
.THEME_BORDER           = .THEME_BACK
.THEME_FORE             = .THEME_BLUE_FORE
.THEME_TITLE            = .THEME_BLUE_TITLE
.THEME_BOLD             = .THEME_BLUE_BOLD
.THEME_NOUN             = .THEME_BLUE_NOUN
.THEME_NAME             = .THEME_BLUE_NAME
.THEME_SOFT             = .THEME_BLUE_SOFT
.THEME_URL              = .THEME_BLUE_URL
.THEME_WARN             = .THEME_BLUE_WARN

read_styles:
;-------------------------------------------------------------------------------
read_styles_colour:
read_style0_colour:     !byte   .THEME_FORE     ; default text colour
read_style1_colour:     !byte   .THEME_TITLE    ; structural (e.g. title)
read_style2_colour:     !byte   .THEME_BOLD
read_style3_colour:     !byte   .THEME_NOUN     ; proper noun, work/citation
read_style4_colour:     !byte   .THEME_NAME     ; person / group
read_style5_colour:     !byte   .THEME_SOFT     ; soft / aside text
read_style6_colour:     !byte   .THEME_URL      ; URL
read_style7_colour:     !byte   .THEME_WARN     ; warning / error

;===============================================================================
read_init:
        ;-----------------------------------------------------------------------
        ; setup the screen:
        ;
        ; turn the screen off whilst we
        ; populate the first screen of text
        lda # %00000000
        sta .VIC_SCREEN_VERT

        ; set screen colour
        lda # .THEME_BORDER
        sta .VIC_BORDER
        lda # .THEME_BACK
        sta .VIC_BACKGROUND

        ; clear and prepare the overlay screen
        ;-----------------------------------------------------------------------
        !ct "build/scr_nucomer.ct" {
        lda # ' '
        }
        ldx # $00
-       sta nu_overlay + $000, x
        sta nu_overlay + $100, x
        sta nu_overlay + $200, x
        sta nu_overlay + $300, x
        dex
        bne -

        ; initialise printing:
        ;-----------------------------------------------------------------------
        ; set the number of token literals, this will be used to decide
        ; what tokens contain screen-codes and what ones are token-pairs
        ; (for further decompression)
        lda nu_text_literals_count
        sta .read_literal_count
        ; set the address of the table of token-pairs (left-bytes)
        lda nu_text_tokens_left+lo
        ldx nu_text_tokens_left+hi
        sta .read_tokens_left+lo
        stx .read_tokens_left+hi
        ; set the address of the table of token-pairs (right-bytes)
        lda nu_text_tokens_right+lo
        ldx nu_text_tokens_right+hi
        sta .read_tokens_right+lo
        stx .read_tokens_right+hi

        ; set the address of the compressed text-data
        lda nu_text_data+lo
        ldx nu_text_data+hi
        ; set the reading head to the first line
        sta zp_read_char+lo
        stx zp_read_char+hi
        ; and this doubles as the first line on the screen
        ; (used to know what line to print when scrolling upwards)
        sta zp_read_top+lo
        stx zp_read_top+hi

        ; set the address of the list of line-lengths
        lda nu_text_lines+lo
        ldx nu_text_lines+hi
        sta zp_read_lens+lo
        stx zp_read_lens+hi

        ; for the smooth scrolling to not overshoot the bottom of the article,
        ; we need to calculate the height of the article in pixels; this is
        ; the number of lines multiplied by 8
        ;
        lda nu_text_length+lo
        ; subtract 26 to account for where the top of the screen
        ; is when the bottom of the article is reached
        sec
        sbc # 26
        sta zp_read_vlen+lo
        lda nu_text_length+hi
        sbc # 0
        sta zp_read_vlen+hi
        ; begin multiplying
        asl zp_read_vlen+lo     ; x2
        rol zp_read_vlen+hi     ; ...
        asl zp_read_vlen+lo     ; x4
        rol zp_read_vlen+hi     ; ...
        asl zp_read_vlen+lo     ; x8
        rol zp_read_vlen+hi     ; ...

        ; print the article's first screen full of text
        ;-----------------------------------------------------------------------
        ldy # 0                 ; begin on row 0 -- the off-screen row
        ldx # 27                ; number of rows to print (1-based)
        jsr read_print

        ; now that 27 rows have been printed, the routine will have left
        ; the details of the last row behind which we can make use of
        lda zp_read_char+lo
        sta zp_read_bot+lo
        lda zp_read_char+hi
        sta zp_read_bot+hi

        ;-----------------------------------------------------------------------
        ; reset the smooth scrolling variables
        ;
        ldx # $00
        stx zp_read_scroll      ; scroll-speed = 0
        stx zp_read_stop_dn     ; allow scrolling down; $00 = go, $FF = stop
        stx zp_read_vpos+lo     ; set the exact pixel vertical position
        stx zp_read_vpos+hi     ; within the article to zero
        ; we begin at the top of the article,
        ; so disallow scrolling upwards
        dex                     ; X = $FF
        stx zp_read_stop_up     ; $00 = go, $FF = stop

        ; set our own interrupt handlers
        jsr read_irq_init

        ; note that the screen will automatically turn itself back on
        ; because the raster interrupt that handles smooth-scrolling
        ; always sets the screen control register every frame

read_keyboard:
        ;-----------------------------------------------------------------------
        jsr Keyboard
        bcc @crsr

        ; when no keys are pressed, or the scroll keys
        ; are released, stop the smooth scrolling
        lda # $00
        sta zp_read_scroll
        ; no key code to process,
        ; go back to waiting
        bpl read_keyboard       ; (always branches)
        brk

        ; cursor up/down
        ;-----------------------------------------------------------------------
@crsr   cpx # %10000000
        bne @spc

        ; up, or down?
        tya
        and # %01010000         ; are either of the shift keys pressed?
        bne @up                 ; if yes, it's CRSR-UP

        ; crsr-dn
        ;-----------------------------------------------------------------------
        ; if at the bottom of the article,
        ; do not allow scrolling any further
        ;
@dn     lda zp_read_stop_dn     ; check flag set when scroll hits the bottom
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content down the page:
        ; (smooth scroll upwards)
        ldx # .SCROLL_SPEED     ; set scroll speed
        stx zp_read_scroll      ; this will be applied at interrupt
        ; whenever scrolling down,
        ; allow scrolling up again
        sta zp_read_stop_up     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

        ; crsr-up
        ;-----------------------------------------------------------------------
        ; if at the top of the article,
        ; do not allow scrolling any further
@up     lda zp_read_stop_up     ; check flag set when scroll hits the top
        bmi read_keyboard       ; if flag is set ($FF) then don't scroll

        ; scroll the content up the page
        ; (smooth scroll downwards)
        ldx # 256-.SCROLL_SPEED ; set negative scroll speed
        stx zp_read_scroll      ; this will be applied at interrupt
        ; whenever scrolling up,
        ; allow scrolling down again
        sta zp_read_stop_dn     ; A = $00 due to condition above
        bne read_keyboard       ; (always branches, note X register is used!)

@spc    cmp # $20
        bne @esc

        jsr irqs_disable
        jmp read_init

@esc    cmp # $1f               ; "<-" key
        beq @exit
        
@stop   cpy # %10000000
        bne +
        brk

+       jmp read_keyboard

        ;-----------------------------------------------------------------------
        jmp *

        ; TODO: transition out
@exit   jsr irqs_disable        ; tear down the custom interrupt handlers
        rts                     ; return to the menu

;===============================================================================
; display a footnote
;
read_footnote:
        ;-----------------------------------------------------------------------


; IRQs:
;===============================================================================
; we don't need stable rasters most of the time with the reading screen so
; IRQs chain each other and stabilisation is handled individually by any
; specific IRQ that requires it
;
; before the visible screen begins we set the vertical smooth-scrolling offset
; -- we cannot change the vertical scroll inside the screen or we will get
; tearing / glitching!
;
; hard scrolling the screen up or down takes a long time and even if we start
; before vblank, the process will overrun into the screen before it finishes,
; causing screen tear. therefore it is necessary for this interrupt to
; interrupt the previous one(!) whilst it is still shifting the screen,
; to ensure that the smooth scrolling register is not changed within
; the visible portion of the screen when hard-scrolling is occuring
;
.IRQ_TOP        = 0

; hard scrolling the screen takes a lot of cycles and we must be ahead of the
; beam when we do this to avoid screen-tearing, therefore we begin scrolling
; the top of the screen whilst the beam is in the middle of the screen
;
.IRQ_SCROLL     = SCANLINE_VBLANK_BEGIN - (14 * 8)

; the footnote overlay is unique in that it has to change the vertical scroll
; register within the visible screen. because the smooth scroll register could
; be any value 0 to 7 before we change it, we have to deal with a potential
; "bad-line" in the stabilisation. we interrupt one line early to be able to
; deal with the [possible] first bad-line which does not give us enough time
; to make any changes
;
.IRQ_OVERLAY    = (SCANLINE_VBLANK_BEGIN - (8 * 8))

;-------------------------------------------------------------------------------
; 
read_irq_init:
        ;-----------------------------------------------------------------------
        ; remove any current custom interrupts and put the safety stubs
        ; in place; these will prevent crashes from unexpected interrupts
        ;
        jsr irqs_disable

        ; absolutely do not allow an interrupt to occur
        ; in the middle of changing interrupt settings!
        ;
        sei                     ; disable interrupts

        lda # .IRQ_TOP          ; scanline to interrupt at
        sta .VIC_SCANLINE

        ldx #< read_irq_top     ; IRQ handler address, lo
        ldy #> read_irq_top     ; IRQ handler address, hi
        stx .HW_VECTOR_IRQ+lo
        sty .HW_VECTOR_IRQ+hi
        
        ; enable raster-interrupts on the VIC-II (sprite-sprite,
        ; sprite-background & lightpen interrupts are disabled)
        lda # %00000001
        sta .VIC_INTERRUPT_CONTROL

        ; safe to re-enable interrupts
        cli
        rts

;-------------------------------------------------------------------------------
; shared Return From Interrupt footer
;
read_irq_rti_xy:
        ;-----------------------------------------------------------------------
        pla                     ; restore pre-interrupt...
        tay                     ; ...Y register
        pla                     ; restore pre-interrupt...
        tax                     ; ...X register

read_irq_rti:
        ;-----------------------------------------------------------------------
        pla                     ; restore pre-interrupt A register
        ;;dec .VIC_BORDER
        rti

;===============================================================================
read_irq_top:
        ;-----------------------------------------------------------------------
        ; acknowledge the interrupt to prevent it double-firing;  we only need
        ; to write to the status register to do this, the value is unimportant
        inc .VIC_INTERRUPT_STATUS
        ; backup pre-interrupt A register
        pha

        ;-----------------------------------------------------------------------
        ; return to the in-page background colour
        ; (rather than the status-bar colour)
        lda # .THEME_BACK
        sta .VIC_BORDER
        sta .VIC_BACKGROUND

        ; set the smooth scroll register. we are doing this at the top of
        ; the screen, just before the text begins to avoid graphical glitches
        lda zp_read_vpos+lo
        and # %00000111
        eor # %00000111
        ;     %---1---- = screen on
        ;     %----0--- = 24 rows (for smooth scrolling)
        ;     %-----??? = vertical scroll offset
        ora # %00010000
        sta .VIC_SCREEN_VERT

        ; temp: print Y-scroll value
        ;-----------------------------------------------------------------------
        ;;lsr
        ;;pha
        ;;lda # '0'
        ;;adc # 0
        ;;sta nu_screen+(1*40)+2
        ;;
        ;;pla
        ;;lsr
        ;;pha
        ;;lda # '0'
        ;;adc # 0
        ;;sta nu_screen+(1*40)+1
        ;;
        ;;pla
        ;;lsr
        ;;lda # '0'
        ;;adc # 0
        ;;sta nu_screen+(1*40)+0

        ; chain the next IRQ
        ;-----------------------------------------------------------------------
        sei                     ; disable interrupts
        lda # .IRQ_SCROLL
        sta .VIC_SCANLINE
        lda #< read_irq_scroll
        sta .HW_VECTOR_IRQ+lo
        lda #> read_irq_scroll
        sta .HW_VECTOR_IRQ+hi
        ; we're going to skip re-enabling interrupts as the RTI instruction
        ; will pop the pre-interrupt state, re-enabling the interrupts soon
        ; enough that it doesn't matter between here and the RTI
        ;cli

        pla                     ; restore pre-interrupt A register
        rti

;===============================================================================
read_irq_scroll:
        ;-----------------------------------------------------------------------
        ;;inc .VIC_BORDER

        ; acknowledge the interrupt to prevent it double-firing;  we only need
        ; to write to the status register to do this, the value is unimportant
        inc .VIC_INTERRUPT_STATUS

        pha                     ; backup pre-interrupt A-register

        sei                     ; disable interrupts
        lda # .IRQ_TOP
        sta .VIC_SCANLINE
        lda #< read_irq_top
        sta .HW_VECTOR_IRQ+lo
        lda #> read_irq_top
        sta .HW_VECTOR_IRQ+hi
        cli                     ; safe to re-enable interrupts

        ;-----------------------------------------------------------------------
        ; is there any scrolling to be done?
        ;
        lda zp_read_scroll      ; read requested scroll speed
        bne +                   ; if scroll-speed = 0, then skip

        pla
        rti

        ; backup X & Y registers
+       txa
        pha
        tya
        pha

        ;-----------------------------------------------------------------------
        ; apply the scroll to our current
        ; vertical position within the article
        clc
        lda zp_read_vpos+lo
        ; remember the article position *before* the move;
        ; we'll need to mask the bottom three bits later
        tay
        ; note that regardless of positive or negative scroll speed,
        ; adding will always produce the same result due to the
        ; wrap-around nature of negative numbers (e.g. -1 = +$FF)
        adc zp_read_scroll
        sta zp_read_vpos+lo

        ; beyond one byte, we do have to take into
        ; account the postive / negative direction
        lda zp_read_vpos+hi
        ; check the sign-bit of the scroll-speed
        bit zp_read_scroll
        bmi +
        ; for positive numbers,
        ; the carry can be applied
        adc # 0
       +bit_skip2
        ; for negative numbers,
        ; the carry becomes a borrow
+       sbc # 0
        sta zp_read_vpos+hi

        ; hit top/bottom of article?
        ;-----------------------------------------------------------------------
        ; have we gone above the top of the article?
        ; (pixel vertical position < $0000)
        ldx zp_read_vpos+hi
        bpl +
        ; gone above the article; move back to the top
        stx zp_read_stop_up     ; X = $FF, disable scrolling upwards
        inx                     ; X = $00
        stx zp_read_vpos+lo     ; set scroll position within article
        stx zp_read_vpos+hi     ; to $0000

@done:  jmp read_irq_rti_xy
        ;-----------------------------------------------------------------------

        ; check the end of the article:
+       ldx zp_read_vlen+hi
        cpx zp_read_vpos+hi
        beq +                   ; hi-bytes equal, compare lo-bytes
        bcs @scroll             ; scroll position < height, scroll ahead
        bcc @stop               ; scroll position > height, go back!
        ; check the low-bytes
+       ldx zp_read_vlen+lo
        cpx zp_read_vpos+lo
        bcs @scroll
        
        ; gone below the article!
        ; move back to the end
@stop   ldx # $ff               ; set the flag to disallow
        stx zp_read_stop_dn     ; scrolling down ($FF = stop, $00 = go)
        inx                     ; X = $00
        sta zp_read_scroll      ; set scroll speed to zero
        ldx zp_read_vlen+lo     ; change the moved-to position back a bit
        stx zp_read_vpos+lo     ; to the exact bottom of the article
        lda zp_read_vlen+hi
        sta zp_read_vpos+hi
        
        ; do we need to hard-scroll?
        ;-----------------------------------------------------------------------
@scroll tya                     ; article scroll position *before* scroll
        and # %00000111         ; get just the smooth scroll offset (0-7)
        sta zp_read_row         ; (temporary use)

        lda zp_read_vpos+lo     ; article scroll position *after* scroll
        and # %00000111         ; get just the smooth scroll offset (0-7)
        
        bit zp_read_scroll      ; check direction of scroll
        bpl +

        cmp zp_read_row         ; (temporary use)
        bcc @done

        jsr read_scroll_up
        jmp @done

+       cmp zp_read_row         ; (temporary use)
        bcs @done

;===============================================================================
; scroll the article down a line:
;
read_scroll_down:
        ;-----------------------------------------------------------------------
        ; copy the screen up a row -- due to the number of rows, the loop has
        ; to be split into three otherwise the relative branches cannot reach
        ; the top (>128 bytes) but we do want to get as close to that limit
        ; as possible (about 41 load + stores) as this minimizes the number
        ; of cycles wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
-       ; row 1 -> row 0
        lda read_screen_row1, y ; the top line moves into the off-screen
        sta read_screen_row0, y ; buffer ready for if the user scrolls up
        lda read_colour_row1, y ; (=$D800)
        sta read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        ; row 2 -> row 1
        lda read_screen_row2, y
        sta read_screen_row1, y
        lda read_colour_row2, y
        sta read_colour_row1, y
        ; row 3 -> row 2
        lda read_screen_row3, y
        sta read_screen_row2, y
        lda read_colour_row3, y
        sta read_colour_row2, y
        ; row 4 -> row 3
        lda read_screen_row4, y
        sta read_screen_row3, y
        lda read_colour_row4, y
        sta read_colour_row3, y
        ; row 5 -> row 4
        lda read_screen_row5, y
        sta read_screen_row4, y
        lda read_colour_row5, y
        sta read_colour_row4, y
        ; row 6 -> row 5
        lda read_screen_row6, y
        sta read_screen_row5, y
        lda read_colour_row6, y
        sta read_colour_row5, y
        ; row 7 -> row 6
        lda read_screen_row7, y
        sta read_screen_row6, y
        lda read_colour_row7, y
        sta read_colour_row6, y
        ; row 8 -> row 7
        lda read_screen_row8, y
        sta read_screen_row7, y
        lda read_colour_row8, y
        sta read_colour_row7, y
        ; row 9 -> row 8
        lda read_screen_row9, y
        sta read_screen_row8, y
        lda read_colour_row9, y
        sta read_colour_row8, y
        ; row 10 -> row 9
        lda read_screen_row10, y
        sta read_screen_row9, y
        lda read_colour_row10, y
        sta read_colour_row9, y
        dey
        bpl -

        ldy # 39
        ; row 11 -> row 10
-       lda read_screen_row11, y
        sta read_screen_row10, y
        lda read_colour_row11, y
        sta read_colour_row10, y
        ; row 12 -> row 11
        lda read_screen_row12, y
        sta read_screen_row11, y
        lda read_colour_row12, y
        sta read_colour_row11, y
        ; row 13 -> row 12
        lda read_screen_row13, y
        sta read_screen_row12, y
        lda read_colour_row13, y
        sta read_colour_row12, y
        ; row 14 -> row 13
        lda read_screen_row14, y
        sta read_screen_row13, y
        lda read_colour_row14, y
        sta read_colour_row13, y
        ; row 15 -> row 14
        lda read_screen_row15, y
        sta read_screen_row14, y
        lda read_colour_row15, y
        sta read_colour_row14, y
        ; row 16 -> row 15
        lda read_screen_row16, y
        sta read_screen_row15, y
        lda read_colour_row16, y
        sta read_colour_row15, y
        ; row 17 -> row 16
        lda read_screen_row17, y
        sta read_screen_row16, y
        lda read_colour_row17, y
        sta read_colour_row16, y
        ; row 18 -> row 17
        lda read_screen_row18, y
        sta read_screen_row17, y
        lda read_colour_row18, y
        sta read_colour_row17, y
        ; row 19 -> row 18
        lda read_screen_row19, y
        sta read_screen_row18, y
        lda read_colour_row19, y
        sta read_colour_row18, y
        ; row 20 -> row 19
        lda read_screen_row20, y
        sta read_screen_row19, y
        lda read_colour_row20, y
        sta read_colour_row19, y
        dey
        bpl -

        ldy # 40
        ; row 21 -> row 20
-       lda read_screen_row21-1, y
        sta read_screen_row20-1, y
        lda read_colour_row21-1, y
        sta read_colour_row20-1, y
        ; row 22 -> row 21
        lda read_screen_row22-1, y
        sta read_screen_row21-1, y
        lda read_colour_row22-1, y
        sta read_colour_row21-1, y
        ; row 23 -> row 22
        lda read_screen_row23-1, y
        sta read_screen_row22-1, y
        lda read_colour_row23-1, y
        sta read_colour_row22-1, y
        ; row 24 -> row 23
        lda read_screen_row24-1, y
        sta read_screen_row23-1, y
        lda read_colour_row24-1, y
        sta read_colour_row23-1, y
        ; row 25 -> row 24
        lda read_screen_row25-1, y
        sta read_screen_row24-1, y
        lda read_colour_row25-1, y
        sta read_colour_row24-1, y
        ; row 26 -> row 25
        ; copy the off-screen line into view
        lda read_screen_row26-1, y
        sta read_screen_row25-1, y
        ; note that the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row26-1, y
        sta read_colour_row25-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ; begin printing the new row
        ;-----------------------------------------------------------------------
        ; read the length of the current line at the top of the screen,
        ; and move the line-pointer for the top screen line to the next line
        ;
        clc                     ; (note that Y = 0)
        lda (zp_read_lens), y   ; length of line above screen
        and # %00111111         ; (top two bits are flags)
        adc zp_read_top+lo      ; add line-length to the line address
        sta zp_read_top+lo      ; (move to next line)
        bcc +
        inc zp_read_top+hi
        clc

        ; do the same but with the line-pointer for the bottom row of the
        ; screen, but also write the address into the print routine
        ;
+       ldy # 26                ; row to begin printing at (below screen)
        lda (zp_read_lens), y   ; length of line at bottom of screen
        and # %00111111         ; (top two bits are flags)
        adc zp_read_bot+lo      ; add line-length to the line address
        sta zp_read_bot+lo      ; (move to next line)
        sta zp_read_char+lo     ; set printing routine line-address (lo)
        lda zp_read_bot+hi
        adc # 0                 ; ripple the add
        sta zp_read_bot+hi
        sta zp_read_char+hi     ; set printing routine line-address (hi)

        ; move to the next entry in the line-lengths array
        inc zp_read_lens+lo
        bne +
        inc zp_read_lens+hi

+       ldx # 1                 ; number of lines to print
        jsr read_print          ; note that Y = 26, row to print from

        jmp read_irq_rti_xy

;===============================================================================
; scroll the article up a line:
;
read_scroll_up:
        ;-----------------------------------------------------------------------
        ; copy the screen down a row:
        ;
        ; credit for this particular methodology must go to Richard Bayliss
        ; of The New Dimenson for producing a copy routine fast enough to
        ; copy the screen bottom-up before the scanline catches up
        ; <http://tnd64.unikat.sk/assemble_it6.html>
        ;
        ; due to the number of rows, the loop has to be split into three
        ; otherwise the relative branches cannot reach the top (>128 bytes)
        ; but we do want to get close to that limit as possible (about
        ; 41 load + stores) as this minimizes the amount of cycles
        ; wasted each iteration maintaining the loop
        ;
        ldy # 39                ; as always, loop backwards for speed
        ; row 9 -> row ...
-       lda read_screen_row9, y
        sta zp_read_buffer_screen, y    ; (zero-page, saves 40 cycles)
        lda read_colour_row9, y
        sta zp_read_buffer_colour, y    ; (zero-page, saves 40 cycles)
        ; row 8 -> row 9
        lda read_screen_row8, y
        sta read_screen_row9, y
        lda read_colour_row8, y
        sta read_colour_row9, y
        ; row 7 -> row 8
        lda read_screen_row7, y
        sta read_screen_row8, y
        lda read_colour_row7, y
        sta read_colour_row8, y
        ; row 6 -> row 7
        lda read_screen_row6, y
        sta read_screen_row7, y
        lda read_colour_row6, y
        sta read_colour_row7, y
        ; row 5 -> row 6
        lda read_screen_row5, y
        sta read_screen_row6, y
        lda read_colour_row5, y
        sta read_colour_row6, y
        ; row 4 -> row 5
        lda read_screen_row4, y
        sta read_screen_row5, y
        lda read_colour_row4, y
        sta read_colour_row5, y
        ; row 3 -> row 4
        lda read_screen_row3, y
        sta read_screen_row4, y
        lda read_colour_row3, y
        sta read_colour_row4, y
        ; row 2 -> row 3
        lda read_screen_row2, y
        sta read_screen_row3, y
        lda read_colour_row2, y
        sta read_colour_row3, y
        ; row 1 -> row 2
        lda read_screen_row1, y
        sta read_screen_row2, y
        lda read_colour_row1, y
        sta read_colour_row2, y
        ; row 0 -> row 1
        ; (copy the off-screen line into view)
        lda read_screen_row0, y
        sta read_screen_row1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $D800-40 when I/O is on!
        lda read_colour_row0, y ; (offscreen colour-RAM buffer, outside $D800)
        sta read_colour_row1, y ; (=$D800)
        dey
        bpl -

        ldy # 39
        ; row 18 -> row ...
        ; (we use the off-screen row above temporarily as it is "garbage" at
        ;  this point until after the screen copy, when it will be populated)
-       lda read_screen_row18, y
        sta read_screen_row0, y
        lda read_colour_row18, y
        sta read_colour_row0, y
        ; row 17 -> row 18
        lda read_screen_row17, y
        sta read_screen_row18, y
        lda read_colour_row17, y
        sta read_colour_row18, y
        ; row 16 -> row 17
        lda read_screen_row16, y
        sta read_screen_row17, y
        lda read_colour_row16, y
        sta read_colour_row17, y
        ; row 15 -> row 16
        lda read_screen_row15, y
        sta read_screen_row16, y
        lda read_colour_row15, y
        sta read_colour_row16, y
        ; row 14 -> row 15
        lda read_screen_row14, y
        sta read_screen_row15, y
        lda read_colour_row14, y
        sta read_colour_row15, y
        ; row 13 -> row 14
        lda read_screen_row13, y
        sta read_screen_row14, y
        lda read_colour_row13, y
        sta read_colour_row14, y
        ; row 12 -> row 13
        lda read_screen_row12, y
        sta read_screen_row13, y
        lda read_colour_row12, y
        sta read_colour_row13, y
        ; row 11 -> row 12
        lda read_screen_row11, y
        sta read_screen_row12, y
        lda read_colour_row11, y
        sta read_colour_row12, y
        ; row 10 -> row 11
        lda read_screen_row10, y
        sta read_screen_row11, y
        lda read_colour_row10, y
        sta read_colour_row11, y
        ; row ... -> row 10
        lda zp_read_buffer_screen, y    ; (zero-page, saves 40 cycles)
        sta read_screen_row10, y
        lda zp_read_buffer_colour, y    ; (zero-page, saves 40 cycles)
        sta read_colour_row10, y
        dey
        bpl -

        ldy # 40
        ; row 25 -> row 26
        ; the bottom line moves into the off-screen
        ; buffer ready for if the user scrolls down
-       lda read_screen_row25-1, y
        sta read_screen_row26-1, y
        ; the color for the off-screen line is stored at a different
        ; place as we cannot store data at $DC00 when I/O is on!
        lda read_colour_row25-1, y
        sta read_colour_row26-1, y
        ; row 24 -> row 25
        lda read_screen_row24-1, y
        sta read_screen_row25-1, y
        lda read_colour_row24-1, y
        sta read_colour_row25-1, y
        ; row 23 -> row 24
        lda read_screen_row23-1, y
        sta read_screen_row24-1, y
        lda read_colour_row23-1, y
        sta read_colour_row24-1, y
        ; row 22 -> row 23
        lda read_screen_row22-1, y
        sta read_screen_row23-1, y
        lda read_colour_row22-1, y
        sta read_colour_row23-1, y
        ; row 21 -> row 22
        lda read_screen_row21-1, y
        sta read_screen_row22-1, y
        lda read_colour_row21-1, y
        sta read_colour_row22-1, y
        ; row 20 -> row 21
        lda read_screen_row20-1, y
        sta read_screen_row21-1, y
        lda read_colour_row20-1, y
        sta read_colour_row21-1, y
        ; row 19 -> row 20
        lda read_screen_row19-1, y
        sta read_screen_row20-1, y
        lda read_colour_row19-1, y
        sta read_colour_row20-1, y
        ; row ... -> row 19
        lda read_screen_row0-1, y
        sta read_screen_row19-1, y
        lda read_colour_row0-1, y
        sta read_colour_row19-1, y
        dey
        bne -                   ; stop when Y = 0 (important for later!)

        ; print the next row in the off-screen space
        ;-----------------------------------------------------------------------
        sec
        lda zp_read_lens+lo     ; move the index in the line-lengths array...
        sbc # 1                 ; ...back one line
        sta zp_read_lens+lo
        bcs +
        dec zp_read_lens+hi
        sec

        ; move the address of the line above the screen
        ; backwards to the previous line address
        ;
        ; TODO: anyway to do this subtraction faster? (EOR-1?)
        ;       the need to mask the top bits prevents us
        ;       from using `sbc (zp_read_lens), y`
        ;
+       lda (zp_read_lens), y
        and # %00111111         ; (top two bits are flags)
        sta zp_read_row         ; (temporary use)

        lda zp_read_top+lo
        sbc zp_read_row         ; (length of line-data, in bytes)
        sta zp_read_top+lo
        sta zp_read_char+lo     ; also set in the printing routine
        lda zp_read_top+hi
        sbc # 0                 ; ripple the subtract
        sta zp_read_top+hi
        sta zp_read_char+hi     ; also set in the printing routine

        ; repeat this for the off-screen
        ; line after the screen RAM
        ;
        ; TODO: anyway to do this subtraction faster? (EOR-1?)
        ;       the need to mask the top bits prevents us
        ;       from using `sbc (zp_read_lens), y`
        ;
        ldy # 26
        lda (zp_read_lens), y   ; length of line-data, in bytes
        and # %00111111         ; (top two bits are flags)
        sta zp_read_row         ; (temporary use)

        lda zp_read_bot+lo
        sbc zp_read_row         ; (length of line-data, in bytes)
        sta zp_read_bot+lo
        bcs +
        dec zp_read_bot+hi

+       ldy # 0                 ; starting row
        ldx # 1                 ; number of rows to print

;===============================================================================
; print a number of lines from the article to the screen:
;
;       Y = row to begin printing
;       X = number of lines to print (1-based)
;       
; the address to read data from must already be set in:
;
;       zp_read_char
;
read_print:
        ;-----------------------------------------------------------------------
        ; prepare for printing:
        ;
        stx zp_read_rows        ; number of lines to print (1-based)
        sty zp_read_row         ; current row being printed

        ; print a line:
        ;-----------------------------------------------------------------------
@line:  ldy zp_read_row         ; current row...

        ; set the screen address from the row number
        lda read_screen_rows_lo, y
        sta @out+1
        lda read_screen_rows_hi, y
        sta @out+2
        ; get the number of *compressed* bytes for this line;
        ; this is not the number of characters on the line,
        ; and the upper two-bits are used as flags
        lda (zp_read_lens), y

        ; most lines of text will not require colour data, resorting to the
        ; 'default' style. if we included a byte for every line to indicate
        ; if it had colour-data or not, this would waste a lot of bytes very
        ; quickly; 500 extra bytes for 500 lines is a lot of wasted bytes!
        ;
        ; instead, the upper-bit of the line-length is used to indicate the
        ; presence of colour-data in the line-data. the compare instruction
        ; that follows will check the high-bit of the line-length; if it's 0,
        ; carry is set; if 1, carry is cleared. we use this as our indicator
        ; for reading & processing colour-data from the line-data
        ;
        cmp # %10000000         ; check for high-bit on the byte-count
        beq @eof                ; terminator mark ($80), article ends
        
        and # %00111111         ; (strip flags from byte-count)

        ; whilst we count Y down to zero, we keep a copy of the line-length
        ; to move the character pointer forward to the next line (the flags
        ; in the upper bits have been been stripped now)
        tay                     ; Y = length of line-data (in bytes)
        sty zp_read_len

        ; skip a zero-length line
        ; (line-length must be recorded first)
        beq @blank

        ; if colour data is present, go process it first
        ; (note that the carry bit has not been modified
        ;  since the CMP instruction above)
        bcs @cdata

        ; when no colour data is present, we still have to
        ; colour the whole line with the default style
        lda read_style0_colour
        jsr read_colour_row

        ; print line:
        ;-----------------------------------------------------------------------
        ; Y is the number of compressed bytes remaining to read; these will
        ; be decompressed into a buffer of screen-codes ready to print.
        ; the number of characters to print (0-based) will be returned in X
@print: jsr read_decompress

        ; TODO:
        ldx # 39
-       lda zp_read_buffer, x   ; read a character from the buffer
@out    sta nu_screen, x        ; print the character
        dex                     ; more characters remain in the buffer?
        bpl -                   ; keep printing whilst characters remain

        ; end-of-line:
        ;-----------------------------------------------------------------------
@eol:   dec zp_read_rows        ; all rows printed?
        beq @eof                ; yes -- stop printing

        inc zp_read_row         ; move to the next screen row

        ; move the data-pointer forward to the beginning of the next line,
        ; that is, add the length of the line (in bytes) to the pointer
        clc
        lda zp_read_char+lo
        adc zp_read_len
        sta zp_read_char+lo
        bcc @line
        inc zp_read_char+hi
        bne @line
        brk

        ; print blank line:
        ;-----------------------------------------------------------------------
        ; we don't have to erase the characters already in the line
        ; if we just colour the line blank, which is slightly faster
        ;
@blank: lda # .THEME_BACK       ; colour text same as background
        jsr read_colour_row     ; colour whole row quickly

        beq @eol
        bne @eol

@eof:   rts

        ; colour whole row:
        ;=======================================================================
@whole: and # %00000111         ; which style class
        tax                     ; (we know this is the first byte, so reuse X)
        
        ; get the colour for the given style class
        lda read_styles_colour, x
        jsr read_colour_row

        ; begin printing text:
        dey                     ; move to the next line-data byte
        bne @print              ; (always branches, Y != 0)
        brk

        ; finished colour-data, begin printing text:
        ;-----------------------------------------------------------------------
@cdone: ldy zp_read_index_data  ; retrieve the data-index for reading bytes
        bne @print              ; (always branches, Y != 0)
        brk

        ; decode colour-data:
        ;=======================================================================
        ; the first colour byte is special:
        ;
        ; if the upper bit is set, this indicates that the whole line is
        ; coloured a non-default colour and no other colour data will follow
        ;
@cdata: lda (zp_read_char), y   ; read first colour-data byte
        bmi @whole              ; colour whole row one colour?

        dey                     ; move to the next data-byte
        sty zp_read_index_data  ; save the current position

        ; if the first byte upper-bit is not set, the first byte represents
        ; an initial column offset before the first colour change occurs
        ; (colour spans are limited to 32-chars, but the initial-offset can
        ;  be higher, though obviously limited to the width of the screen)
        ;
        ; now that we know we will be reading more than 1-byte of colour
        ; data, we set up the colour-RAM address we'll be writing to:
        ;
        pha                     ; backup the first data-byte

        ldx zp_read_row         ; current row being printed
        lda read_colour_rows_hi, x
        sta @clram+2
        lda read_colour_rows_lo, x
        sbc # 1                 ; (carry is still set from way, way back!)
        sta @clram+1

        ldx # 40                ; starting column
        stx zp_read_index_col   ; (colouring right-to-left!)

        pla                     ; length of first span (can be > 32)
        beq @cread              ; if there's no initial offset, ignore it

        tay                     ; number of characters to colour
        dey                     ; (adjust to 0-based for the colouring loop)
        lda read_style0_colour  ; use the default line colour
        bne @clram              ; (always branches, != 0)
        brk

        ; process colour-spans:
        ;-----------------------------------------------------------------------
        ; after the first byte is processed, all colour-data bytes that follow
        ; use a fixed format:
        ;
        ;       %sssnnnnn       s = style class to change to (0-7)
        ;                       n = length of span (0-31, represents 1 to 32)
        ;
@cread: ldy zp_read_index_data  ; retrieve the data-index before reading
        lda (zp_read_char), y   ; read a byte of colour-data
        tax                     ; (put-aside to extract the style-class later)
        dec zp_read_index_data  ; move to the next data-byte
        and # %00011111         ; extract the span-length from the byte,
        tay                     ; and use this as a count-down

        ; decode the style-class from the top three bits;
        ; we need to rotate these into the bottom three bits
        ;
        txa                     ; retrieve the data-byte again
        and # %11100000         ; keep top three bits (also, no carry at end)
        asl                     ; pop bit 7 off
        rol                     ; shift bit 7 in, pop bit 6 off
        rol                     ; shift bit 6 in, pop bit 5 off
        rol                     ; shift bit 5 in
        tax                     ; we now have the style class 0-7
        lda read_styles, x      ; look up the style class from the index

        ldx zp_read_index_col   ; restore our current column number
@clram  sta $d800, x            ; set the colour
        dex
        beq @cdone
        dey                     ; one less cell to colour...
        bpl @clram              ; keep going?
        
        stx zp_read_index_col   ; remember current column for the next span
        bmi @cread              ; read the next span from the colour-data?
        brk

;===============================================================================
; colour a whole row:
;
; rows 1-25 use a slower, general method:
;-------------------------------------------------------------------------------
-       pha                     ; put colour aside

        ; look up the address to write to
        ; (X is the current row)
        lda read_colour_rows_lo, x
        sta @clrow+1
        lda read_colour_rows_hi, x
        sta @clrow+2

        pla                     ; get the colour back
        ldx # 40-1              ; colour 40 columns...
@clrow  sta $d800, x
        dex
        bpl @clrow

        rts

; this is the routine you want to call,
; it'll use the fastest path available for the row number
;
read_colour_row:
        ;-----------------------------------------------------------------------
        ; which row are we on?
        ; (there are speed-paths for the off-screen rows)
        ldx zp_read_row
        ; row = 0? colour off-screen row above screen
        beq read_colour_before
        ; row = 26? colour off-screen row below screen
        cpx # 26
        bne -

; set the colour for the off-screen bottom row:
;
; this is a "fast path" to set a colour on the characters
; of the off-screen row below the screen
;
;       A = colour
;
read_colour_after:
        ;-----------------------------------------------------------------------
        sta nu_colour_after+0
        sta nu_colour_after+1
        sta nu_colour_after+2
        sta nu_colour_after+3
        sta nu_colour_after+4
        sta nu_colour_after+5
        sta nu_colour_after+6
        sta nu_colour_after+7
        sta nu_colour_after+8
        sta nu_colour_after+9
        sta nu_colour_after+10
        sta nu_colour_after+11
        sta nu_colour_after+12
        sta nu_colour_after+13
        sta nu_colour_after+14
        sta nu_colour_after+15
        sta nu_colour_after+16
        sta nu_colour_after+17
        sta nu_colour_after+18
        sta nu_colour_after+19
        sta nu_colour_after+20
        sta nu_colour_after+21
        sta nu_colour_after+22
        sta nu_colour_after+23
        sta nu_colour_after+24
        sta nu_colour_after+25
        sta nu_colour_after+26
        sta nu_colour_after+27
        sta nu_colour_after+28
        sta nu_colour_after+29
        sta nu_colour_after+30
        sta nu_colour_after+31
        sta nu_colour_after+32
        sta nu_colour_after+33
        sta nu_colour_after+34
        sta nu_colour_after+35
        sta nu_colour_after+36
        sta nu_colour_after+37
        sta nu_colour_after+38
        sta nu_colour_after+39
        
        rts

; set the colour for the off-screen top row:
;
; this is a "fast path" to set a colour on the characters
; of the off-screen row above the screen
;
;       A = colour
;
read_colour_before:
        ;-----------------------------------------------------------------------
        sta nu_colour_before+0
        sta nu_colour_before+1
        sta nu_colour_before+2
        sta nu_colour_before+3
        sta nu_colour_before+4
        sta nu_colour_before+5
        sta nu_colour_before+6
        sta nu_colour_before+7
        sta nu_colour_before+8
        sta nu_colour_before+9
        sta nu_colour_before+10
        sta nu_colour_before+11
        sta nu_colour_before+12
        sta nu_colour_before+13
        sta nu_colour_before+14
        sta nu_colour_before+15
        sta nu_colour_before+16
        sta nu_colour_before+17
        sta nu_colour_before+18
        sta nu_colour_before+19
        sta nu_colour_before+20
        sta nu_colour_before+21
        sta nu_colour_before+22
        sta nu_colour_before+23
        sta nu_colour_before+24
        sta nu_colour_before+25
        sta nu_colour_before+26
        sta nu_colour_before+27
        sta nu_colour_before+28
        sta nu_colour_before+29
        sta nu_colour_before+30
        sta nu_colour_before+31
        sta nu_colour_before+32
        sta nu_colour_before+33
        sta nu_colour_before+34
        sta nu_colour_before+35
        sta nu_colour_before+36
        sta nu_colour_before+37
        sta nu_colour_before+38
        sta nu_colour_before+39
        
-       rts

;;-       !byte $22
;;        rts

;===============================================================================
; decompress text:
;
; params:
;       Y = number of [compressed] bytes to read
;           (value is clobbered on return)
;
; returns:
;       X = number of characters in the buffer to print
;
read_decompress:
        ;-----------------------------------------------------------------------
        lda # 0                                                         ;+2=2
        ; initialise our position within the decompression buffer
        sta zp_read_buffer_index                                        ;+3=5
        ; pre-fill the buffer with spaces
        sta zp_read_buffer+0                                            ;+3=8
        sta zp_read_buffer+1                                            ;+3=11
        sta zp_read_buffer+2                                            ;+3=14
        sta zp_read_buffer+3                                            ;+3=17
        sta zp_read_buffer+4                                            ;+3=20
        sta zp_read_buffer+5                                            ;+3=23
        sta zp_read_buffer+6                                            ;+3=26
        sta zp_read_buffer+7                                            ;+3=29
        sta zp_read_buffer+8                                            ;+3=32
        sta zp_read_buffer+9                                            ;+3=35
        sta zp_read_buffer+10                                           ;+3=38
        sta zp_read_buffer+11                                           ;+3=41
        sta zp_read_buffer+12                                           ;+3=44
        sta zp_read_buffer+13                                           ;+3=47
        sta zp_read_buffer+14                                           ;+3=50
        sta zp_read_buffer+15                                           ;+3=53
        sta zp_read_buffer+16                                           ;+3=56
        sta zp_read_buffer+17                                           ;+3=59
        sta zp_read_buffer+18                                           ;+3=62
        sta zp_read_buffer+19                                           ;+3=65
        sta zp_read_buffer+20                                           ;+3=68
        sta zp_read_buffer+21                                           ;+3=71
        sta zp_read_buffer+22                                           ;+3=74
        sta zp_read_buffer+23                                           ;+3=77
        sta zp_read_buffer+24                                           ;+3=80
        sta zp_read_buffer+25                                           ;+3=83
        sta zp_read_buffer+26                                           ;+3=86
        sta zp_read_buffer+27                                           ;+3=89
        sta zp_read_buffer+28                                           ;+3=92
        sta zp_read_buffer+29                                           ;+3=95
        sta zp_read_buffer+30                                           ;+3=98
        sta zp_read_buffer+31                                           ;+3=101
        sta zp_read_buffer+32                                           ;+3=104
        sta zp_read_buffer+33                                           ;+3=107
        sta zp_read_buffer+34                                           ;+3=110
        sta zp_read_buffer+35                                           ;+3=113
        sta zp_read_buffer+36                                           ;+3=116
        sta zp_read_buffer+37                                           ;+3=119
        sta zp_read_buffer+38                                           ;+3=122
        sta zp_read_buffer+39                                           ;+3=125

        ; compensate for the pre-decrement
        ; nature of reading tokens
        iny

        ; (note that A must be 0 at this point, so as
        ;  to place the terminator on the stack below)

        ;-----------------------------------------------------------------------
        ; the stack has been emptied, fetch more tokens:
        ;
@fetch: dey                     ; move to next token
        beq -                   ; if we reach the end, stop decompressing
        
        ; rather than check the height of the stack, it's easier and faster
        ; to just push a zero on the bottom and when it comes out, push it
        ; back in again. this way we don't have to numerically examine the
        ; stack pointer
        ;
        pha

        lda (zp_read_char), y   ; read a token
        pha                     ; push the token onto the stack for decoding

        ;-----------------------------------------------------------------------
        ; are there any tokens waiting to be decoded?
        ;
        ; (a zero on the bottom of the stack indicates
        ;  when there are no more tokens on the stack)
        ;
@next:  pla
        beq @fetch              ; no? go fetch more tokens

        ; examine the token:
        ;-----------------------------------------------------------------------
        tax                     ; index the token
@count  cpx # $88               ; (placeholder value)
        bcc @print              ; is literal, print it

        ; process token-pair; the left-hand and right-hand bytes
        ; both represent additional tokens; push them onto the
        ; stack for further decoding
        ;
@right  lda $8888, x            ; read the right-hand byte
        pha                     ; push right-hand byte first (2nd out)
@left   lda $8888, x            ; read the left-hand byte
        pha                     ; push that to the top (1st out)

        bcs @next
        brk

        ; literal token:
        ;-----------------------------------------------------------------------
@print: lda nu_text_literals, x ; read the literal's screen-code
        ldx zp_read_buffer_index
        sta zp_read_buffer, x   ; add to the output buffer
        ; move to the next byte in the output buffer
        inc zp_read_buffer_index

        bcc @next
        brk

!addr   .read_literal_count     = @count+1
!addr   .read_tokens_left       = @left+1
!addr   .read_tokens_right      = @right+1
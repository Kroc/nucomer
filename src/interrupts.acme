; the scanlines to use for the pair of raster interrupts:
; since scanlines include the borders, the top of the addressable
; screen begins at 50 and proceeds to 250 where the vblank begins
SCANLINE_VBLANK_END     = 50
SCANLINE_VBLANK_BEGIN   = 250


;-------------------------------------------------------------------------------
!addr   ZP_IRQ          = $ff   ; current index in the table
!addr   ZP_IRQS_LEN     = $fe   ; number of entries in the table
!addr   ZP_IRQS         = $fc   ; address of the table
!addr   ZP_IRQS_LO      = $fc   ; - lo-byte
!addr   ZP_IRQS_HI      = $fd   ; - hi-byte

;===============================================================================
; wait for a given number of frames to pass:
;
;       X = number of frames to wait (1-based)
;
wait_frames:
        ;-----------------------------------------------------------------------
-       jsr wait_frame
        dex
        bne -
        
        rts

wait_frame:
        ;-----------------------------------------------------------------------
        ; wait for a full cycle of the raster beam:
        ;
        ; bit 7 of $D011 is the upper-most bit of the current raster line,
        ; i.e. when it is 0 the beam is on lines 0-255 and when it's 1 the
        ; beam is on lines 256+ -- PAL has 312 lines, NTSC has 262 lines
        ; but some very early NTSC machines have 263 lines
        ;
        ; first, we wait for the beam to enter the top of the screen
        ; (lines 0-255), this is so that if the beam is currently within the
        ; bottom of the screen (lines 256+), we wait for it to go back around
        ; and don't trigger early
        ;
-       bit VIC_SCREEN_VERT
        bmi -                   ; wait until bit 7 is 0

        ; now wait for the addressible screen to pass and the vblank
        ; to begin again, this syncronises the main thread with the vblank
-       bit VIC_SCREEN_VERT
        bpl -                   ; wait until bit 7 is 1

        rts

;===============================================================================
init_interrupts:

        ; disable interrupts whilst we alter them
        sei

        ; turn off all interrupts on CIA1. note that bit 7 is used to fill all
        ; other bits that are given as 1! therefore, the value `%011111111` is
        ; instructing the port to set bits 0-6 to 0, therefore turning off all
        ; timers on the port
        ;
        lda # %01111111
        sta CIA1_INTERRUPT
        ; repeat this also for CIA2 which uses the Non-Maskable-Interrupt
        ; ("NMI") for its timers
        sta CIA2_INTERRUPT

        ; we must 'acknowledge' any currently queued interrupts
        ; or they will fire the instant we re-enable interrupts.
        ; this is done by simply reading the port(s)
        lda CIA1_INTERRUPT
        lda CIA2_INTERRUPT

        ; set the non-maskable interrupt location when the KERNAL is on.
        ; pressing the RESTORE key will fire this routine (unless disabled
        ; -- see comments on `nmi_disable` routine)
        lda #< nmi_debug
        sta KERNAL_VECTOR_NMI+0
        lda #> nmi_debug
        sta KERNAL_VECTOR_NMI+1

        ; likewise, when the KERNAL is off, an NMI handler
        ; must be specified or the machine will crash
        lda #< nmi_debug
        sta HW_VECTOR_NMI+0
        lda #> nmi_debug
        sta HW_VECTOR_NMI+1

        ; put the KERNAL-off interrupt-handler on stand-by
        jmp disable_interrupts

;===============================================================================
; switch off the custom VIC-II raster interrupts:
; (doesn't disable the other interrupts on the CIAs)
;
disable_interrupts:

        sei                     ; disable interrupts whilst we alter them

        ; disable all forms of VIC-II interrupts
        ; (raster, light-pen, sprite collisions)
        lda # %00000000
        sta VIC_INTERRUPT_CONTROL

        ; switch to the minimal interrupt
        ; handler for when the KERNAL is off
        lda #< irq_kernal_off
        sta HW_VECTOR_IRQ+0
        lda #> irq_kernal_off
        sta HW_VECTOR_IRQ+1

        ; and likewise for when the KERNAL is on
        lda #< irq_kernal_on
        sta KERNAL_VECTOR_INTERRUPT+0
        lda #> irq_kernal_on
        sta KERNAL_VECTOR_INTERRUPT+1

        cli                     ; enable interrupts
        rts

;===============================================================================
; the default table of interrupts, consisting of addresses & scanline-numbers:
; the order of the entries is last-to-first as the code reads them backwards
; for speed / simplicity reasons
;
!macro  irqs_table_item         .irq_addr, .scanline {
        !word   .irq_addr
        !byte   (<.scanline)
        !byte   (>.scanline) << 7
}
irqs_default:
        ;-----------------------------------------------------------------------
        ; 2. this raster interrupt occurs as soon as vblank begins. this lets
        ; us time code to the point where the beam is 'off-screen' so we can
        ; begin updating the display, as well as giving us a fixed point to
        ; time / count frames
       +irqs_table_item         irq_nop,        SCANLINE_VBLANK_BEGIN

        ; 1.
       +irqs_table_item         irq_nop,        SCANLINE_VBLANK_END

irq_nop:
        ;=======================================================================
        ; an interrupt shim that does nothing -- used by the default table
        ;
        rts

;===============================================================================
; set up custom interrupts using an interrupt table:
;
;       A = address of IRQ table, lo-byte
;       X = address of IRQ table, hi-byte
;       Y = number of entries in the table (1-based)
;
irqs_load:
        ; disable interrupts whilst we alter them
        sei

        ; configure table
        ;-----------------------------------------------------------------------
        ; set the pointer to the table of interrupt handlers;
        ; whenever an interrupt occurs, this table will
        ; determine the chain of raster interrupts
        ;
        dey                     ; (1-based purely for readability)
        sta ZP_IRQS_LO
        stx ZP_IRQS_HI
        tya
        sta ZP_IRQS_LEN         ; number of entries in the table
        sta ZP_IRQ              ; also set as current index -- we work backward

        ; set the central interrupt handling routine,
        ; this will read the table to chain interrupts
        lda #< irq
        sta HW_VECTOR_IRQ+0
        lda #> irq
        sta HW_VECTOR_IRQ+1

        ; this enables just the raster-interrupt on the VIC-II
        ; (sprite-sprite, sprite-background & lightpen interrupts are disabled)
        lda # %00000001
        sta VIC_INTERRUPT_CONTROL

;; TODO: why is this broken?
;;
;;        ; push a fake "processor status" on to the stack so that the `rti`
;;        ; instruction will have something to pull -- we can't use the actual
;;        ; processor status (`php`) because interrupts are currently disabled
;;        ; and the `rti` would pull this status and disable interrupts!
;;        pha
;;
;;        ; setup the 'next' (first in our case) interrupt by borrowing the
;;        ; code of the central interrupt handler. when the `rti` instruction
;;        ; is encountered the return address already on the stack will be used,
;;        ; effectively reproducing the `rts` for us!
;;        jmp irq_next

        lda ZP_IRQ
        asl                     ; x2
        asl                     ; x4
        tay
        
        ; read the address of the interrupt handler from the table
        ; (for speed, we write the address directly into the code above)
        lda (ZP_IRQS), y
        sta irq_addr+1
        iny
        lda (ZP_IRQS), y
        sta irq_addr+2

        ; set the scanline for the interrupt by reading from the table
        iny
        lda (ZP_IRQS), y        ; read scanline lo-byte
        sta VIC_SCANLINE        ; set the scanline lo-byte

        ; because the height of the screen + borders will be more than 256,
        ; an extra high-bit is included from `VIC_SCREEN_VERT`. the byte in
        ; the table is pre-processed to move this bit from bit 0 to bit 7,
        ; to match the location required for the register
        ;
        iny                     ; move to scanline hi-byte
        lda VIC_SCREEN_VERT     ; get current register value
        eor (ZP_IRQS), y        ; merge the scanline hi-bit (in bit 7)
        sta VIC_SCREEN_VERT     ; update the register

        cli
        rts

;===============================================================================
nmi_debug:
        ;-----------------------------------------------------------------------
        pha
        txa
        pha
        tya
        pha

        lsr $dd0d
        jmp $c006               ; invoke BSOD64!

; exiting without acknowledging the NMI interrupt (via write to $DD0D)
; will effectively disable further NMIs from occuring. further details
; can be read here: https://codebase64.org/doku.php?id=base:nmi_lock
;
nmi_disable:
        ;-----------------------------------------------------------------------
        rti

;===============================================================================
; when the KERNAL is off, but no raster interrupts are in use, this simple
; IRQ handler does the minimum amount necessary to service the interrupt
;
irq_kernal_off:
        ;-----------------------------------------------------------------------
        ; acknowledge the interrupt to prevent it double-firing.
        ; we only need to write to the status register to do this
        inc VIC_INTERRUPT_STATUS

        ; for BSOD64 integration we push the registers to the stack
        pha
        txa
        pha
        tya
        pha

; when the KERNAL ROM is switched on, it controls the interrupt vectors at
; $FFFA-$FFFF. this means that there's some extra indirection that happens
; whenever an IRQ occurs. first, the KERNAL pushes A, X & Y onto the stack
; and then calls the vector at $0314; by default this is the routine that
; handles the BASIC interrupt, e.g. blinking the cursor. if the KERNAL is
; on but BASIC is off, the system will crash!
;
; unless you are writing a BASIC extension there is no reason to keep BASIC
; switched on (you can use the RAM underneath instead), therefore we must
; provide a routine to replace the BASIC interrupt. it doesn't have to do
; any actual work, just merely exit in the correct way, that is, restore
; the register from the stack and call `rti`. alternatively, one can jump
; to $EA81 which is the KERNAL's code to do the same, but I recommend
; against this because that assumes that the machine is a C64 with
; stock ROMs and this might not be the case!
;
irq_kernal_on:
        ;-----------------------------------------------------------------------
        ; check if BRK occurred:
        tsx                     ; we need to look on the stack
        lda $0104, x            ; retrieve the processor flags at interrupt
        and # %00010000         ; check the BRK bit
        beq +
        jmp $c006               ; invoke BSOD64!

        ; pull the registers from the stack
        ; (in reverse order)
+       pla                     ; pull...
        tay                     ; ...Y
        pla                     ; pull...
        tax                     ; ...X
        pla                     ; pull A

        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti

;===============================================================================
; the main interrupt handler that manages the raster interrupt list:
;
; when raster interrupts are enabled, this routine is always called for
; every interrupt and then hands off to the individual handlers provided
; by the IRQ table
;
; in order to make changes to the background / border colour without flicker,
; we need to align the VIC-II write to the "horizontal blank", the very small
; amount of time available whilst the beam "flies back" to the left side of
; the screen. a line is 63 cycles on a PAL machine, 65 on most NTSC machines
; but 64 on very early NTSC machines. we don't have to be absolutely accurate
; in our delay, there's a few cycles worth of jitter in the flyback period
;
irq:                                                                    ;cycles
        ;-----------------------------------------------------------------------
        ; note that an interrupt takes 7 cycles to execute before       ;+7=7
        ; we get to this point

        ; acknowledge the interrupt to prevent it double-firing.
        ; we only need to write to the status register to do this
        inc VIC_INTERRUPT_STATUS                                        ;+6=13

        ; preserve the registers on the stack
        pha                                                             ;+3=16
        txa                                                             ;+2=18
        pha                                                             ;+3=21
        tya                                                             ;+2=23
        pha                                                             ;+3=26

        ; check if BRK occurred:
        ;-----------------------------------------------------------------------
        tsx                     ; we need to look on the stack          ;+2=28
        lda $0104, x            ; retrieve processor flags at interrupt ;+4=32
        and # %00010000         ; check the BRK bit                     ;+2=34
        beq +                                                           ;+3=37
        jmp $c006               ; invoke BSOD64!

        ; process the custom interrupt handler
        ;-----------------------------------------------------------------------
        ; preserve the memory layout (I/O, KERNAL, BASIC). the routines from
        ; the IRQ table will always be executed with I/O on and KERNAL off
        ;
+       lda CPU_CONTROL         ; current memory layout                 ;+3=40
        pha                     ; push to stack                         ;+3=43
        and %11111100           ; strip bottom bits, keep upper bits    ;+2=45
        ora %00000001           ; set memory layout to I/O only         ;+2=47
        sta CPU_CONTROL                                                 ;+3=50

        ; delay just enough so that the call to the handler
        ; will begin around about the flyback period
        nop                                                             ;+2=52
        nop                                                             ;+2=54
        nop                                                             ;+2=56

        ; for speed, the address of the handler will already
        ; have been written directly into this instruction
@addr   jsr $8888                                                       ;+6=62
!addr   irq_addr = @addr

        ; set up next interrupt in the chain:
        ;-----------------------------------------------------------------------
        dec ZP_IRQ              ; move down an index in the table
        bpl @next               ; if last one, we need to loop the table

        lda ZP_IRQS_LEN
        sta ZP_IRQ
        
@next   ; (each table entry is 4 bytes so we have to scale up the index)
!addr   irq_next = @next
        
        lda ZP_IRQ
        asl                     ; x2
        asl                     ; x4
        tay
        
        ; read the address of the interrupt handler from the table
        ; (for speed, we write the address directly into the code above)
        lda (ZP_IRQS), y
        sta @addr+1
        iny
        lda (ZP_IRQS), y
        sta @addr+2

        ; set the scanline for the interrupt by reading from the table
        iny
        lda (ZP_IRQS), y        ; read scanline lo-byte
        sta VIC_SCANLINE        ; set the scanline lo-byte

        ; because the height of the screen + borders will be more than 256,
        ; an extra high-bit is included from `VIC_SCREEN_VERT`. the byte in
        ; the table is pre-processed to move this bit from bit 0 to bit 7,
        ; to match the location required for the register
        ;
        iny                     ; move to scanline hi-byte
        lda VIC_SCREEN_VERT     ; get current register value
        eor (ZP_IRQS), y        ; merge the scanline hi-bit (in bit 7)
        sta VIC_SCREEN_VERT     ; update the register

        ; finish interrupt:
        ;-----------------------------------------------------------------------
        pla                     ; restore the memory layout
        sta CPU_CONTROL

        pla
        tay
        pla
        tax
        pla

        rti


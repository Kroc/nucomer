; the scanlines to use for the pair of raster interrupts:
; since scanlines include the borders, the top of the addressable
; screen begins at 50 and proceeds to 250 where the vblank begins
SCANLINE_VBLANK_END     = 50
SCANLINE_VBLANK_BEGIN   = 250

isVBlank:
        ; flag to indicate if the raster is within the VBlank
        ; (out of addressable screen area). $00 = no, $FF = yes
        !byte $00

wait_frames:
        ;=======================================================================
        ; wait for a given number of frames to pass:
        ;
        ;       X = number of frames to wait (1-based)
        ;
-       jsr wait_frame
        dex
        bne -
        
        rts

wait_frame:
        ;=======================================================================
        ; wait for a full cycle of the raster interrupts:
        ;
        ; first, wait until the vblank flag goes from on to off; that is, wait
        ; for a vblank period to complete in case the raster beam is already
        ; within the vblank
        ;
-       bit isVBlank
        bmi -                   ; wait until bit 7 is 0 (isVBlank = $00)

        ; now wait for the addressible screen to pass and the vblank
        ; to begin again, this syncronises the main thread with the vblank
-       bit isVBlank
        bpl -                   ; wait until bit 7 is 1 (isVBlank = $FF)

        rts

setup_interrupts:
;===============================================================================
        sei

        ; set non-maskable interrupt location when the KERNAL is on.
        ; pressing the RESTORE key will fire this routine
        ;
        ; note that when the KERNAL is switched off, the RAM underneath will
        ; define the NMI interrupt address -- this gets rectified below
        ;
        lda #< nmi
        sta KERNAL_VECTOR_NMI+0
        lda #> nmi
        sta KERNAL_VECTOR_NMI+1

        ; non-maskable interrupt:
        lda #< nmi
        sta HW_VECTOR_NMI+0
        lda #> nmi
        sta HW_VECTOR_NMI+1

        ; regular interrupt:
        lda #> interrupt_vblank_begin
        sta HW_VECTOR_IRQ+1
        lda #< interrupt_vblank_begin
        sta HW_VECTOR_IRQ+0

        lda # $00
        sta isVBlank
        
        ; configure the raster interrupt to occure as soon as vblank begins:
        ; this lets us time code to the point where the beam is 'off-screen'
        ; so we can begin updating the display, as well as giving us a fixed
        ; point to time/count frames
        ;-----------------------------------------------------------------------
        ; first, turn off all interrupts on CIA1. note that bit 7 is used to
        ; fill all other bits that are given as 1! therefore, the value
        ; `%011111111` is instructing the port to set bits 0-6 to 0,
        ; therfore turning off all timers on the port
        ;
        lda # %01111111
        sta CIA1_INTERRUPT
        ; repeat this also for CIA2 which uses the Non-Maskable-Interrupt
        ; ("NMI") for its timers
        sta CIA2_INTERRUPT

        ; we must 'acknowledge' any currently queued interrupts
        ; or they will fire the instant we re-enable interrupts.
        ; this is done by simply reading the port
        lda CIA1_INTERRUPT
        lda CIA2_INTERRUPT

        ; this enables just the raster-interrupt on the VIC-II
        ; (sprite-sprite, sprite-background & lightpen interrupts are disabled)
        lda # %00000001
        sta VIC_INTERRUPT_CONTROL

        ; now we must set at which line the raster interrupt should occur.
        ; this includes the borders, so the top of the addressable screen is
        ; at 50, not 0. this makes the bottom of the screen at line 250
        ;
        ; because the height of the screen + borders will be more than 256,
        ; an extra high-bit is included from `VIC_SCREEN_CTL1`. in our case
        ; this bit is not required
        ;
        lda # SCANLINE_VBLANK_BEGIN
        sta VIC_RASTER
        
        ; turn off BASIC & KERNAL ROM
        dec CPU_CONTROL
        dec CPU_CONTROL

        cli                     ; enable interrupts
        rts

nmi:
;===============================================================================
; exiting without acknowledging the interrupt (via write to $DD0D)
; will effectively disable further NMIs from occuring. further details
; can be read here: https://codebase64.org/doku.php?id=base:nmi_lock

        rti

interrupt_vblank_begin:
;===============================================================================
;;        inc VIC_BORDER

        ; acknowledge the interrupt to prevent it double-firing.
        ; we only need to write to it to do this
        inc VIC_INTERRUPT_STATUS

        dec isVBlank

        ; backup A register by writing it to an LDA at end of routine --
        ; https://codebase64.org/doku.php?id=base:introduction_to_raster_irqs
        sta @a+1

        ; set the next interrupt routine address
        lda #> interrupt_vblank_end
        sta HW_VECTOR_IRQ+1
        lda #< interrupt_vblank_end
        sta HW_VECTOR_IRQ+0

        lda # SCANLINE_VBLANK_END
        sta VIC_RASTER

@a:     lda # $ff               ; restore the A register
        rti

interrupt_vblank_end:
;===============================================================================
;;        dec VIC_BORDER

        ; acknowledge the interrupt to prevent it double-firing.
        ; we only need to write to it to do this
        inc VIC_INTERRUPT_STATUS

        inc isVBlank

        ; backup A register by writing it to an LDA at end of routine --
        ; https://codebase64.org/doku.php?id=base:introduction_to_raster_irqs
        sta @a+1

        ; set the next interrupt routine address
        lda #> interrupt_vblank_begin
        sta HW_VECTOR_IRQ+1
        lda #< interrupt_vblank_begin
        sta HW_VECTOR_IRQ+0

        lda # SCANLINE_VBLANK_BEGIN
        sta VIC_RASTER

@a:     lda # $ff               ; restore the A register
        rti

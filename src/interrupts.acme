; the scanlines to use for the pair of raster interrupts:
; since scanlines include the borders, the top of the addressable
; screen begins at 50 and proceeds to 250 where the vblank begins
SCANLINE_VBLANK_END     = 50
SCANLINE_VBLANK_BEGIN   = 250

; a pointer in the zero-page to the table of interrupt handlers
;-------------------------------------------------------------------------------
!addr   ZP_IRQS         = $02
!addr   ZP_IRQS_LO      = $02
!addr   ZP_IRQS_HI      = $03
!addr   ZP_IRQS_LEN     = $04   ; number of enteries in the table
!addr   ZP_IRQ          = $05   ; current index in the table

frameReady:
;-------------------------------------------------------------------------------
        ; flag to indicate if the interrupt loop has completed.
        ; used to indicate that the frame is complete and the
        ; next one can be started. $00 = no, $FF = yes
        !byte $00

;===============================================================================
; wait for a given number of frames to pass:
;
;       X = number of frames to wait (1-based)
;
wait_frames:

-       jsr wait_frame
        dex
        bne -
        
        rts

wait_frame:
        ;=======================================================================
        ; wait for a full cycle of the raster interrupts:
        ;
        ; first, wait until the ready flag goes from on to off; that is, wait
        ; for a vblank period to complete in case the raster beam is already
        ; within the vblank
        ;
-       bit frameReady
        bmi -                   ; wait until bit 7 is 0 (frameReady = $00)

        ; now wait for the addressible screen to pass and the vblank
        ; to begin again, this syncronises the main thread with the vblank
-       bit frameReady
        bpl -                   ; wait until bit 7 is 1 (frameReady = $FF)

        rts

;===============================================================================
; exiting without acknowledging the interrupt (via write to $DD0D)
; will effectively disable further NMIs from occuring. further details
; can be read here: https://codebase64.org/doku.php?id=base:nmi_lock
;
nmi:
        rti

;===============================================================================
setup_interrupts:
        ; disable interrupts whilst we alter them
        sei

        ; turn off BASIC & KERNAL ROM
        dec CPU_CONTROL
        dec CPU_CONTROL

        ; non-maskable interrupt:
        ;-----------------------------------------------------------------------
        ; set non-maskable interrupt location when the KERNAL is on.
        ; pressing the RESTORE key will fire this routine
        ;
        ; note that when the KERNAL is switched off, the RAM underneath will
        ; define the NMI interrupt address -- this gets rectified below
        ;
        lda #< nmi
        sta KERNAL_VECTOR_NMI+0
        lda #> nmi
        sta KERNAL_VECTOR_NMI+1

        ; non-maskable interrupt:
        lda #< nmi
        sta HW_VECTOR_NMI+0
        lda #> nmi
        sta HW_VECTOR_NMI+1

        ; raster interrupts:
        ;-----------------------------------------------------------------------
        ; configure raster interrupts using the default interrupt table
        lda #< irqs_default
        ldx #> irqs_default
        ldy # 2
        ; (note this automatically re-enables interrupts)
        jmp irqs_load

;===============================================================================
; the default table of interrupts, consisting of addresses & scanline-numbers:
; the order of the entries is last-to-first as the code reads them backwards
; for speed / simplicity reasons
;
!macro  irqs_table_item         .irq_addr, .scanline {
        !word   .irq_addr
        !byte   (<.scanline)
        !byte   (>.scanline) << 7
}
irqs_default:
        ;-----------------------------------------------------------------------
        ; 2. this raster interrupt occurs as soon as vblank begins. this lets
        ; us time code to the point where the beam is 'off-screen' so we can
        ; begin updating the display, as well as giving us a fixed point to
        ; time / count frames
       +irqs_table_item         irq_nop,        SCANLINE_VBLANK_BEGIN

        ; 1.
       +irqs_table_item         irq_nop,        SCANLINE_VBLANK_END

irq_nop:
        ;=======================================================================
        ; an interrupt that does nothing -- used by the default table so that
        ; the frame ready flag toggles at the right places, but nothing needs
        ; to be altered on the screen at the splits
        ;
        rts

;===============================================================================
; set up custom interrupts using an interrupt table:
;
;       A = address of IRQ table, lo-byte
;       X = address of IRQ table, hi-byte
;       Y = number of entries in the table (1-based)
;
irqs_load:
        ; disable interrupts whilst we alter them
        sei

        ; configure table
        ;-----------------------------------------------------------------------
        ; set the pointer to the table of interrupt handlers;
        ; whenever an interrupt occurs, this table will
        ; determine the chain of raster interrupts
        ;
        dey                     ; (1-based purely for readability)
        sta ZP_IRQS_LO
        stx ZP_IRQS_HI
        tya
        sta ZP_IRQS_LEN         ; number of entries in the table
        sta ZP_IRQ              ; also set as current index -- we work backward

        ; turn off all interrupts on CIA1. note that bit 7 is used to fill all
        ; other bits that are given as 1! therefore, the value `%011111111` is
        ; instructing the port to set bits 0-6 to 0, therfore turning off all
        ; timers on the port
        ;
        lda # %01111111
        sta CIA1_INTERRUPT
        ; repeat this also for CIA2 which uses the Non-Maskable-Interrupt
        ; ("NMI") for its timers
        sta CIA2_INTERRUPT

        ; we must 'acknowledge' any currently queued interrupts
        ; or they will fire the instant we re-enable interrupts.
        ; this is done by simply reading the port
        lda CIA1_INTERRUPT
        lda CIA2_INTERRUPT

        ; this enables just the raster-interrupt on the VIC-II
        ; (sprite-sprite, sprite-background & lightpen interrupts are disabled)
        lda # %00000001
        sta VIC_INTERRUPT_CONTROL

        ; set the central interrupt handling routine,
        ; this will read the table to chain interrupts
        lda #< irq
        sta HW_VECTOR_IRQ+0
        lda #> irq
        sta HW_VECTOR_IRQ+1

        lda # $00
        sta frameReady

        ; push a fake "processor status" on to the stack so that the `rti`
        ; instruction will have something to pull -- we can't use the actual
        ; processor status (`php`) because interrupts are currently disabled
        ; and the `rti` would pull this status and disable interrupts!
        pha

        ; setup the 'next' (first in our case) interrupt by borrowing the
        ; code of the central interrupt handler. when the `rti` instruction
        ; is encountered the return address already on the stack will be used,
        ; effectively reproducing the `rts` for us!
        jmp irq_next

;===============================================================================
; the main interrupt handler that manages the interrupt list:
;
; this routine is always called for every interrupt and then
; hands off to the individual handlers provided by the IRQ list
;
irq_busy:
        inc frameReady

        lda #< irq
        sta HW_VECTOR_IRQ+0
        lda #> irq
        sta HW_VECTOR_IRQ+1
irq:
        ;=======================================================================
        ; acknowledge the interrupt to prevent it double-firing.
        ; we only need to write to it to do this
        inc VIC_INTERRUPT_STATUS

        ; backup the A register by writing it to an LDA at end of routine --
        ; https://codebase64.org/doku.php?id=base:introduction_to_raster_irqs
        sta @a+1

        ; process the custom interrupt handler
        ;-----------------------------------------------------------------------
        ; for speed, the address of the handler will already
        ; have been written into this instruction
@addr   jsr $8888
!addr   irq_addr = @addr

        ; set up next interrupt in the chain:
        ;-----------------------------------------------------------------------
        dec ZP_IRQ              ; move down an index in the table
        bpl @next               ; if last one, we need to loop the table

        lda ZP_IRQS_LEN
        sta ZP_IRQ
        
        ; when all interrupts in the table have been processed, the frame is
        ; 'complete'. when the next interrupt happens the frame will go 'busy'
        ; for frame synchronisation, your 'last' interrupt (first in the table)
        ; should be where vblank begins -- line 250
        dec frameReady

        lda #< irq_busy
        sta HW_VECTOR_IRQ+0
        lda #> irq_busy
        sta HW_VECTOR_IRQ+1
        
        ; (each table entry is 4 bytes so we have to scale up the index)
@next
!addr   irq_next = @next
        
        lda ZP_IRQ
        asl                     ; x2
        asl                     ; x4
        
        ; now that we need to use Y,
        ; we have to back it up
        sty @y+1
        tay
        
        ; read the address of the interrupt handler from the table
        ; (for speed, we write the address directly into the code above)
        lda (ZP_IRQS), y
        sta @addr+1
        iny
        lda (ZP_IRQS), y
        sta @addr+2

        ; set the scanline for the interrupt by reading from the table
        iny
        lda (ZP_IRQS), y        ; read scanline lo-byte
        sta VIC_SCANLINE        ; set the scanline lo-byte

        ; because the height of the screen + borders will be more than 256,
        ; an extra high-bit is included from `VIC_SCREEN_CTL1`. the byte in
        ; the table is pre-processed to move this bit from bit 0 to bit 7,
        ; to match the location required for the register
        ;
        iny                     ; move to scanline hi-byte
        lda VIC_SCREEN_CTL1     ; get current register value
        eor (ZP_IRQS), y        ; merge the scanline hi-bit (in bit 7)
        sta VIC_SCREEN_CTL1     ; update the register

        ; finish interrupt:
        ;-----------------------------------------------------------------------
@y      ldy # $88               ; restore Y register
@a      lda # $88               ; restore A register
        rti
; the main menu page, i.e. the front-page / directory of the magazine

; theme colours
MENU_BORDER     = BLACK
MENU_FORE       = BLACK
MENU_BACK       = LTGREY

; currently selected menu item
!addr   ZP_MENU_INDEX           = $10

;===============================================================================
; table of interrupts to use for the menu screen:
;
menu_irqs:
        ;-----------------------------------------------------------------------
       +irqs_table_item menu_irq_vblank,        SCANLINE_VBLANK_BEGIN
       +irqs_table_item menu_irq_logo_end,      SCANLINE_VBLANK_END + (3 * 8)-1
       +irqs_table_item menu_irq_logo,          SCANLINE_VBLANK_END + (2 * 8)-1
       +irqs_table_item menu_irq_logo,          SCANLINE_VBLANK_END + (1 * 8)-1

menu_irq_logo:
        ;-----------------------------------------------------------------------
        ; note that the global interrupt handler `irq` (see "interrupts.acme"),
        ; has delayed up to the horizontal blank, so we can change colours
        ; immediately and there won't be any flicker
        ;
        lda # DKGREY
        sta VIC_BORDER

        ; now kill enough time for a whole line
        ; TODO: time this more accurately (~63-65 cycles)
        ldx # 11
-       dex
        bne -

        ; go back to black
        stx VIC_BORDER

        rts

menu_irq_logo_end:
        ;-----------------------------------------------------------------------
        ; note that the global interrupt handler `irq` (see "interrupts.acme"),
        ; has delayed up to the horizontal blank, so we can change colours
        ; immediately and there won't be any flicker
        ;
        lda # DKGREY
        sta VIC_BORDER
        lda # LTGREY
        sta VIC_BACKGROUND

        ; now kill enough time for a whole line
        ; TODO: time this more accurately (~63-65 cycles)
        ldx # 10
-       dex
        bne -
        ; go back to black
        stx VIC_BORDER

        ; kill enough time to get out of the left-hand border before we change
        ; the colour. TODO: time this more accurately
        ldx # 3
-       dex
        bne -

        lda # LTGREY
        sta VIC_BORDER

        rts

menu_irq_vblank:
        ;-----------------------------------------------------------------------
        lda # MENU_BORDER
        sta VIC_BORDER
        sta VIC_BACKGROUND
        rts

;===============================================================================
menu_screen:
        ;-----------------------------------------------------------------------
        ; setup the screen:
        ; turn the screen off whilst we clear it
        lda # %00001000
        sta VIC_SCREEN_CTL1
        
        ; set our own interrupt handlers
        ; A = address of IRQ table, lo-byte
        ; X = address of IRQ table, hi-byte
        ; Y = number of entries in the table (1-based)
        ;
        lda #< menu_irqs
        ldx #> menu_irqs
        ldy # 4
        jsr irqs_load

        ; set screen colour
        lda # MENU_BORDER
        sta VIC_BORDER
        lda # MENU_BACK
        sta VIC_BACKGROUND

        ; erase the text-screen
        lda # MENU_FORE
        jsr clear_screen

        ; print logo:
        ;-----------------------------------------------------------------------
        ; print the logo with the base colour;
        ; we're going to recolour just the letters
        lda # DKGREY
        sta ZP_PRINT_COLOR
       +print_str_pos       menu_petscii_logo

        ; begin at the end of the logo and work backwards
        ; (easier for loop management to count toward 0)
        ldy # (3 * 40)
        ldx # BLUE      ; colour of letters

-       dey
        bmi +           ; finished?

        lda $0400, y    ; read a character from the logo
        cmp # $64       ; is the character a background-line?
        beq -           ; yes, skip it and don't change the colour
        txa
        sta $d800, y
        bpl -           ; (always branches)

+       lda # BLACK
        sta ZP_PRINT_COLOR
        
        ldx # 40
        lda # $63
-       dex
        sta $0400 + (3 * 40), x
        bne -

       +print_str_pos   menu_subline

        ; print menu items:
        ;-----------------------------------------------------------------------
        ; select the first menu item by default
        lda # 0
        sta ZP_MENU_INDEX
        
        ; draw the menu items on the screen
        jsr menu_refresh

        ; turn screen on
        lda # %00011011
        sta VIC_SCREEN_CTL1
        
menu_keyboard:
        ;-----------------------------------------------------------------------
        ; debounce the keyboard by waiting for no keypress
        ;
-       jsr Keyboard            ; check current state of keyboard
        bcc -                   ; if key pressed, keep checking

        ; now await a keypress
-       jsr Keyboard
        bcs -

        ; load article?
@enter  cpx # %00000010         ; check RETURN-key bit
        bne @crsr               ; no? maybe cursor keys?
        jmp menu_load           ; load & show the article

        ; cursor up/down?
@crsr   cpx # %10000000         ; check CRSR-key bit
        bne @stop               ; no? what other keys are pressed?
        
        ; up, or down?
        tya
        and # %01010000         ; are either of the shift keys pressed?
        bne @up                 ; if yes, it's CRSR-UP

        ; crsr-dn: move to the next menu item
@dn     ldy ZP_MENU_INDEX       ; what's the currently selected menu item?
        iny                     ; if we were to move down...
        cpy # MENU_DB_COUNT     ; would we go below the bottom? (1-based)
        beq menu_keyboard       ; if at the bottom, move no further
        inc ZP_MENU_INDEX
        jsr menu_refresh
        jmp menu_keyboard

        ; crsr-up: move to the previous menu item
@up     ldy ZP_MENU_INDEX       ; what's the currently selected menu item?
        dey                     ; if we were to move up?
        bmi menu_keyboard       ; if already at top, move no further
        dec ZP_MENU_INDEX
        jsr menu_refresh
        jmp menu_keyboard

        ; run/stop: invoke BSOD64
@stop   cpy # %10000000
        bne @next
        brk

        ;-----------------------------------------------------------------------
@next   jmp menu_keyboard

;===============================================================================
; draw the article titles on the screen:
;
; the number of articles, and their names are provided by a file
; "build/menu_db.acme" that is generated by the build process
; when converting the articles into a C64-readable format
;
menu_refresh:
        ;-----------------------------------------------------------------------
        ; the menu-count is 1-based; subtract 1 to avoid printing garbage.
        ; we also render the menu items from last to first for speed purposes
        ldy # MENU_DB_COUNT
        dey
        
        ; position the cursor:
        ;-----------------------------------------------------------------------
-       lda menu_db_cols, y     ; get the column
        tax                     ; in X
        sty @i+1                ; (backup index)
        lda menu_db_rows, y     ; get the row
        tay                     ; in Y
        jsr print_set_crsr      ; set cursor: Y = row, X = col

        ; set the text colour:
        ;-----------------------------------------------------------------------
@i      ldy # $88               ; retrieve the menu index
        cpy ZP_MENU_INDEX       ; is this the selected menu item?
        bne +                   ; no, use standard colour
        lda # BLACK             ; yes, use selected colour
       +bit_skip2               ; skip over the next instruction
+       lda # DKGREY
        sta ZP_PRINT_COLOR

        ; print the string:
        ;-----------------------------------------------------------------------
        lda menu_db_strlo, y    ; load the string address lo-byte...
        tax                     ; ...into X
        lda menu_db_strhi, y    ; load the string address hi-byte into A
        jsr print_str           ; print the string!
        dey
        bpl -

        ; mark the selected menu item:
        ;-----------------------------------------------------------------------
        ldy ZP_MENU_INDEX
        lda menu_db_cols, y     ; column number
        tax                     ; must be in X
        lda menu_db_rows, y     ; row in Y
        jsr print_get_crsr      ; returns X = addr lo-byte, A = addr hi-byte
        stx @scr+1              ; set screen address lo-byte
        stx @color+1            ; mirror this in the screen RAM
        sta @scr+2              ; set screen address hi-byte
        clc                     ; to mirror this in the colour RAM, add the
        adc # >($d800 - $0400)  ; distance between screen RAM & colour RAM
        sta @color+2            ; e.g. $0508 -> $D908

        lda # $db               ; screen code for marker symbol
@scr    sta $8888
        lda # BLACK
@color  sta $8888

        rts

;===============================================================================
; load an article:
; TODO: transition screen out
;
menu_load:
        ;-----------------------------------------------------------------------
        ; turn the screen off
        lda # %00001000
        sta VIC_SCREEN_CTL1
        ; tear down the custom interrupt handlers
        jsr irqs_disable
        
        ; set the KERNAL load properties:
        sei                     ; disable interrupts
        inc CPU_CONTROL         ; enable the KERNAL

        ; get the last-used device
        ; number set by the KERNAL
        ldx ZP_KERNAL_DEV
        bne +                   ; not 0? good
        ldx # DEV_DRV8          ; default to drive 8
+       ldy # $00               ; use custom load address
        tya                     ; logical file number
        jsr KERNAL_SETLFS
        
        ; read the address of the filename:
        ldy ZP_MENU_INDEX       ; currently selected menu item
        lda menu_db_prg_lens, y ; get string length from the menu database
        pha                     ; put aside whilst we reuse register A
        
        ; the file names are all padded to 16-bytes,
        ; so we only need to multiply the index to fit
        tya
        ; TODO: this is an 8-bit result so we are limited to 16 menu items
        asl                     ; x2...
        asl                     ; x4...
        asl                     ; x8...
        asl                     ; x16
        clc
        adc #< menu_db_prg_strs ; add this offset to the table of program names
        tax                     ; program name address lo-byte in X
        lda #> menu_db_prg_strs
        adc # 0
        tay                     ; program name address hi-byte in Y
        pla                     ; A is string-length
        jsr KERNAL_SETNAM       ; set KERNAL file name

        lda # 0                 ; load, not verify
        ldx #< $1ffe
        ldy #> $1ffe
        jsr KERNAL_LOAD

        ; TODO: error handling, fastloader et al
        bcc +
        jsr bsod64_jsr
        
+       dec CPU_CONTROL         ; turn KERNAL off
        cli
        
        ; switch to the reading screen...
        jsr read_screen
        ; upon return, restart the screen
        jmp menu_screen

menu_petscii_logo:
;===============================================================================
        !byte   0, 0
!ct "build/petscii_font.ct" {
        !text   " ---- =  = ---- ---- ----- ---- ----    "
        !text   " #  # #  # #    #  # # # # #___ #       "
        !text   " #  # #__# #___ #__# # # # #___ #       ", 0
}
menu_subline:
        !byte   4, 31
        !scr    "issue #0", 0

menu_db:
;===============================================================================
!source "build/menu_db.acme"
